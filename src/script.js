// Menu Management Utility
function closeAllMenus() {
    const startMenu = document.getElementById('start-menu');
    if (startMenu) startMenu.classList.remove('show');
    const virtualDesktopOverlay = document.getElementById('virtual-desktop-overlay');
    if (virtualDesktopOverlay) virtualDesktopOverlay.classList.remove('show');
}

// Boot Screen (Splash) - shown for a fixed duration before login screen appears.
const BOOT_DURATION_MS = 10000;
let bootInProgress = false;

function _sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Best-effort wipe of this origin's persisted data (used for "Shutdown").
async function wipeSiteData() {
    // 1) Web Storage
    try { localStorage.clear(); } catch (e) {}
    try { sessionStorage.clear(); } catch (e) {}

    // 2) Cookies (best effort; may not clear HttpOnly cookies)
    try {
        const cookies = (document.cookie || '').split(';').map(c => c.trim()).filter(Boolean);
        cookies.forEach(c => {
            const eq = c.indexOf('=');
            const name = eq >= 0 ? c.slice(0, eq) : c;
            // Expire at root path.
            document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
        });
    } catch (e) {}

    // 3) CacheStorage
    try {
        if (typeof caches !== 'undefined' && caches && typeof caches.keys === 'function') {
            const keys = await caches.keys();
            await Promise.all((keys || []).map(k => caches.delete(k)));
        }
    } catch (e) {}

    // 4) Service workers (if present)
    try {
        if (navigator.serviceWorker && typeof navigator.serviceWorker.getRegistrations === 'function') {
            const regs = await navigator.serviceWorker.getRegistrations();
            await Promise.all((regs || []).map(r => r.unregister()));
        }
    } catch (e) {}

    // 5) IndexedDB (delete all DBs for this origin, including PilkOS filesystem)
    try {
        const deleteDb = (name) => new Promise((resolve) => {
            try {
                const req = indexedDB.deleteDatabase(name);
                req.onsuccess = () => resolve();
                req.onerror = () => resolve();
                req.onblocked = () => resolve();
            } catch (e) {
                resolve();
            }
        });

        const names = new Set(['PilkOS_FileSystem']);
        if (indexedDB && typeof indexedDB.databases === 'function') {
            const dbs = await indexedDB.databases();
            (dbs || []).forEach(db => {
                if (db && db.name) names.add(db.name);
            });
        }
        await Promise.all(Array.from(names).map(n => deleteDb(n)));
    } catch (e) {}
}

async function runBootSequence({ durationMs = BOOT_DURATION_MS } = {}) {
    // Prevent overlapping boot sequences.
    if (bootInProgress) return;
    bootInProgress = true;

    const boot = document.getElementById('boot-screen');
    if (!boot) {
        bootInProgress = false;
        return;
    }

    // Hide desktop + login while booting (boot screen should block all interaction).
    const loginScreen = document.getElementById('login-screen');
    const desktop = document.getElementById('desktop');
    if (loginScreen) {
        loginScreen.classList.add('hidden');
        loginScreen.style.display = 'none';
        loginScreen.style.pointerEvents = 'none';
    }
    if (desktop) {
        desktop.style.display = 'none';
        desktop.style.pointerEvents = 'none';
    }

    // Ensure boot is visible immediately.
    boot.style.display = 'flex';
    boot.classList.remove('boot-hide');
    boot.classList.add('boot-show');

    // "Realistic" progress: fast start, slow middle with small stalls, then finalize near the end.
    const bar = boot.querySelector('.boot-progress-bar');
    if (bar) {
        bar.style.width = '0%';
        try { bar.style.animation = 'none'; } catch (e) {}
    }

    const ms = Math.max(0, Number(durationMs) || 0);

    const easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
    const easeInQuad = (t) => t * t;
    const easeInOutCubic = (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);
    const lerp = (a, b, t) => a + (b - a) * t;

    const animateProgress = async () => {
        if (!bar) return;
        const startedAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        let current = 0;

        const tick = async () => {
            const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            const t = ms <= 0 ? 1 : Math.min(1, (now - startedAt) / ms);

            // Base curve: jump early, then slow, then finish late.
            let desired;
            if (t < 0.15) {
                desired = lerp(0, 35, easeOutQuad(t / 0.15));
            } else if (t < 0.75) {
                desired = lerp(35, 92, easeInOutCubic((t - 0.15) / 0.60));
            } else if (t < 0.95) {
                desired = lerp(92, 98, easeOutQuad((t - 0.75) / 0.20));
            } else {
                desired = lerp(98, 100, easeInQuad((t - 0.95) / 0.05));
            }
            desired = Math.max(0, Math.min(100, desired));

            // Add "work" feel: occasional micro-stalls + variable step size toward the desired point.
            const remaining = desired - current;
            if (remaining > 0) {
                const inMid = t > 0.20 && t < 0.90;
                const stallChance = inMid ? 0.28 : 0.12;
                const shouldStall = Math.random() < stallChance;
                if (!shouldStall) {
                    const dynamicMax = t < 0.30 ? 3.6 : (t < 0.80 ? 2.1 : 1.2);
                    const step = Math.min(remaining, 0.25 + Math.random() * dynamicMax);
                    current = Math.min(100, current + step);
                }
            }

            bar.style.width = `${current.toFixed(2)}%`;

            if (t >= 1) {
                // Guarantee completion.
                bar.style.width = '100%';
                return;
            }

            // Irregular cadence helps sell "loading different subsystems".
            const delay = 90 + Math.random() * 180;
            await _sleep(delay);
            return tick();
        };

        return tick();
    };

    const began = Date.now();
    await Promise.all([animateProgress(), _sleep(ms)]);
    const elapsed = Date.now() - began;
    if (elapsed < ms) {
        await _sleep(ms - elapsed);
    }

    // Fade out boot screen.
    boot.classList.remove('boot-show');
    boot.classList.add('boot-hide');
    await _sleep(650);
    boot.style.display = 'none';
    boot.classList.remove('boot-hide');

    bootInProgress = false;
}

// Dock Menu Positioning Utilities
const DOCK_MENU_GAP_PX = 6;
const DOCK_MENU_VIEWPORT_PADDING = 8;
const WINDOW_EDGE_GAP_PX = 6;
const WINDOW_DOCK_GAP_PX = 6;

function getWindowBounds() {
    const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
    const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
    const dock = document.querySelector('.dock');
    const dockTop = dock ? dock.getBoundingClientRect().top : viewportHeight;
    const maxBottom = Math.max(WINDOW_EDGE_GAP_PX, Math.min(viewportHeight, dockTop) - WINDOW_DOCK_GAP_PX);
    const maxRight = Math.max(WINDOW_EDGE_GAP_PX, viewportWidth - WINDOW_EDGE_GAP_PX);
    const maxWidth = Math.max(1, maxRight - WINDOW_EDGE_GAP_PX);
    const maxHeight = Math.max(1, maxBottom - WINDOW_EDGE_GAP_PX);

    return {
        viewportWidth,
        viewportHeight,
        minLeft: WINDOW_EDGE_GAP_PX,
        minTop: WINDOW_EDGE_GAP_PX,
        maxRight,
        maxBottom,
        maxWidth,
        maxHeight,
    };
}

function getDockMenuLeftPx() {
    const dock = document.querySelector('.dock');
    if (dock) {
        const rect = dock.getBoundingClientRect();
        return rect.left + DOCK_MENU_GAP_PX;
    }
    return DOCK_MENU_GAP_PX;
}

function clampDockMenuLeft(left, menuWidth) {
    const minLeft = DOCK_MENU_VIEWPORT_PADDING;
    const maxLeft = Math.max(minLeft, window.innerWidth - menuWidth - DOCK_MENU_VIEWPORT_PADDING);
    return Math.min(maxLeft, Math.max(minLeft, left));
}

function positionDockMenuForControl(menuEl, controlRect, options = {}) {
    const dock = _getDockEl();
    if (!dock) return;
    const menuWidth = menuEl.offsetWidth || options.menuWidth || 220;
    const dockRect = dock.getBoundingClientRect();
    const iconCenterX = controlRect.left + (controlRect.width / 2);
    const menuLeft = clampDockMenuLeft(iconCenterX - (menuWidth / 2), menuWidth);
    const menuBottom = Math.max(0, window.innerHeight - dockRect.top + DOCK_MENU_GAP_PX);
    menuEl.style.left = menuLeft + 'px';
    menuEl.style.bottom = menuBottom + 'px';
    menuEl.style.top = 'auto';
    menuEl.style.right = 'auto';
}

// Dock Auto-Hide (Settings > Dock)
const DOCK_AUTO_HIDE_STORAGE_KEY = 'dockAutoHide';
const DOCK_AUTO_HIDE_EDGE_PX = 2; // moving the mouse to the left/bottom edge reveals the dock
const DOCK_AUTO_HIDE_REVEAL_STRIP_PX = 4; // keep a tiny sliver visible for affordance
const DOCK_AUTO_HIDE_DELAY_MS = 650;

let _dockAutoHideInitialized = false;
let _dockAutoHideEnabled = false;
let _dockAutoHideHidden = false;
let _dockAutoHidePointerInside = false;
let _dockAutoHideHideTimeout = null;
let _dockAutoHideLastMouseY = Number.NEGATIVE_INFINITY;

function _getDockEl() {
    return document.querySelector('.dock');
}

function _isDesktopVisible() {
    const desktop = document.getElementById('desktop');
    return !!desktop && desktop.style.display !== 'none';
}

function _updateDockHideCssVar() {
    const dock = _getDockEl();
    if (!dock) return;
    const rect = dock.getBoundingClientRect();
    const height = Math.max(1, rect.height || 60);
    const hideY = Math.max(0, height - DOCK_AUTO_HIDE_REVEAL_STRIP_PX);
    dock.style.setProperty('--dock-hide-y', `${hideY}px`);
}

function _isDockEdgeRevealActive() {
    return _dockAutoHideLastMouseY >= window.innerHeight - DOCK_AUTO_HIDE_EDGE_PX;
}

function _setDockHidden(hidden) {
    const dock = _getDockEl();
    if (!dock) return;
    _updateDockHideCssVar();
    _dockAutoHideHidden = !!hidden;
    dock.classList.toggle('dock-auto-hide-hidden', _dockAutoHideHidden);
}

function _showDock() {
    clearTimeout(_dockAutoHideHideTimeout);
    _dockAutoHideHideTimeout = null;
    _setDockHidden(false);
}

function _scheduleDockHide() {
    if (!_dockAutoHideEnabled) return;
    if (!_isDesktopVisible()) return;
    if (_dockAutoHidePointerInside) return;
    if (_isDockEdgeRevealActive()) return;
    if (_dockAutoHideHidden) return;

    clearTimeout(_dockAutoHideHideTimeout);
    _dockAutoHideHideTimeout = setTimeout(() => {
        if (!_dockAutoHideEnabled) return;
        if (!_isDesktopVisible()) return;
        if (_dockAutoHidePointerInside) return;
        if (_isDockEdgeRevealActive()) return;
        _setDockHidden(true);
    }, DOCK_AUTO_HIDE_DELAY_MS);
}

function updateDockAutoHideState() {
    const dock = _getDockEl();
    if (!dock) return;

    const enabled = localStorage.getItem(DOCK_AUTO_HIDE_STORAGE_KEY) === 'true';
    _dockAutoHideEnabled = enabled;

    dock.classList.toggle('dock-auto-hide', enabled);

    // If disabled, always show.
    if (!enabled) {
        _showDock();
        return;
    }

    // If enabled, hide unless the mouse is on it (or at the edge).
    _dockAutoHidePointerInside = dock.matches(':hover');
    _updateDockHideCssVar();
    if (_dockAutoHidePointerInside || _isDockEdgeRevealActive()) {
        _showDock();
    } else {
        // Slight delay feels nicer than snapping away immediately.
        _scheduleDockHide();
    }
}

function initDockAutoHide() {
    if (_dockAutoHideInitialized) return;
    _dockAutoHideInitialized = true;

    const dock = _getDockEl();
    if (!dock) return;

    _updateDockHideCssVar();
    window.addEventListener('resize', _updateDockHideCssVar);

    dock.addEventListener('mouseenter', () => {
        _dockAutoHidePointerInside = true;
        if (_dockAutoHideEnabled) _showDock();
    });

    dock.addEventListener('mouseleave', () => {
        _dockAutoHidePointerInside = false;
        _scheduleDockHide();
    });

    // Track mouse position globally so we can edge-reveal even when dock is hidden.
    document.addEventListener('mousemove', (e) => {
        _dockAutoHideLastMouseY = typeof e.clientY === 'number' ? e.clientY : Number.NEGATIVE_INFINITY;
        if (!_dockAutoHideEnabled) return;
        if (!_isDesktopVisible()) return;

        if (_isDockEdgeRevealActive()) {
            _showDock();
            return;
        }

        // If the mouse isn't over the dock, let it hide itself after a short delay.
        if (!_dockAutoHidePointerInside) {
            _scheduleDockHide();
        }
    }, true);

    // Expose for Settings toggles to call without needing to re-initialize.
    window.updateDockAutoHideState = updateDockAutoHideState;
}

// Tooltip Functionality
function initTooltips() {
    const dockItems = document.querySelectorAll('.dock-item');
    
    dockItems.forEach(item => {
        setupDockItemTooltip(item);
    });

    const getClockTooltipText = () => {
        const now = new Date();
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const dayLabel = weekdays[now.getDay()];
        const monthLabel = months[now.getMonth()];
        const day = now.getDate();
        const year = now.getFullYear();
        const getOrdinalSuffix = (value) => {
            const mod100 = value % 100;
            if (mod100 >= 11 && mod100 <= 13) return 'th';
            switch (value % 10) {
                case 1:
                    return 'st';
                case 2:
                    return 'nd';
                case 3:
                    return 'rd';
                default:
                    return 'th';
            }
        };
        return `${dayLabel} ${monthLabel} ${day}${getOrdinalSuffix(day)}, ${year}`;
    };

    const getWeatherTooltipText = () => {
        const locationName = localStorage.getItem('weatherLocationName');
        return locationName && locationName.trim() ? locationName : 'Location unavailable';
    };

    const dockControlTooltips = [
        { element: document.getElementById('search-icon'), text: 'Start Menu' },
        { element: document.querySelector('.dock-virtual-desktops'), text: 'Virtual Desktops' },
        { element: document.querySelector('.dock-quick-settings'), text: 'Quick Settings' },
        { element: document.querySelector('.dock-weather'), text: getWeatherTooltipText },
        { element: document.querySelector('.dock-clock'), text: getClockTooltipText }
    ];
    dockControlTooltips.forEach(({ element, text }) => {
        setupDockControlTooltip(element, text);
    });
    
    // Also update visibility based on setting
    updateDockTooltipsVisibility();
}

function setupDockItemTooltip(item) {
    const originalTooltip = item.querySelector('.dock-tooltip');
    if (!originalTooltip) {
        console.warn('No tooltip found for dock item');
        return;
    }
    
    // Skip if already set up
    if (item.dataset.tooltipSetup === 'true') return;
    item.dataset.tooltipSetup = 'true';
    
    // Get tooltip text
    const tooltipText = originalTooltip.textContent;
    
    // Hide the original tooltip element
    originalTooltip.style.display = 'none';
    
    // Create a new tooltip element and append to body (like background tooltips)
    let tooltipElement = null;
    
    function createTooltip() {
        if (tooltipElement) return;
        tooltipElement = document.createElement('div');
        tooltipElement.className = 'dock-tooltip tooltip';
        tooltipElement.textContent = tooltipText;
        document.body.appendChild(tooltipElement);
    }
    
    function updateTooltipPosition() {
        if (!tooltipElement) createTooltip();
        const rect = item.getBoundingClientRect();
        const tooltipRect = tooltipElement.getBoundingClientRect();
        const tooltipWidth = tooltipRect.width || tooltipElement.offsetWidth || 0;
        const tooltipHeight = tooltipRect.height || tooltipElement.offsetHeight || 0;
        const centerX = rect.left + rect.width / 2;
        const padding = 6;

        let left = centerX - (tooltipWidth / 2);
        const maxLeft = Math.max(padding, window.innerWidth - tooltipWidth - padding);
        left = Math.min(maxLeft, Math.max(padding, left));

        // Position tooltip above the dock so it never sits inside it.
        const dockRect = _getDockEl()?.getBoundingClientRect();
        let top = rect.top - tooltipHeight - padding;
        if (dockRect) {
            top = dockRect.top - tooltipHeight - padding;
        }
        if (top < padding) {
            top = padding;
        }

        tooltipElement.style.top = top + 'px';
        tooltipElement.style.left = left + 'px';
    }
    
    function showTooltip() {
        const showLabels = localStorage.getItem('taskbarShowLabels') !== 'false';
        if (!showLabels) return;
        
        if (!tooltipElement) createTooltip();
        updateTooltipPosition();
        tooltipElement.style.opacity = '1';
        tooltipElement.style.visibility = 'visible';
        tooltipElement.style.transform = 'translateY(0)';
    }
    
    function hideTooltip() {
        if (tooltipElement) {
            tooltipElement.style.opacity = '0';
            tooltipElement.style.visibility = 'hidden';
            tooltipElement.style.transform = 'translateY(6px)';
        }
    }
    
    item.addEventListener('mouseenter', function(e) {
        showTooltip();
    });
    
    item.addEventListener('mousemove', function(e) {
        const showLabels = localStorage.getItem('taskbarShowLabels') !== 'false';
        if (showLabels && tooltipElement && tooltipElement.style.visibility === 'visible') {
            updateTooltipPosition();
        }
    });
    
    item.addEventListener('mouseleave', function(e) {
        hideTooltip();
    });
    
    // Store reference to tooltip element for cleanup if needed
    item._tooltipElement = tooltipElement;
}

// Function to update dock tooltips visibility based on setting
function updateDockTooltipsVisibility() {
    const showLabels = localStorage.getItem('taskbarShowLabels') !== 'false'; // Default to enabled
    const dockItems = document.querySelectorAll('.dock-item');
    
    dockItems.forEach(item => {
        const tooltip = item.querySelector('.dock-tooltip');
        const globalTooltip = item._tooltipElement;
        if (tooltip) {
            // If labels are disabled, hide tooltips completely; if enabled, allow them to show on hover
            if (showLabels) {
                tooltip.style.display = 'block';
                tooltip.style.pointerEvents = 'none';
                // Ensure tooltip is ready to show (but hidden until hover)
                tooltip.style.opacity = '0';
                tooltip.style.visibility = 'hidden';
                tooltip.style.transform = 'translateY(6px)';
                // Re-setup tooltip if not already set up
                if (item.dataset.tooltipSetup !== 'true') {
                    setupDockItemTooltip(item);
                }
            } else {
                tooltip.style.display = 'none';
                tooltip.style.opacity = '0';
                tooltip.style.visibility = 'hidden';
            }
        }
        if (!showLabels && globalTooltip) {
            globalTooltip.style.opacity = '0';
            globalTooltip.style.visibility = 'hidden';
            globalTooltip.style.transform = 'translateY(6px)';
        }
    });
}

// Global function to setup custom tooltips for navigation buttons (used in Files and Editor apps)
// This function now uses the global tooltip style
// Returns an object with updateTooltip function to update the tooltip text in real time
function setupNavButtonTooltip(button, textOrGetter) {
    if (!button) return null;
    
    // Skip if tooltip already set up
    if (button.dataset.tooltipSetup === 'true') {
        // Return update function if tooltip already exists
        const existingTooltip = button._tooltipElement;
        const getText = typeof textOrGetter === 'function' ? textOrGetter : () => textOrGetter;
        return {
            updateTooltip: () => {
                if (existingTooltip) {
                    existingTooltip.textContent = getText();
                }
            }
        };
    }
    
    // Remove title to prevent browser tooltip
    button.removeAttribute('title');
    
    // Create custom tooltip with global tooltip class
    const tooltip = document.createElement('div');
    tooltip.className = 'nav-button-tooltip tooltip';
    const getText = typeof textOrGetter === 'function' ? textOrGetter : () => textOrGetter;
    tooltip.textContent = getText();
    document.body.appendChild(tooltip);
    
    // Store tooltip element on button for later access
    button._tooltipElement = tooltip;
    
    let showTimeout;
    let hideTimeout;
    
    const updateTooltipText = () => {
        tooltip.textContent = getText();
    };
    
    button.addEventListener('mouseenter', (e) => {
        clearTimeout(hideTimeout);
        updateTooltipText(); // Update text in case it's dynamic
        showTimeout = setTimeout(() => {
            const rect = button.getBoundingClientRect();
            // Position tooltip below the button, centered
            tooltip.style.top = (rect.bottom + 8) + 'px';
            tooltip.style.left = (rect.left + rect.width / 2) + 'px';
            tooltip.style.transform = 'translateX(-50%) translateY(0)';
            tooltip.style.opacity = '1';
            tooltip.style.visibility = 'visible';
        }, 500); // Delay before showing
    });
    
    button.addEventListener('mouseleave', () => {
        clearTimeout(showTimeout);
        hideTimeout = setTimeout(() => {
            tooltip.style.opacity = '0';
            tooltip.style.visibility = 'hidden';
        }, 100);
    });
    
    // Mark as set up
    button.dataset.tooltipSetup = 'true';
    
    // Return object with update function
    return {
        updateTooltip: () => {
            updateTooltipText();
        }
    };
}

function setupDockControlTooltip(target, textOrGetter) {
    if (!target) return null;
    if (target.dataset.dockControlTooltip === 'true') {
        const existingTooltip = target._tooltipElement;
        const getText = typeof textOrGetter === 'function' ? textOrGetter : () => textOrGetter;
        return {
            updateTooltip: () => {
                if (existingTooltip) {
                    existingTooltip.textContent = getText();
                }
            }
        };
    }

    target.dataset.dockControlTooltip = 'true';
    target.removeAttribute('title');

    const tooltip = document.createElement('div');
    tooltip.className = 'nav-button-tooltip tooltip';
    const getText = typeof textOrGetter === 'function' ? textOrGetter : () => textOrGetter;
    tooltip.textContent = getText();
    document.body.appendChild(tooltip);
    target._tooltipElement = tooltip;

    let showTimeout;
    let hideTimeout;

    const updateTooltipText = () => {
        tooltip.textContent = getText();
    };

    const updateTooltipPosition = () => {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const tooltipWidth = tooltipRect.width || tooltip.offsetWidth || 0;
        const tooltipHeight = tooltipRect.height || tooltip.offsetHeight || 0;
        const padding = 6;
        const centerX = rect.left + rect.width / 2;

        let left = centerX - (tooltipWidth / 2);
        const maxLeft = Math.max(padding, window.innerWidth - tooltipWidth - padding);
        left = Math.min(maxLeft, Math.max(padding, left));

        const dockRect = _getDockEl()?.getBoundingClientRect();
        let top = rect.top - tooltipHeight - padding;
        if (dockRect) {
            top = dockRect.top - tooltipHeight - padding;
        }
        if (top < padding) {
            top = padding;
        }

        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
    };

    target.addEventListener('mouseenter', () => {
        clearTimeout(hideTimeout);
        updateTooltipText();
        showTimeout = setTimeout(() => {
            updateTooltipPosition();
            tooltip.style.opacity = '1';
            tooltip.style.visibility = 'visible';
            tooltip.style.transform = 'translateY(0)';
        }, 500);
    });

    target.addEventListener('mousemove', () => {
        if (tooltip.style.visibility === 'visible') {
            updateTooltipPosition();
        }
    });

    target.addEventListener('mouseleave', () => {
        clearTimeout(showTimeout);
        hideTimeout = setTimeout(() => {
            tooltip.style.opacity = '0';
            tooltip.style.visibility = 'hidden';
            tooltip.style.transform = 'translateY(-5px)';
        }, 100);
    });

    return {
        updateTooltip: () => {
            updateTooltipText();
        }
    };
}

// Notification System

// Show a toast notification in the top-right corner
function showNotification(message, type = 'info', duration = 5000) {
    // Create/find container on-demand so notifications are safe to use anywhere.
    let container = document.getElementById('notification-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'notification-container';
        container.className = 'notification-container';
        document.body.appendChild(container);
    }
    
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    // Create icon based on type
    let iconSvg = '';
    if (type === 'success') {
        iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
    } else if (type === 'error') {
        iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
    } else if (type === 'warning') {
        iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>';
    } else {
        iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
    }
    
    notification.innerHTML = `
        <div class="notification-icon">${iconSvg}</div>
        <div class="notification-content">
            <div class="notification-message">${message}</div>
        </div>
        <button class="notification-close" aria-label="Close">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
    `;
    
    // Close button handler
    const closeBtn = notification.querySelector('.notification-close');
    const closeNotification = () => {
        notification.classList.add('notification-hiding');
        setTimeout(() => {
            notification.remove();
            updateNotificationPositions();
        }, 200);
    };
    
    closeBtn.addEventListener('click', closeNotification);
    
    // Add to container
    container.appendChild(notification);
    
    // Trigger animation
    setTimeout(() => {
        notification.classList.add('notification-show');
    }, 10);
    
    // Auto-dismiss after duration
    if (duration > 0) {
        setTimeout(() => {
            closeNotification();
        }, duration);
    }
}

// Update notification positions to stack them
function updateNotificationPositions() {
    // Using flex-column container; no manual positioning required.
}

// Custom confirmation dialog function to replace browser confirm()
// Now positions dialogs in the top-right corner notification area, or centers in target window if provided
function showConfirmationDialog(message, title = 'Confirm', targetWindow = null) {
    return new Promise((resolve) => {
        // Create overlay - always center in viewport
        const overlay = document.createElement('div');
        overlay.className = 'confirmation-dialog-overlay';
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px); z-index: 19000; display: flex; align-items: center; justify-content: center; padding: 0;';
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.className = 'confirmation-dialog';
        
        // Use scale animation for centered dialogs
        dialog.style.transform = 'scale(0.95)';
        // Update transform when shown
        setTimeout(() => {
            dialog.style.transform = 'scale(1)';
        }, 10);
        
        // Create window header (like windows)
        const header = document.createElement('div');
        header.className = 'window-header';
        
        const titleEl = document.createElement('div');
        titleEl.className = 'window-title';
        titleEl.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="16" x2="12" y2="12"></line>
                <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
            ${title}
        `;
        
        header.appendChild(titleEl);
        
        // Create dialog content
        const dialogContent = document.createElement('div');
        dialogContent.className = 'confirmation-dialog-content';
        
        // Create message
        const messageEl = document.createElement('p');
        messageEl.className = 'confirmation-dialog-message';
        messageEl.textContent = message;
        
        // Create buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'confirmation-dialog-buttons';
        
        // Create Cancel button (thumbs down icon)
        const cancelButton = document.createElement('button');
        cancelButton.className = 'confirmation-dialog-button';
        cancelButton.style.cssText = 'width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center; min-width: 28px;';
        cancelButton.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
            </svg>
        `;
        cancelButton.title = 'Cancel';
        cancelButton.addEventListener('click', () => {
            overlay.classList.remove('show');
            setTimeout(() => {
                overlay.remove();
                updateNotificationPositions();
            }, 200);
            resolve(false);
        });
        
        // Create OK/Confirm button (thumbs down icon rotated 180 degrees)
        const confirmButton = document.createElement('button');
        confirmButton.className = 'confirmation-dialog-button primary';
        confirmButton.style.cssText = 'width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center; min-width: 28px;';
        confirmButton.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(180deg);">
                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
            </svg>
        `;
        confirmButton.title = 'OK';
        confirmButton.addEventListener('click', () => {
            overlay.classList.remove('show');
            setTimeout(() => {
                overlay.remove();
                updateNotificationPositions();
            }, 200);
            resolve(true);
        });
        
        // Assemble dialog
        buttonsContainer.appendChild(cancelButton);
        buttonsContainer.appendChild(confirmButton);
        dialogContent.appendChild(messageEl);
        dialogContent.appendChild(buttonsContainer);
        dialog.appendChild(header);
        dialog.appendChild(dialogContent);
        overlay.appendChild(dialog);
        
        // Add to body
        document.body.appendChild(overlay);
        
        // Trigger animation
        setTimeout(() => {
            overlay.classList.add('show');
        }, 10);
        
        // Close on overlay click (outside dialog)
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    updateNotificationPositions();
                }, 200);
                resolve(false);
            }
        });
        
        // Close on Escape key
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    updateNotificationPositions();
                }, 200);
                document.removeEventListener('keydown', escapeHandler);
                resolve(false);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    });
}

// Custom rename dialog function to replace browser prompt()
// Centers dialogs in the viewport
function showRenameDialog(currentName, title = 'Rename', targetWindow = null, options = {}) {
    return new Promise((resolve) => {
        // Create overlay - always center in viewport
        const overlay = document.createElement('div');
        overlay.className = 'confirmation-dialog-overlay';
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px); z-index: 19000; display: flex; align-items: center; justify-content: center; padding: 0;';
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.className = 'confirmation-dialog';
        
        // Use scale animation for centered dialogs
        dialog.style.transform = 'scale(0.95)';
        // Update transform when shown
        setTimeout(() => {
            dialog.style.transform = 'scale(1)';
        }, 10);
        
        // Create window header (like windows)
        const header = document.createElement('div');
        header.className = 'window-header';
        
        const titleEl = document.createElement('div');
        titleEl.className = 'window-title';
        titleEl.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            ${title}
        `;
        
        header.appendChild(titleEl);
        
        // Create dialog content
        const dialogContent = document.createElement('div');
        dialogContent.className = 'confirmation-dialog-content';
        
        // Create input container
        const inputContainer = document.createElement('div');
        inputContainer.style.marginBottom = '15px';
        
        // Create input field
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentName;
        input.style.cssText = 'width: 100%; height: 32px; padding: 6px 12px; background: rgba(40, 40, 50, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 13px; outline: none; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;';
        
        const applyInitialSelection = () => {
            // For "create new file" flows, select only the base name (exclude extension)
            // so typing doesn't wipe out ".txt" etc.
            const selectBaseName = options && options.selectBaseName === true;
            const val = String(input.value || '');
            if (selectBaseName) {
                const lastDot = val.lastIndexOf('.');
                // Only treat it as an extension if it isn't the first char and isn't the last char
                if (lastDot > 0 && lastDot < val.length - 1) {
                    input.setSelectionRange(0, lastDot);
                    return;
                }
            }
            input.select();
        };

        // Select appropriate range on focus
        input.addEventListener('focus', applyInitialSelection);
        
        inputContainer.appendChild(input);
        
        // Create buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'confirmation-dialog-buttons';
        
        // Create Cancel button (thumbs down icon)
        const cancelButton = document.createElement('button');
        cancelButton.className = 'confirmation-dialog-button';
        cancelButton.style.cssText = 'width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center; min-width: 28px;';
        cancelButton.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
            </svg>
        `;
        cancelButton.title = 'Cancel';
        cancelButton.addEventListener('click', () => {
            overlay.classList.remove('show');
            setTimeout(() => {
                overlay.remove();
                updateNotificationPositions();
            }, 200);
            resolve(null);
        });
        
        // Create OK/Rename button (same icon as cancel, rotated 180 degrees)
        const renameButton = document.createElement('button');
        renameButton.className = 'confirmation-dialog-button primary';
        renameButton.style.cssText = 'width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center; min-width: 28px;';
        renameButton.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(180deg);">
                <path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>
            </svg>
        `;
        renameButton.title = 'Rename';
        
        const handleRename = () => {
            const newName = input.value.trim();
            const allowUnchanged = options && options.allowUnchanged === true;
            if (newName && (allowUnchanged || newName !== currentName)) {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    updateNotificationPositions();
                }, 200);
                resolve(newName);
            } else if (newName === currentName) {
                // Same name, treat as cancel
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    updateNotificationPositions();
                }, 200);
                resolve(null);
            }
            // If empty, do nothing (keep dialog open)
        };
        
        renameButton.addEventListener('click', handleRename);
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleRename();
            }
        });
        
        // Assemble dialog
        buttonsContainer.appendChild(cancelButton);
        buttonsContainer.appendChild(renameButton);
        dialogContent.appendChild(inputContainer);
        dialogContent.appendChild(buttonsContainer);
        dialog.appendChild(header);
        dialog.appendChild(dialogContent);
        overlay.appendChild(dialog);
        
        // Add to body
        document.body.appendChild(overlay);
        
        // Trigger animation
        setTimeout(() => {
            overlay.classList.add('show');
            input.focus();
            applyInitialSelection();
        }, 10);
        
        // Close on overlay click (outside dialog)
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    updateNotificationPositions();
                }, 200);
                resolve(null);
            }
        });
        
        // Close on Escape key
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    updateNotificationPositions();
                }, 200);
                document.removeEventListener('keydown', escapeHandler);
                resolve(null);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    });
}

// Helper: generate a unique file/folder name inside a directory
async function getUniqueChildName(fs, parentPath, desiredName, itemType /* 'file' | 'folder' */) {
    if (!desiredName) return desiredName;
    const type = itemType === 'folder' ? 'folder' : 'file';
    let name = desiredName;
    let counter = 1;

    while (true) {
        const testPath = parentPath === '/' ? `/${name}` : `${parentPath}/${name}`;
        const exists = type === 'folder' ? await fs.getFolder(testPath) : await fs.getFile(testPath);
        if (!exists) return name;

        const ext = type === 'file' && name.includes('.') ? name.substring(name.lastIndexOf('.')) : '';
        const base = type === 'file' && name.includes('.') ? name.substring(0, name.lastIndexOf('.')) : name;
        name = `${base} (${counter})${ext}`;
        counter++;
    }
}

// Helper function to remove .txt extension from file name for display
function removeTxtExtension(fileName) {
    if (fileName && fileName.toLowerCase().endsWith('.txt')) {
        return fileName.slice(0, -4);
    }
    return fileName;
}

// Helper function to ensure filename has .txt extension
function ensureTxtExtension(fileName) {
    if (!fileName) return 'Untitled.txt';
    const lowerName = fileName.toLowerCase();
    if (!lowerName.endsWith('.txt')) {
        return fileName + '.txt';
    }
    return fileName;
}

// Helper function to check if a file path is a temporary editor file
function isTempEditorFile(path) {
    if (!path) return false;
    const fileName = path.split('/').pop();
    return fileName.startsWith('_temp_editor_') && fileName.endsWith('.txt');
}

// Helper function to generate a unique temporary file name
function generateTempFileName() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 9);
    return `_temp_editor_${timestamp}_${random}.txt`;
}

// Clock Functionality
function initClock() {
    const clockElement = document.getElementById('clock-time');
    if (!clockElement) return;

    function updateClock() {
        const now = new Date();
        let hours = now.getHours();
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const dayLabel = weekdays[now.getDay()];
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const year = now.getFullYear();
        
        // Check if 24-hour format is enabled (default to true/24-hour if not set)
        const clockFormatSetting = localStorage.getItem('clock24HourFormat');
        const use24Hour = clockFormatSetting === null ? true : clockFormatSetting === 'true';
        
        if (use24Hour) {
            // 24-hour format: HH:MM
            hours = String(hours).padStart(2, '0');
            clockElement.textContent = `${hours}:${minutes}`;
        } else {
            // 12-hour format: H:MM AM/PM
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // Convert 0 to 12 for midnight/noon
            clockElement.textContent = `${hours}:${minutes} ${ampm}`;
        }

    }

    if (clockElement.dataset.clockToggleBound !== 'true') {
        clockElement.addEventListener('click', () => {
            const clockFormatSetting = localStorage.getItem('clock24HourFormat');
            const use24Hour = clockFormatSetting === null ? true : clockFormatSetting === 'true';
            const nextUse24Hour = !use24Hour;

            localStorage.setItem('clock24HourFormat', nextUse24Hour.toString());

            const clock24HourToggle = document.querySelector('#clock-24-hour-toggle');
            if (clock24HourToggle) {
                clock24HourToggle.classList.toggle('active', nextUse24Hour);
            }

            updateClock();
        });
        clockElement.dataset.clockToggleBound = 'true';
    }

    updateClock();
    setInterval(updateClock, 1000);
}

// Power Menu Functionality
function initPowerActions() {
    // Handle menu item clicks
    const menuItems = document.querySelectorAll('.power-menu-item');
    const powerTooltipLabels = {
        signout: 'Log Out',
        restart: 'Restart',
        shutdown: 'Shutdown'
    };

    menuItems.forEach(item => {
        const action = item.dataset.action;
        const label = powerTooltipLabels[action];
        if (label) {
            item.setAttribute('aria-label', label);
            setupNavButtonTooltip(item, label);
        }
    });

    menuItems.forEach(item => {
        item.addEventListener('click', function(e) {
            e.stopPropagation();
            closeAllMenus();
            const action = this.dataset.action;

            // Handle different power actions
            if (action === 'restart') {
                // Restart: show boot screen, then require login again.
                try {
                    localStorage.removeItem('loggedInUser');
                } catch (e) {
                    // ignore storage errors
                }
                try {
                    sessionStorage.clear();
                } catch (e) {
                    // ignore storage errors
                }
                // Force boot splash on next load (explicit restart).
                try {
                    sessionStorage.setItem('forceBootOnce', '1');
                } catch (e) {
                    // ignore storage errors
                }

                // Show boot immediately for better UX, then reload to re-run full boot flow.
                const boot = document.getElementById('boot-screen');
                if (boot) {
                    boot.style.display = 'flex';
                    boot.classList.remove('boot-hide');
                    boot.classList.add('boot-show');
                }
                setTimeout(() => window.location.reload(), 50);
            } else if (action === 'signout') {
                // Sign out action - return to login screen
                signOut();
                // Re-initialize login screen after sign out
                setTimeout(() => {
                    initLoginScreen();
                }, 100);
            } else if (action === 'shutdown') {
                // Shutdown: wipe browser data for this webpage and reload into a clean cold boot.
                const boot = document.getElementById('boot-screen');
                if (boot) {
                    boot.style.display = 'flex';
                    boot.classList.remove('boot-hide');
                    boot.classList.add('boot-show');
                }
                (async () => {
                    await wipeSiteData();
                    setTimeout(() => window.location.reload(), 50);
                })();
            }
        });
    });

}

// Battery Status Functionality
function initBattery() {
    const batteryIcon = document.getElementById('battery-icon');
    const batteryPercent = document.getElementById('battery-percent');
    
    const hasDockBattery = !!batteryIcon && !!batteryPercent;

    // Power profile state
    let currentPowerProfile = localStorage.getItem('batteryPowerProfile') || 'balanced';
    
    // Battery state
    let currentBatteryLevel = 0;
    let isCharging = false;
    let batteryObject = null;

    function updateBatteryStatus(battery) {
        const level = Math.round(battery.level * 100);
        const charging = battery.charging;
        
        currentBatteryLevel = level;
        isCharging = charging;
        batteryObject = battery;
        
        // Store in global scope for menu updates
        window.currentBatteryLevel = level;
        window.isCharging = charging;
        
        // Update percentage text (dock, if present)
        if (batteryPercent) {
            batteryPercent.textContent = `${level}%`;
        }
        
        // Update icon based on battery level and charging state (dock, if present)
        const svg = batteryIcon ? batteryIcon.querySelector('svg') : null;
        if (!svg) {
            updateBatteryMenu();
            return;
        }
        
        // Clear existing battery fill
        svg.innerHTML = '';
        
        // Battery outline
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', '1');
        rect.setAttribute('y', '6');
        rect.setAttribute('width', '18');
        rect.setAttribute('height', '10');
        rect.setAttribute('rx', '2');
        rect.setAttribute('ry', '2');
        rect.setAttribute('fill', 'none');
        rect.setAttribute('stroke', 'currentColor');
        rect.setAttribute('stroke-width', '2');
        svg.appendChild(rect);
        
        // Battery terminal
        const terminal = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        terminal.setAttribute('x1', '23');
        terminal.setAttribute('y1', '13');
        terminal.setAttribute('x2', '23');
        terminal.setAttribute('y2', '11');
        terminal.setAttribute('stroke', 'currentColor');
        terminal.setAttribute('stroke-width', '2');
        terminal.setAttribute('stroke-linecap', 'round');
        svg.appendChild(terminal);
        
        // Battery fill based on level
        if (level > 0) {
            const fillWidth = (level / 100) * 18;
            const fill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            fill.setAttribute('x', '2');
            fill.setAttribute('y', '7');
            fill.setAttribute('width', fillWidth.toString());
            fill.setAttribute('height', '8');
            fill.setAttribute('rx', '1');
            fill.setAttribute('ry', '1');
            
            // Use blue theme color to match other icons
            fill.setAttribute('fill', '#5dade2');
            
            svg.appendChild(fill);
        }
        
        // Charging indicator (lightning bolt) - only show if charging and not full
        if (charging && level < 100) {
            const bolt = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            bolt.setAttribute('d', 'M13 2L3 14h8l-2 8 10-12h-8l2-8z');
            bolt.setAttribute('fill', '#5dade2');
            bolt.setAttribute('opacity', '0.9');
            svg.appendChild(bolt);
        }
        
        // Update battery menu if it exists
        updateBatteryMenu();
    }
    
    function calculateBatteryTime() {
        // Get current power profile from localStorage
        const profile = localStorage.getItem('batteryPowerProfile') || 'balanced';
        
        if (currentBatteryLevel === 0 && !isCharging) {
            return { time: '0 min', label: 'Depleted', status: 'Discharging' };
        }
        
        if (isCharging) {
            // If battery is full (100%), show "Battery Full" without time estimate
            if (currentBatteryLevel >= 100) {
                return { time: '', label: '', status: 'Battery Full' };
            }
            
            // Calculate time to full charge
            // Estimate: charging at ~1% per 2-3 minutes (varies by device)
            const remainingPercent = 100 - currentBatteryLevel;
            const minutesPerPercent = 2.5; // Average charging rate
            const totalMinutes = remainingPercent * minutesPerPercent;
            
            if (totalMinutes < 60) {
                return { time: `${Math.round(totalMinutes)} min`, label: 'until full', status: 'Charging' };
            } else {
                const hours = Math.floor(totalMinutes / 60);
                const mins = Math.round(totalMinutes % 60);
                return { time: `${hours}h ${mins}m`, label: 'until full', status: 'Charging' };
            }
        } else {
            // Calculate time until depleted
            // Discharge rate varies by power profile
            let dischargeRate = 1; // percent per hour (base rate)
            
            switch(profile) {
                case 'power-saving':
                    dischargeRate = 0.6; // Slower discharge
                    break;
                case 'balanced':
                    dischargeRate = 1; // Normal discharge
                    break;
                case 'performance':
                    dischargeRate = 1.8; // Faster discharge
                    break;
            }
            
            const hoursRemaining = currentBatteryLevel / dischargeRate;
            
            if (hoursRemaining < 1) {
                const minutes = Math.round(hoursRemaining * 60);
                return { time: `${minutes} min`, label: 'remaining', status: 'Discharging' };
            } else {
                const hours = Math.floor(hoursRemaining);
                const mins = Math.round((hoursRemaining - hours) * 60);
                if (mins === 0) {
                    return { time: `${hours}h`, label: 'remaining', status: 'Discharging' };
                } else {
                    return { time: `${hours}h ${mins}m`, label: 'remaining', status: 'Discharging' };
                }
            }
        }
    }
    
    function updateBatteryMenu() {
        const batteryMenu = document.getElementById('battery-menu');
        const batteryProgressBar = document.getElementById('battery-progress-bar');
        const batteryMenuTime = document.getElementById('battery-menu-time');
        
        const timeInfo = calculateBatteryTime();
        if (timeInfo.status === 'Battery Full') {
            window.currentBatteryTimeText = 'Fully Charged';
        } else {
            window.currentBatteryTimeText = `${timeInfo.status}  ${timeInfo.time} ${timeInfo.label}`;
        }

        if (batteryMenu && batteryProgressBar) {
            batteryProgressBar.style.width = `${currentBatteryLevel}%`;
        }

        if (batteryMenuTime) {
            batteryMenuTime.textContent = window.currentBatteryTimeText || '';
        }

        if (window.updateQuickSettingsPanel) {
            window.updateQuickSettingsPanel();
        }
    }
    
    // Make updateBatteryMenu accessible globally for profile changes
    window.updateBatteryMenuFromBattery = updateBatteryMenu;

    // Check if Battery API is available
    if ('getBattery' in navigator) {
        // Function to refresh battery status
        function refreshBatteryStatus() {
            navigator.getBattery().then(function(battery) {
                // Update the stored battery object
                batteryObject = battery;
                updateBatteryStatus(battery);
            }).catch(function(error) {
                console.warn('Failed to refresh battery status:', error);
                // If refresh fails, try to use the existing battery object
                if (batteryObject) {
                    updateBatteryStatus(batteryObject);
                }
            });
        }
        
        // Initial battery status fetch
        refreshBatteryStatus();
        
        // Periodically refresh battery status to ensure accuracy
        // This is especially important on Android where the API may not update frequently
        // or where event listeners might not fire reliably
        setInterval(function() {
            refreshBatteryStatus();
        }, 10000); // Refresh every 10 seconds to stay in sync with actual device battery
        
        // Also listen for battery level changes (as a backup to periodic refresh)
        navigator.getBattery().then(function(battery) {
            battery.addEventListener('levelchange', function() {
                updateBatteryStatus(battery);
            });
            
            // Listen for charging state changes
            battery.addEventListener('chargingchange', function() {
                updateBatteryStatus(battery);
            });
        });
        
        // Update menu periodically to refresh time estimates
        setInterval(function() {
            updateBatteryMenu();
        }, 60000); // Update every minute
    } else {
        // Fallback if Battery API is not available - use simulated data
        currentBatteryLevel = 75;
        isCharging = false;
        window.currentBatteryLevel = 75;
        window.isCharging = false;
        
        // Update display with simulated data
        if (batteryPercent) {
            batteryPercent.textContent = '75%';
        }
        updateBatteryMenu();
        
        setInterval(function() {
            updateBatteryMenu();
        }, 60000);
    }
    
}

// Volume Status Functionality
function initVolume() {
    const volumeIcon = document.getElementById('volume-icon');
    const volumePercent = document.getElementById('volume-percent');
    const systemAudio = window.pilkOSSystemAudio;
    
    if (!volumeIcon || !volumePercent) return;

    function updateVolumeIcon(volume, muted) {
        const svg = volumeIcon.querySelector('svg');
        if (!svg) return;
        
        svg.innerHTML = '';
        
        // Speaker base
        const speaker = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        speaker.setAttribute('points', '11 5 6 9 2 9 2 15 6 15 11 19 11 5');
        speaker.setAttribute('fill', 'none');
        speaker.setAttribute('stroke', 'currentColor');
        speaker.setAttribute('stroke-width', '2');
        speaker.setAttribute('stroke-linecap', 'round');
        speaker.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(speaker);
        
        if (muted) {
            // Muted - show X line (diagonal line from top-left of speaker to bottom-right of sound waves)
            // Starts from top-left portion of speaker cone, extends through center to bottom-right
            const muteLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            muteLine.setAttribute('x1', '1');
            muteLine.setAttribute('y1', '5');
            muteLine.setAttribute('x2', '16');
            muteLine.setAttribute('y2', '16');
            muteLine.setAttribute('stroke', 'currentColor');
            muteLine.setAttribute('stroke-width', '2');
            muteLine.setAttribute('stroke-linecap', 'round');
            svg.appendChild(muteLine);
        } else {
            // Sound waves based on volume level
            if (volume > 0) {
                const wave1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                wave1.setAttribute('d', 'M15.54 8.46a5 5 0 0 1 0 7.07');
                wave1.setAttribute('fill', 'none');
                wave1.setAttribute('stroke', 'currentColor');
                wave1.setAttribute('stroke-width', '2');
                wave1.setAttribute('stroke-linecap', 'round');
                svg.appendChild(wave1);
            }
            
            if (volume > 50) {
                const wave2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                wave2.setAttribute('d', 'M19.07 4.93a10 10 0 0 1 0 14.14');
                wave2.setAttribute('fill', 'none');
                wave2.setAttribute('stroke', 'currentColor');
                wave2.setAttribute('stroke-width', '2');
                wave2.setAttribute('stroke-linecap', 'round');
                svg.appendChild(wave2);
            }
        }
    }

    async function updateVolume() {
        // Try to get system volume using Web Audio API
        // Note: Browser security prevents direct system volume access
        // This is a best-effort implementation
        
        // Check if we can access audio context
        let volume = 70; // Default
        let muted = false;
        let systemStatusApplied = false;

        if (systemAudio && typeof systemAudio.getStatus === 'function') {
            try {
                const status = await systemAudio.getStatus();
                if (status && typeof status.volume === 'number') {
                    volume = Math.max(0, Math.min(100, Math.round(status.volume)));
                    muted = Boolean(status.muted);
                    systemStatusApplied = true;
                }
            } catch (e) {
                // Fall back to local detection below.
            }
        }
        
        // Try to detect mute state from audio elements
        if (!systemStatusApplied) {
            const audioElements = document.querySelectorAll('audio, video');
            if (audioElements.length > 0) {
                let hasMuted = false;
                audioElements.forEach(el => {
                    if (el.muted) hasMuted = true;
                });
                muted = hasMuted;
            }
        }
        
        // Update display
        volumePercent.textContent = muted ? 'Muted' : `${volume}%`;
        updateVolumeIcon(volume, muted);
    }

    // Initial update
    updateVolume();
    
    // Note: Volume updates are now handled by initVolumeMenu() slider
    // This function only provides initial setup
}

// Networks Signal Strength Functionality
function initWiFi() {
    const wifiIcon = document.getElementById('wifi-icon');
    if (!wifiIcon) return;

    function updateWiFiIcon(strength) {
        const svg = wifiIcon.querySelector('svg');
        if (!svg) return;
        
        svg.innerHTML = '';
        
        const connectedColor = '#5dade2'; // Stable dock WiFi blue (avoid red/yellow flicker on startup)
        const disconnectedColor = 'rgba(255, 255, 255, 0.3)';
        const isConnected = strength > 0;
        const color = isConnected ? connectedColor : disconnectedColor;

        // Keep the dock WiFi icon stable: show the standard "3-wave" icon when connected,
        // and a muted dot when disconnected. (Avoid red/yellow transitions.)
        const bars = isConnected ? 3 : 0;
        
        // Base dot (always visible)
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', '12');
        dot.setAttribute('cy', '20');
        dot.setAttribute('r', '1.5');
        dot.setAttribute('fill', color);
        svg.appendChild(dot);
        
        // Bar 1 (smallest arc - always show if connected)
        if (bars >= 1) {
            const bar1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            bar1.setAttribute('d', 'M8.53 16.11a6 6 0 0 1 6.95 0');
            bar1.setAttribute('fill', 'none');
            bar1.setAttribute('stroke', color);
            bar1.setAttribute('stroke-width', '2');
            bar1.setAttribute('stroke-linecap', 'round');
            svg.appendChild(bar1);
        }
        
        // Bar 2
        if (bars >= 2) {
            const bar2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            bar2.setAttribute('d', 'M1.42 9a16 16 0 0 1 21.16 0');
            bar2.setAttribute('fill', 'none');
            bar2.setAttribute('stroke', color);
            bar2.setAttribute('stroke-width', '2');
            bar2.setAttribute('stroke-linecap', 'round');
            svg.appendChild(bar2);
        }
        
        // Bar 3
        if (bars >= 3) {
            const bar3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            bar3.setAttribute('d', 'M5 12.55a11 11 0 0 1 14.08 0');
            bar3.setAttribute('fill', 'none');
            bar3.setAttribute('stroke', color);
            bar3.setAttribute('stroke-width', '2');
            bar3.setAttribute('stroke-linecap', 'round');
            svg.appendChild(bar3);
        }
        
        // Bar 4 (largest arc - strongest signal)
        if (bars >= 4) {
            const bar4 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            bar4.setAttribute('d', 'M2 5a20 20 0 0 1 20 0');
            bar4.setAttribute('fill', 'none');
            bar4.setAttribute('stroke', color);
            bar4.setAttribute('stroke-width', '2');
            bar4.setAttribute('stroke-linecap', 'round');
            svg.appendChild(bar4);
        }
    }

    function getWiFiStrength() {
        // Respect WiFi toggle state (keeps dock slash + disconnected icon consistent)
        let wifiEnabled = true;
        try {
            const raw = localStorage.getItem('wifiEnabled');
            wifiEnabled = raw === null ? true : raw === 'true';
        } catch (e) {}
        wifiIcon.classList.toggle('is-disabled', !wifiEnabled);
        if (!wifiEnabled) {
            updateWiFiIcon(0);
            return;
        }

        // Try to use Network Information API if available
        if ('connection' in navigator) {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (connection) {
                // Check if we're on WiFi
                if (connection.type === 'wifi' || connection.effectiveType) {
                    // Estimate strength based on effectiveType
                    // 4g = strong, 3g = medium, 2g = weak
                    let strength = 75; // Default
                    if (connection.effectiveType === '4g' || connection.effectiveType === 'slow-2g') {
                        strength = 90;
                    } else if (connection.effectiveType === '3g') {
                        strength = 60;
                    } else if (connection.effectiveType === '2g') {
                        strength = 30;
                    }
                    
                    // Try to get downlink speed as indicator
                    if (connection.downlink) {
                        // Normalize downlink speed (assuming max ~10 Mbps for WiFi)
                        strength = Math.min(100, Math.max(10, (connection.downlink / 10) * 100));
                    }
                    
                    updateWiFiIcon(strength);
                    return;
                }
            }
        }
        
        // Fallback: Check online status
        if (navigator.onLine) {
            // Assume medium strength if online but can't detect
            updateWiFiIcon(60);
        } else {
            // No connection
            updateWiFiIcon(0);
        }
    }
    
    // Make updateWiFiIcon accessible globally
    window.updateWiFiIcon = updateWiFiIcon;
    
    // Initial update
    getWiFiStrength();
    
    // Update periodically
    setInterval(getWiFiStrength, 5000);
    
    // Listen for connection changes
    if ('connection' in navigator) {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (connection) {
            connection.addEventListener('change', getWiFiStrength);
        }
    }
    
    // Listen for online/offline events
    window.addEventListener('online', function() {
        getWiFiStrength();
    });
    
    window.addEventListener('offline', function() {
        updateWiFiIcon(0);
    });
}

// Volume Menu Functionality
function initVolumeMenu() {
    const volumeIcon = document.getElementById('volume-icon');
    const volumeMenu = document.getElementById('volume-menu');
    const volumeSlider = document.getElementById('volume-slider');
    const volumePercent = document.getElementById('volume-percent');
    const systemAudio = window.pilkOSSystemAudio;


    if (!volumeIcon || !volumeMenu || !volumeSlider || !volumePercent) {
        console.error('initVolumeMenu: Missing elements');
        return;
    }
    
    // Check if listener already attached
    if (volumeIcon.hasAttribute('data-listener-attached')) {
        return;
    }
    
    volumeIcon.setAttribute('data-listener-attached', 'true');

    // Make volume icon clickable
    volumeIcon.style.cursor = 'pointer';

    // Initialize slider value from localStorage, current display, or default to 70
    let currentVolume = parseInt(localStorage.getItem('volumeLevel')) || parseInt(volumePercent.textContent) || 70;
    if (isNaN(currentVolume) || currentVolume < 0 || currentVolume > 100) {
        currentVolume = 70;
    }
    // Load muted state from localStorage, or set based on volume being 0
    let isMuted = localStorage.getItem('volumeMuted') === 'true' || currentVolume === 0;
    // If muted, always set volume slider to 0
    if (isMuted) {
        currentVolume = 0;
    }
    volumeSlider.value = currentVolume;
    updateVolumeDisplay(currentVolume);
    updateVolumeIconState(currentVolume, isMuted);

    // Function to update volume slider progress bar
    function updateVolumeSliderProgress(volume) {
        // Update the CSS variable that controls the progress bar fill
        volumeSlider.style.setProperty('--volume-percent', volume + '%');
    }
    
    // Initialize progress bar
    updateVolumeSliderProgress(currentVolume);

    function updateVolumeDisplay(volume) {
        if (isMuted || volume === 0) {
            if (volumePercent) {
                volumePercent.textContent = 'Muted';
            }
        } else {
            if (volumePercent) {
                volumePercent.textContent = `${volume}%`;
            }
        }
    }

    function updateVolumeIconState(volume, muted) {
        const svg = volumeIcon.querySelector('svg');
        if (!svg) return;
        
        svg.innerHTML = '';
        
        // Speaker base
        const speaker = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        speaker.setAttribute('points', '11 5 6 9 2 9 2 15 6 15 11 19 11 5');
        speaker.setAttribute('fill', 'none');
        speaker.setAttribute('stroke', 'currentColor');
        speaker.setAttribute('stroke-width', '2');
        speaker.setAttribute('stroke-linecap', 'round');
        speaker.setAttribute('stroke-linejoin', 'round');
        svg.appendChild(speaker);
        
        if (muted || volume === 0) {
            // Muted - show X line (diagonal line from top-left of speaker to bottom-right of sound waves)
            // Starts from top-left portion of speaker cone, extends through center to bottom-right
            const muteLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            muteLine.setAttribute('x1', '1');
            muteLine.setAttribute('y1', '5');
            muteLine.setAttribute('x2', '16');
            muteLine.setAttribute('y2', '16');
            muteLine.setAttribute('stroke', 'currentColor');
            muteLine.setAttribute('stroke-width', '2');
            muteLine.setAttribute('stroke-linecap', 'round');
            svg.appendChild(muteLine);
        } else {
            // Sound waves based on volume level
            if (volume > 0) {
                const wave1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                wave1.setAttribute('d', 'M15.54 8.46a5 5 0 0 1 0 7.07');
                wave1.setAttribute('fill', 'none');
                wave1.setAttribute('stroke', 'currentColor');
                wave1.setAttribute('stroke-width', '2');
                wave1.setAttribute('stroke-linecap', 'round');
                svg.appendChild(wave1);
            }
            
            if (volume > 50) {
                const wave2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                wave2.setAttribute('d', 'M19.07 4.93a10 10 0 0 1 0 14.14');
                wave2.setAttribute('fill', 'none');
                wave2.setAttribute('stroke', 'currentColor');
                wave2.setAttribute('stroke-width', '2');
                wave2.setAttribute('stroke-linecap', 'round');
                svg.appendChild(wave2);
            }
        }
    }

    function applySystemVolume(volume, muted) {
        const clampedVolume = Math.max(0, Math.min(100, Math.round(Number(volume))));
        currentVolume = clampedVolume;
        isMuted = Boolean(muted) || clampedVolume === 0;
        volumeSlider.value = isMuted ? 0 : clampedVolume;
        updateVolumeDisplay(currentVolume);
        updateVolumeIconState(currentVolume, isMuted);
        updateVolumeSliderProgress(currentVolume);
        localStorage.setItem('volumeLevel', currentVolume.toString());
        localStorage.setItem('volumeMuted', isMuted.toString());
        if (window.updateQuickSettingsPanel) {
            window.updateQuickSettingsPanel();
        }
    }

    async function syncSystemVolume() {
        if (!systemAudio || typeof systemAudio.getStatus !== 'function') return;
        try {
            const status = await systemAudio.getStatus();
            if (status && typeof status.volume === 'number') {
                applySystemVolume(status.volume, status.muted);
            }
        } catch (e) {
            // Ignore polling failures; keep last known UI state.
        }
    }

    if (systemAudio && typeof systemAudio.getStatus === 'function') {
        syncSystemVolume();
        if (window.systemVolumeInterval) {
            clearInterval(window.systemVolumeInterval);
        }
        window.systemVolumeInterval = setInterval(syncSystemVolume, 1000);
    }

    // Slider change handler
    // Function to update volume slider progress bar
    function updateVolumeSliderProgress(volume) {
        volumeSlider.style.setProperty('--volume-percent', volume + '%');
    }

    volumeSlider.addEventListener('input', function(e) {
        currentVolume = parseInt(e.target.value);
        isMuted = currentVolume === 0;
        // Save volume and muted state to localStorage
        localStorage.setItem('volumeLevel', currentVolume.toString());
        localStorage.setItem('volumeMuted', isMuted.toString());
        if (currentVolume > 0) {
            localStorage.setItem('volumeLastNonZero', currentVolume.toString());
        }
        updateVolumeDisplay(currentVolume);
        updateVolumeIconState(currentVolume, isMuted);
        updateVolumeSliderProgress(currentVolume);
        if (window.updateQuickSettingsPanel) {
            window.updateQuickSettingsPanel();
        }
        if (systemAudio && typeof systemAudio.setVolume === 'function') {
            systemAudio.setVolume(currentVolume);
        }
        if (systemAudio && typeof systemAudio.setMuted === 'function') {
            systemAudio.setMuted(isMuted);
        }
    });

    // Scroll wheel control for volume slider
    volumeMenu.addEventListener('wheel', function(e) {
        e.preventDefault();
        
        // Only adjust volume if menu is visible
        if (!volumeMenu.classList.contains('show')) return;
        
        // Determine scroll direction and adjust volume
        const scrollDelta = e.deltaY > 0 ? -2 : 2; // Scroll down decreases, scroll up increases
        let newVolume = currentVolume + scrollDelta;
        
        // Clamp volume between 0 and 100
        newVolume = Math.max(0, Math.min(100, newVolume));
        
        // Update volume if it changed
        if (newVolume !== currentVolume) {
            currentVolume = newVolume;
            isMuted = currentVolume === 0;
            // Save volume and muted state to localStorage
            localStorage.setItem('volumeLevel', currentVolume.toString());
            localStorage.setItem('volumeMuted', isMuted.toString());
            if (currentVolume > 0) {
                localStorage.setItem('volumeLastNonZero', currentVolume.toString());
            }
            volumeSlider.value = currentVolume;
            updateVolumeDisplay(currentVolume);
            updateVolumeIconState(currentVolume, isMuted);
            updateVolumeSliderProgress(currentVolume);
            if (systemAudio && typeof systemAudio.setVolume === 'function') {
                systemAudio.setVolume(currentVolume);
            }
            if (systemAudio && typeof systemAudio.setMuted === 'function') {
                systemAudio.setMuted(isMuted);
            }
        }
    }, { passive: false });

    // Function to position volume menu horizontally centered next to volume icon
    function positionVolumeMenu() {
        const iconRect = volumeIcon.getBoundingClientRect();
        const menuWidth = 220; // Width of the volume menu
        positionDockMenuForControl(volumeMenu, iconRect, { menuWidth, menuHeight: 80 });
    }

    // Toggle menu on volume icon click
    volumeIcon.addEventListener('click', function(e) {
        e.stopPropagation();
        e.preventDefault();
        const wasOpen = volumeMenu.classList.contains('show');
        closeAllMenus();
        if (!wasOpen) {
            volumeMenu.classList.add('show');
            // Use setTimeout to ensure menu is rendered before positioning
            setTimeout(positionVolumeMenu, 0);
        }
    });

    // Close menu when clicking outside
    document.addEventListener('click', function(e) {
        if (volumeMenu.classList.contains('show')) {
            const clickedVolume = volumeIcon.contains(e.target) || volumeIcon === e.target;
            const clickedMenu = volumeMenu.contains(e.target);
            if (!clickedVolume && !clickedMenu) {
                volumeMenu.classList.remove('show');
            }
        }
    });

    // Reposition menu on window resize if it's visible
    window.addEventListener('resize', function() {
        if (volumeMenu.classList.contains('show')) {
            positionVolumeMenu();
        }
    });
}

// Global Window Utilities (for all windows)

// Dock window preview (live hover snapshots)
const DOCK_WINDOW_PREVIEW_REFRESH_MS = 500;
const DOCK_WINDOW_PREVIEW_HIDE_DELAY_MS = 80;
const dockWindowPreviewCache = new WeakMap();
const dockWindowPreviewState = {
    container: null,
    titleEl: null,
    stateEl: null,
    imageEl: null,
    placeholderEl: null,
    activeIcon: null,
    activeWindow: null,
    refreshTimer: null,
    hideTimer: null,
    renderInFlight: false,
    pendingRender: false
};

function canRenderDockWindowPreviews() {
    return typeof window.html2canvas === 'function';
}

function getWindowTitleText(win, fallback = '') {
    if (!win) return fallback;
    const titleEl = win.querySelector('.window-title');
    if (titleEl) {
        const clone = titleEl.cloneNode(true);
        const svgElements = clone.querySelectorAll('svg');
        svgElements.forEach(svg => svg.remove());
        const text = clone.textContent ? clone.textContent.trim() : '';
        if (text) return text;
    }
    return fallback;
}

function ensureDockWindowPreviewEl() {
    if (dockWindowPreviewState.container) return dockWindowPreviewState.container;
    const container = document.createElement('div');
    container.className = 'dock-window-preview';
    container.setAttribute('aria-hidden', 'true');
    container.innerHTML = `
        <div class="dock-window-preview-body">
            <img class="dock-window-preview-image" alt="Window preview">
            <div class="dock-window-preview-placeholder">Preview Unavailable</div>
            <div class="dock-window-preview-label"></div>
        </div>
    `;
    document.body.appendChild(container);
    dockWindowPreviewState.container = container;
    dockWindowPreviewState.imageEl = container.querySelector('.dock-window-preview-image');
    dockWindowPreviewState.placeholderEl = container.querySelector('.dock-window-preview-placeholder');
    dockWindowPreviewState.titleEl = container.querySelector('.dock-window-preview-label');

    window.addEventListener('resize', () => {
        if (dockWindowPreviewState.container?.classList.contains('show') && dockWindowPreviewState.activeIcon) {
            positionDockWindowPreview(dockWindowPreviewState.activeIcon);
        }
    });

    return container;
}

function setDockWindowPreviewSnapshot(url) {
    const container = ensureDockWindowPreviewEl();
    if (url) {
        if (dockWindowPreviewState.imageEl) {
            dockWindowPreviewState.imageEl.src = url;
        }
        container.classList.add('has-image');
        container.classList.remove('no-image');
    } else {
        container.classList.remove('has-image');
        container.classList.add('no-image');
    }
}

function updateDockWindowPreviewContent(win) {
    const titleText = getWindowTitleText(win, win?.id || 'Window');
    if (dockWindowPreviewState.titleEl) {
        dockWindowPreviewState.titleEl.textContent = titleText;
    }
}

function positionDockWindowPreview(iconEl) {
    if (!iconEl) return;
    const container = ensureDockWindowPreviewEl();
    const rect = iconEl.getBoundingClientRect();
    const previewRect = container.getBoundingClientRect();
    const padding = 10;
    const centerX = rect.left + rect.width / 2;
    let left = centerX - previewRect.width / 2;
    const maxLeft = Math.max(padding, window.innerWidth - previewRect.width - padding);
    left = Math.min(maxLeft, Math.max(padding, left));

    const dockRect = _getDockEl()?.getBoundingClientRect();
    let top = rect.top - previewRect.height - padding;
    if (dockRect) {
        top = dockRect.top - previewRect.height - padding;
    }
    if (top < padding) top = padding;
    container.style.left = `${left}px`;
    container.style.top = `${top}px`;
}

function stopDockWindowPreviewRefresh() {
    if (dockWindowPreviewState.refreshTimer) {
        clearInterval(dockWindowPreviewState.refreshTimer);
        dockWindowPreviewState.refreshTimer = null;
    }
}

function hideDockWindowPreview() {
    if (!dockWindowPreviewState.container) return;
    stopDockWindowPreviewRefresh();
    dockWindowPreviewState.container.classList.remove('show');
    dockWindowPreviewState.container.setAttribute('aria-hidden', 'true');
    dockWindowPreviewState.activeIcon = null;
    dockWindowPreviewState.activeWindow = null;
}

function scheduleDockWindowPreviewHide() {
    if (dockWindowPreviewState.hideTimer) {
        clearTimeout(dockWindowPreviewState.hideTimer);
    }
    dockWindowPreviewState.hideTimer = setTimeout(() => {
        hideDockWindowPreview();
    }, DOCK_WINDOW_PREVIEW_HIDE_DELAY_MS);
}

function requestDockWindowPreviewRender() {
    if (!dockWindowPreviewState.activeWindow) return;
    if (dockWindowPreviewState.renderInFlight) {
        dockWindowPreviewState.pendingRender = true;
        return;
    }
    renderDockWindowPreview(dockWindowPreviewState.activeWindow);
}

async function renderDockWindowPreview(win) {
    if (!win || !dockWindowPreviewState.container) return;
    if (!document.body.contains(win)) return;
    if (!dockWindowPreviewState.container.classList.contains('show')) return;
    if (!canRenderDockWindowPreviews()) return;
    if (isWindowMinimized(win) || win.classList.contains('window-desktop-hidden')) {
        const cached = dockWindowPreviewCache.get(win);
        setDockWindowPreviewSnapshot(cached || null);
        updateDockWindowPreviewContent(win);
        return;
    }

    dockWindowPreviewState.renderInFlight = true;
    try {
        const isFileProtocol = window.location && window.location.protocol === 'file:';
        const canvas = await window.html2canvas(win, {
            backgroundColor: null,
            logging: false,
            scale: 0.3,
            useCORS: !isFileProtocol,
            allowTaint: false
        });
        if (dockWindowPreviewState.activeWindow !== win) return;
        let url = null;
        try {
            url = canvas.toDataURL('image/png');
        } catch (e) {
            url = null;
        }
        if (url) {
            dockWindowPreviewCache.set(win, url);
        }
        setDockWindowPreviewSnapshot(url || dockWindowPreviewCache.get(win) || null);
        updateDockWindowPreviewContent(win);
        positionDockWindowPreview(dockWindowPreviewState.activeIcon);
    } catch (e) {
        if (dockWindowPreviewState.activeWindow !== win) return;
        const cached = dockWindowPreviewCache.get(win);
        setDockWindowPreviewSnapshot(cached || null);
        updateDockWindowPreviewContent(win);
    } finally {
        dockWindowPreviewState.renderInFlight = false;
        if (dockWindowPreviewState.pendingRender) {
            dockWindowPreviewState.pendingRender = false;
            requestDockWindowPreviewRender();
        }
    }
}

function showDockWindowPreviewForIcon(iconEl) {
    const win = iconEl?._window;
    if (!win) return;
    if (dockWindowPreviewState.hideTimer) {
        clearTimeout(dockWindowPreviewState.hideTimer);
        dockWindowPreviewState.hideTimer = null;
    }
    const container = ensureDockWindowPreviewEl();
    dockWindowPreviewState.activeIcon = iconEl;
    dockWindowPreviewState.activeWindow = win;
    updateDockWindowPreviewContent(win);
    const cached = dockWindowPreviewCache.get(win);
    setDockWindowPreviewSnapshot(cached || null);
    container.classList.add('show');
    container.setAttribute('aria-hidden', 'false');
    positionDockWindowPreview(iconEl);

    // Hide any tooltip while the preview is visible.
    const tooltip = iconEl._tooltipElement || iconEl.querySelector('.dock-tooltip');
    if (tooltip) {
        tooltip.style.opacity = '0';
        tooltip.style.visibility = 'hidden';
        tooltip.style.transform = 'translateY(6px)';
    }

    requestDockWindowPreviewRender();
    stopDockWindowPreviewRefresh();
    dockWindowPreviewState.refreshTimer = setInterval(() => {
        requestDockWindowPreviewRender();
    }, DOCK_WINDOW_PREVIEW_REFRESH_MS);
}

// Global registry for window app bar icons
const windowAppBarIcons = new Map();

function addWindowToAppBar(window, options = {}) {
    const dockApps = document.querySelector('.dock-apps');
    if (!dockApps) return null;
    
    // Use window.id as the unique identifier for each window instance
    // Always prioritize window.id to ensure each window gets its own icon
    // Try both window.id and window.getAttribute('id') to ensure we get the ID
    // Force read the ID directly from the DOM element to ensure we get the latest value
    let windowIdValue = window.id;
    if (!windowIdValue || windowIdValue.trim() === '') {
        // Try getAttribute as fallback
        windowIdValue = window.getAttribute ? window.getAttribute('id') : '';
    }
    // If still no ID, generate a unique one
    const appId = (windowIdValue && windowIdValue.trim() !== '') ? windowIdValue : `window-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const iconSvg = options.iconSvg || '';
    
    // Get window title for tooltip
    const windowTitleElement = window.querySelector('.window-title');
    let windowTitle = options.label || '';
    if (!windowTitle && windowTitleElement) {
        // Extract text content, excluding SVG
        const titleClone = windowTitleElement.cloneNode(true);
        const svgElements = titleClone.querySelectorAll('svg');
        svgElements.forEach(svg => svg.remove());
        windowTitle = titleClone.textContent.trim();
    }
    // Fallback to appId if no title found
    if (!windowTitle) {
        windowTitle = appId;
    }
    
    // Use the onIconClick directly (it should already be a closure that captures the window)
    const onIconClick = options.onIconClick || null;
    
    // Check if icon already exists for this specific window
    if (windowAppBarIcons.has(appId)) {
        // Icon already exists for this window ID, return it
        return windowAppBarIcons.get(appId);
    }
    
    const appBarIcon = document.createElement('div');
    appBarIcon.className = 'dock-item dock-item-active';
    appBarIcon.dataset.app = appId;
    appBarIcon.innerHTML = `
        <div class="dock-icon">
            ${iconSvg}
        </div>
        <div class="dock-tooltip tooltip">${windowTitle}</div>
    `;
    
    // Store reference to the specific window
    appBarIcon._window = window;
    
    if (onIconClick) {
        appBarIcon.addEventListener('click', onIconClick);
    }
    
    dockApps.appendChild(appBarIcon);
    windowAppBarIcons.set(appId, appBarIcon);
    
    // Setup tooltip for this item (must happen after appending to DOM)
    setupDockItemTooltip(appBarIcon);

    // Live window previews on hover
    appBarIcon.addEventListener('mouseenter', () => {
        showDockWindowPreviewForIcon(appBarIcon);
    });
    appBarIcon.addEventListener('mousemove', () => {
        if (dockWindowPreviewState.activeIcon === appBarIcon) {
            positionDockWindowPreview(appBarIcon);
        }
    });
    appBarIcon.addEventListener('mouseleave', () => {
        scheduleDockWindowPreviewHide();
    });
    appBarIcon.addEventListener('mousedown', () => {
        hideDockWindowPreview();
    });
    
    // Apply label visibility setting
    updateDockTooltipsVisibility();
    
    return appBarIcon;
}

function removeWindowFromAppBar(appId) {
    if (windowAppBarIcons.has(appId)) {
        const icon = windowAppBarIcons.get(appId);
        if (icon && icon.parentNode) {
            icon.remove();
        }
        windowAppBarIcons.delete(appId);
        if (dockWindowPreviewState.activeIcon === icon) {
            hideDockWindowPreview();
        }
    }
}

function updateWindowAppBarState(window, isFocused, isMinimized = false) {
    // Find the app bar icon for this specific window
    windowAppBarIcons.forEach((icon, appId) => {
        if (icon._window === window) {
            // Always keep dock-item-active for open windows
            icon.classList.add('dock-item-active');
            
            // Add focused class for the focused window
            if (isFocused) {
                icon.classList.add('dock-item-focused');
            } else {
                icon.classList.remove('dock-item-focused');
            }
            
            // Add minimized class for minimized windows
            if (isMinimized) {
                icon.classList.add('dock-item-minimized');
            } else {
                icon.classList.remove('dock-item-minimized');
            }
        }
    });
}

function isWindowMinimized(win) {
    if (!win) return false;
    if (win.style.display === 'none') return true;
    try {
        return window.getComputedStyle(win).display === 'none';
    } catch {
        return false;
    }
}

// Standard dock icon behavior:
// - If minimized: restore + focus
// - Else if focused: minimize
// - Else: focus
function toggleWindowFromDock(win, saveFn = null) {
    if (!win) return;
    const minimized = isWindowMinimized(win);
    const focused = win.classList.contains('window-focused') && !minimized;

    if (minimized) {
        win.style.display = 'flex';
        focusWindow(win);
        updateWindowAppBarState(win, true, false);
    } else if (focused) {
        win.style.display = 'none';
        win.classList.remove('window-focused');
        updateWindowAppBarState(win, false, true);
    } else {
        focusWindow(win);
        updateWindowAppBarState(win, true, false);
    }

    if (typeof saveFn === 'function') {
        try { saveFn(); } catch (e) {}
    }
}

// Global Properties Window (shared by Desktop + Files)

function savePropertiesWindowsStateGlobal() {
    const propertiesWindows = Array.from(document.querySelectorAll('[data-properties-window]'));
    const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
    const minLeft = 0;

    const windowsState = propertiesWindows.map(win => {
        const isMinimized = win.style.display === 'none';

        let left = parseInt(win.style.left) || win.offsetLeft || 400;
        let top = parseInt(win.style.top) || win.offsetTop || 150;
        let width = parseInt(win.style.width) || win.offsetWidth || 550;
        let height = parseInt(win.style.height) || win.offsetHeight || 400;

        const maxLeft = viewportWidth - width;
        if (left > maxLeft || left + width > viewportWidth) left = Math.max(minLeft, maxLeft);
        if (left < minLeft) left = minLeft;
        if (width > viewportWidth - minLeft) width = Math.max(550, viewportWidth - minLeft - 20);

        return {
            windowId: win.id,
            path: win.dataset.propertiesPath || '',
            type: win.dataset.propertiesType || '',
            name: win.dataset.propertiesName || '',
            left: left + 'px',
            top: top + 'px',
            width: width + 'px',
            height: height + 'px',
            minimized: isMinimized
        };
    });

    try {
        localStorage.setItem('propertiesWindowsState', JSON.stringify(windowsState));
    } catch (e) {
        // ignore storage errors
    }
}

async function showPropertiesGlobal(path, type, name, restoreState = null) {
    try {
        const fs = await initFileSystem();
        let size = 0;
        let created;
        let modified;

        if (type === 'folder') {
            const folder = await fs.getFolder(path);
            created = new Date(folder.created);
            modified = new Date(folder.modified);

            // Calculate folder size (sum of file sizes recursively)
            const countSize = async (folderPath) => {
                const dir = await fs.listDirectory(folderPath);
                let totalSize = 0;
                for (const file of dir.files) totalSize += file.size || 0;
                for (const f of dir.folders) totalSize += await countSize(f.path);
                return totalSize;
            };
            size = await countSize(path);
        } else {
            const file = await fs.getFile(path);
            size = file.size || 0;
            created = new Date(file.created);
            modified = new Date(file.modified);
        }

        const formatSize = (bytes) => {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        };
        const formatDate = (date) => date.toLocaleString();

        const propsHTML = `
            <div style="padding: 20px; max-width: 500px;">
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Name</div>
                        <div style="color: rgba(255,255,255,0.9);">${name}</div>
                    </div>
                    <div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Type</div>
                        <div style="color: rgba(255,255,255,0.9);">${type === 'folder' ? 'Folder' : 'File'}</div>
                    </div>
                    <div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Size</div>
                        <div style="color: rgba(255,255,255,0.9);">${formatSize(size)}</div>
                    </div>
                    <div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Created</div>
                        <div style="color: rgba(255,255,255,0.9);">${formatDate(created)}</div>
                    </div>
                    <div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Modified</div>
                        <div style="color: rgba(255,255,255,0.9);">${formatDate(modified)}</div>
                    </div>
                    <div>
                        <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Location</div>
                        <div style="color: rgba(255,255,255,0.9); font-size: 12px;">${path}</div>
                    </div>
                </div>
            </div>
        `;

        const windowsContainer = document.getElementById('windows-container');
        if (!windowsContainer) return null;

        const propsWindow = document.createElement('div');
        propsWindow.className = 'window';
        propsWindow.id = restoreState ? restoreState.windowId : `properties-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        propsWindow.setAttribute('data-properties-window', 'true');
        propsWindow.dataset.propertiesPath = path;
        propsWindow.dataset.propertiesType = type;
        propsWindow.dataset.propertiesName = name;

        if (restoreState) {
            propsWindow.style.left = restoreState.left || '400px';
            propsWindow.style.top = restoreState.top || '150px';
            propsWindow.style.width = restoreState.width || '550px';
            propsWindow.style.height = restoreState.height || '400px';
        } else {
            propsWindow.style.left = '400px';
            propsWindow.style.top = '150px';
            propsWindow.style.width = '550px';
            propsWindow.style.height = 'auto';
        }
        propsWindow.style.minHeight = '400px';

        const propertiesIconSvg = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="16" x2="12" y2="12"></line>
            <line x1="12" y1="8" x2="12.01" y2="8"></line>
        </svg>`;

        propsWindow.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    Properties
                </div>
                <div class="window-controls">
                    <div class="window-control minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content">${propsHTML}</div>
        `;

        windowsContainer.appendChild(propsWindow);

        // Setup window controls + app bar integration
        const minimizeBtn = propsWindow.querySelector('.window-control.minimize');
        const maximizeBtn = propsWindow.querySelector('.window-control.maximize');
        const closeBtn = propsWindow.querySelector('.window-control.close');

        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const isMinimized = propsWindow.style.display === 'none';
                if (isMinimized) {
                    propsWindow.style.display = 'flex';
                    focusWindow(propsWindow);
                } else {
                    propsWindow.style.display = 'none';
                }
                updateWindowAppBarState(propsWindow, !isMinimized, isMinimized);
                savePropertiesWindowsStateGlobal();
            });
        }

        if (maximizeBtn) {
            let previousSize = null;
            let isMaximized = false;
            maximizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (isMaximized) {
                    if (previousSize) {
                        propsWindow.style.width = previousSize.width;
                        propsWindow.style.height = previousSize.height;
                        propsWindow.style.left = previousSize.left;
                        propsWindow.style.top = previousSize.top;
                    } else {
                        propsWindow.style.width = '550px';
                        propsWindow.style.height = 'auto';
                        propsWindow.style.minHeight = '400px';
                        propsWindow.style.left = '400px';
                        propsWindow.style.top = '150px';
                    }
                    isMaximized = false;
                } else {
                    previousSize = {
                        width: propsWindow.style.width || propsWindow.offsetWidth + 'px',
                        height: propsWindow.style.height || propsWindow.offsetHeight + 'px',
                        left: propsWindow.style.left || propsWindow.offsetLeft + 'px',
                        top: propsWindow.style.top || propsWindow.offsetTop + 'px'
                    };
                    maximizeWindowToBounds(propsWindow);
                    isMaximized = true;
                }
                savePropertiesWindowsStateGlobal();
            });
        }

        if (closeBtn) {
            closeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const windowId = propsWindow.id;
                propsWindow.remove();
                if (windowId) removeWindowFromAppBar(windowId);
                savePropertiesWindowsStateGlobal();
            });
        }

        addWindowToAppBar(propsWindow, {
            iconSvg: propertiesIconSvg,
            onIconClick: function() {
                toggleWindowFromDock(propsWindow, savePropertiesWindowsStateGlobal);
            }
        });

        makeWindowDraggable(propsWindow, { onDragEnd: savePropertiesWindowsStateGlobal });
        makeWindowResizable(propsWindow, { onResize: savePropertiesWindowsStateGlobal });

        if (restoreState && restoreState.minimized) {
            propsWindow.style.display = 'none';
            updateWindowAppBarState(propsWindow, false, true);
        }

        focusWindow(propsWindow);
        savePropertiesWindowsStateGlobal();
        return propsWindow;
    } catch (error) {
        alert('Error loading properties: ' + error.message);
        return null;
    }
}

// Expose globally (Desktop + Files use this)
window.savePropertiesWindowsState = savePropertiesWindowsStateGlobal;
window.showProperties = showPropertiesGlobal;
window.openPropertiesWindow = showPropertiesGlobal;

// Global counter to ensure newly opened windows always get highest z-index
let windowZIndexCounter = 1002;
// During boot/restore, apps create windows and often call focusWindow().
// We temporarily suppress persisting focusedWindowId so the pre-refresh focused
// window can be restored deterministically.
let suppressFocusPersistence = false;

function focusWindow(window) {
    const windowsContainer = document.getElementById('windows-container');
    if (!windowsContainer) return;
    
    // Check if window is minimized
    const isMinimized = window.style.display === 'none';
    
    // Increment z-index counter to ensure this window is on top
    windowZIndexCounter++;
    
    // Bring window to front
    const windows = windowsContainer.querySelectorAll('.window');
    windows.forEach(w => {
        if (w !== window) {
            // Keep other windows at lower z-index, but preserve their relative order
            const currentZIndex = parseInt(w.style.zIndex) || 1001;
            if (currentZIndex >= windowZIndexCounter) {
                // If another window has a higher z-index, increment our counter
                windowZIndexCounter = currentZIndex + 1;
            }
            w.classList.remove('window-focused');
            const wMinimized = w.style.display === 'none';
            updateWindowAppBarState(w, false, wMinimized);
        }
    });
    window.style.zIndex = windowZIndexCounter.toString();
    window.classList.add('window-focused');
    
    // Save focused window ID to localStorage (unless suppressed during restore)
    if (!suppressFocusPersistence && window.id) {
        localStorage.setItem('focusedWindowId', window.id);
    }
    
    // Update App bar icon state
    updateWindowAppBarState(window, true, isMinimized);
}

// Ensure clicking anywhere inside a window focuses it (like a real desktop OS).
// This keeps focusedWindowId accurate even if the user doesn't drag the header.
(function ensureGlobalWindowFocusOnClick() {
    if (document.documentElement.hasAttribute('data-window-focus-on-click')) return;
    document.documentElement.setAttribute('data-window-focus-on-click', 'true');

    document.addEventListener('mousedown', function(e) {
        const win = e.target && e.target.closest ? e.target.closest('.window') : null;
        if (!win) return;
        if (win.style.display === 'none') return;
        // Avoid interfering with control buttons; they already manage their own behavior.
        if (e.target.closest && e.target.closest('.window-controls')) return;
        focusWindow(win);
    }, true);
})();

// Helper function to calculate staggered position for new windows
function calculateStaggeredPosition(windowType, defaultLeft = 200, defaultTop = 100) {
    const staggerOffset = 40; // Pixels to offset each new window diagonally
    const bounds = getWindowBounds();
    const minLeft = bounds.minLeft;
    const minTop = bounds.minTop;
    const viewportWidth = bounds.viewportWidth;
    const viewportHeight = bounds.viewportHeight;
    
    // Count all visible windows (not just windows of the same type)
    // This ensures windows stagger across different types
    const allWindows = document.querySelectorAll('.window');
    const visibleWindows = Array.from(allWindows).filter(w => {
        // Check if window is visible (not minimized)
        return w.style.display !== 'none' && 
               w.style.display !== '' && 
               !w.hasAttribute('data-hidden');
    });
    
    // Get the count of visible windows (this will be the stagger count for the new window)
    const staggerCount = visibleWindows.length;
    
    // Center new windows by default (account for dock width) and then apply a small stagger
    // so multiple new windows don't perfectly overlap.
    const defaultWidth = 900;
    const defaultHeight = 650;
    const availableWidth = Math.max(1, viewportWidth - minLeft - WINDOW_EDGE_GAP_PX);
    const availableHeight = Math.max(1, bounds.maxBottom - minTop);
    const centeredLeft = Math.max(minLeft, Math.round(minLeft + (availableWidth - defaultWidth) / 2));
    const centeredTop = Math.max(minTop, Math.round(minTop + (availableHeight - defaultHeight) / 2));

    // Calculate staggered position (centered baseline)
    let staggeredLeft = centeredLeft + (staggerCount * staggerOffset);
    let staggeredTop = centeredTop + (staggerCount * staggerOffset);
    
    // Ensure staggered position is within viewport bounds
    const maxLeft = bounds.maxRight - defaultWidth;
    const maxTop = bounds.maxBottom - defaultHeight;
    
    // If staggered position would go beyond viewport, wrap around
    if (staggeredLeft > maxLeft) {
        // Reset to minimum left and add vertical offset
        staggeredLeft = minLeft + ((staggerCount % Math.floor((maxLeft - minLeft) / staggerOffset)) * staggerOffset);
    }
    if (staggeredTop > maxTop) {
        // Reset to top and add horizontal offset
        staggeredTop = centeredTop + ((staggerCount % Math.max(1, Math.floor((maxTop - centeredTop) / staggerOffset))) * staggerOffset);
    }
    
    // Ensure values are within bounds
    staggeredLeft = Math.max(minLeft, Math.min(staggeredLeft, maxLeft));
    staggeredTop = Math.max(minTop, Math.min(staggeredTop, maxTop));
    
    return {
        left: staggeredLeft,
        top: staggeredTop
    };
}

// Helper function to validate and fix window position to ensure it's fully visible
function validateAndFixWindowPosition(window) {
    if (!window || !window.parentElement) return; // Window must be in DOM
    const bounds = getWindowBounds();
    const minLeft = bounds.minLeft;
    const minTop = bounds.minTop;

    let left = parseInt(window.style.left) || minLeft;
    let top = parseInt(window.style.top) || minTop;
    
    // Force a reflow to ensure dimensions are accurate
    void window.offsetWidth;
    
    // Use actual rendered dimensions if available, otherwise fall back to CSS values
    const width = window.offsetWidth || parseInt(window.style.width) || 900;
    const height = window.offsetHeight || parseInt(window.style.height) || 650;
    
    const viewportWidth = bounds.viewportWidth;
    const viewportHeight = bounds.viewportHeight;
    
    // Ensure we have valid dimensions
    if (!viewportWidth || !viewportHeight || !width || !height) {
        return; // Can't validate without dimensions
    }
    
    // Keep windows inside the left/top edge gap
    left = Math.max(minLeft, left);
    top = Math.max(minTop, top);
    
    // Ensure window doesn't extend beyond right edge
    // The window controls are on the right side, so we need the entire window visible
    // Calculate the maximum left position that keeps the window fully visible
    const maxLeft = bounds.maxRight - width;
    if (left > maxLeft) {
        left = Math.max(minLeft, maxLeft);
    }
    
    // Double-check: ensure window's right edge doesn't extend beyond viewport
    // This is critical for ensuring window controls are accessible
    if (left + width > bounds.maxRight) {
        left = Math.max(minLeft, bounds.maxRight - width);
    }
    
    // If window is wider than viewport (shouldn't happen, but handle it gracefully)
    const maxWidth = bounds.maxWidth;
    const maxHeight = bounds.maxHeight;
    if (width > maxWidth) {
        window.style.width = maxWidth + 'px';
        left = minLeft;
    }
    
    // Ensure window doesn't extend beyond the dock's top edge
    const maxTop = bounds.maxBottom - height;
    if (top > maxTop) {
        top = Math.max(minTop, maxTop);
    }
    if (height > maxHeight) {
        window.style.height = maxHeight + 'px';
        top = minTop;
    }
    
    // Only update if position actually changed to avoid unnecessary reflows
    const currentLeft = parseInt(window.style.left) || 0;
    const currentTop = parseInt(window.style.top) || 0;
    
    if (Math.abs(currentLeft - left) > 1 || Math.abs(currentTop - top) > 1) {
        window.style.left = left + 'px';
        window.style.top = top + 'px';
    }
}

function maximizeWindowToBounds(targetWindow) {
    const bounds = getWindowBounds();
    targetWindow.style.left = bounds.minLeft + 'px';
    targetWindow.style.top = bounds.minTop + 'px';
    targetWindow.style.width = bounds.maxWidth + 'px';
    targetWindow.style.height = bounds.maxHeight + 'px';
    validateAndFixWindowPosition(targetWindow);
}

function makeWindowDraggable(window, options = {}) {
    const header = window.querySelector('.window-header');
    if (!header) return;
    
    const onDragEnd = options.onDragEnd || null;
    const windowsContainer = document.getElementById('windows-container');
    
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    
    header.addEventListener('mousedown', function(e) {
        if (e.target.closest('.window-controls')) return;
        
        // Bring window to front when starting to drag (and persist focus)
        // Use the shared focusWindow() so z-index, app bar state, and focusedWindowId stay consistent.
        if (window.style.display !== 'none') {
            focusWindow(window);
            try { window.focus(); } catch (e) {}
        }
        
        // Fix window position if it's off-screen before starting drag
        validateAndFixWindowPosition(window);
        
        // Use CSS position values instead of offsetLeft/offsetTop for accuracy
        // This is important when window is positioned off-screen
        const currentLeft = parseInt(window.style.left) || 0;
        const currentTop = parseInt(window.style.top) || 0;
        
        isDragging = true;
        initialX = e.clientX - currentLeft;
        initialY = e.clientY - currentTop;

        // While dragging a window, keep desktop icons visually below windows
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (desktopIconsContainer) {
            desktopIconsContainer.classList.add('window-drag-active');
        }
        
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDrag);
    });
    
    function drag(e) {
        if (!isDragging) return;
        
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        
        // Note: Windows do NOT use grid mode - they can be positioned freely
        // Grid mode (desktopGridEnabled) only affects desktop icons
        
        // Keep window within viewport bounds (with gaps)
        const bounds = getWindowBounds();
        const minX = bounds.minLeft;
        const minY = bounds.minTop;
        const viewportWidth = bounds.viewportWidth;
        const viewportHeight = bounds.viewportHeight;
        const windowWidth = parseInt(window.style.width) || window.offsetWidth;
        const windowHeight = parseInt(window.style.height) || window.offsetHeight;
        
        // Calculate max X position to ensure entire window (including controls) is visible
        const maxX = Math.max(minX, bounds.maxRight - windowWidth);
        const maxY = Math.min(viewportHeight - windowHeight, bounds.maxBottom - windowHeight);
        
        currentX = Math.max(minX, Math.min(currentX, maxX));
        currentY = Math.max(minY, Math.min(currentY, maxY));
        
        // Double-check: ensure window's right edge doesn't extend beyond viewport
        // This is critical for ensuring window controls are accessible
        if (currentX + windowWidth > bounds.maxRight) {
            currentX = Math.max(minX, bounds.maxRight - windowWidth);
        }
        
        window.style.left = currentX + 'px';
        window.style.top = currentY + 'px';
    }
    
    function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDrag);

        // Restore default icon layering after window drag ends
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (desktopIconsContainer) {
            desktopIconsContainer.classList.remove('window-drag-active');
        }
        
        // Final validation after drag to ensure window stays within bounds
        validateAndFixWindowPosition(window);
        
        if (onDragEnd) {
            onDragEnd(window);
        }
    }
}

function makeWindowResizable(window, options = {}) {
    const handles = window.querySelectorAll('.window-resize-handle');
    if (handles.length === 0) return;
    
    const minWidth = options.minWidth || 400;
    const minHeight = options.minHeight || 300;
    const onResize = options.onResize || null;
    
    handles.forEach(handle => {
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        
        handle.addEventListener('mousedown', function(e) {
            // Bring window to front when starting to resize (and persist focus)
            if (window.style.display !== 'none') {
                focusWindow(window);
                try { window.focus(); } catch (e) {}
            }

            isResizing = true;
            startX = e.clientX;
            startY = e.clientY;
            startWidth = parseInt(window.offsetWidth);
            startHeight = parseInt(window.offsetHeight);
            startLeft = parseInt(window.offsetLeft);
            startTop = parseInt(window.offsetTop);
            
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
            e.preventDefault();
        });
        
        function resize(e) {
            if (!isResizing) return;
            
            const classList = handle.classList;
            const bounds = getWindowBounds();
            const viewportWidth = bounds.viewportWidth;
            const viewportHeight = bounds.viewportHeight;
            const minLeft = bounds.minLeft;
            const minTop = bounds.minTop;
            const maxRight = bounds.maxRight;
            const maxBottom = bounds.maxBottom;
            
            if (classList.contains('se')) {
                // Southeast corner - resize right and bottom
                const width = startWidth + (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                const maxWidth = maxRight - startLeft;
                const maxHeight = maxBottom - startTop;
                window.style.width = Math.max(minWidth, Math.min(width, maxWidth)) + 'px';
                window.style.height = Math.max(minHeight, Math.min(height, maxHeight)) + 'px';
            } else if (classList.contains('sw')) {
                // Southwest corner - resize left and bottom
                const width = startWidth - (e.clientX - startX);
                const height = startHeight + (e.clientY - startY);
                const left = startLeft + (e.clientX - startX);
                const maxHeight = maxBottom - startTop;
                
                if (width >= minWidth && left >= minLeft && left + width <= maxRight) {
                    window.style.width = width + 'px';
                    window.style.left = left + 'px';
                } else if (left < minLeft) {
                    // Prevent resizing if it would move window under dock
                    const adjustedWidth = startWidth - (minLeft - startLeft);
                    if (adjustedWidth >= minWidth) {
                        window.style.width = Math.min(adjustedWidth, maxRight - minLeft) + 'px';
                        window.style.left = minLeft + 'px';
                    }
                } else if (left + width > maxRight) {
                    // Prevent window from extending beyond right edge
                    const adjustedWidth = maxRight - left;
                    if (adjustedWidth >= minWidth) {
                        window.style.width = adjustedWidth + 'px';
                    }
                }
                window.style.height = Math.max(minHeight, Math.min(height, maxHeight)) + 'px';
            } else if (classList.contains('ne')) {
                // Northeast corner - resize right and top
                const width = startWidth + (e.clientX - startX);
                const height = startHeight - (e.clientY - startY);
                const top = startTop + (e.clientY - startY);
                const maxWidth = maxRight - startLeft;
                
                window.style.width = Math.max(minWidth, Math.min(width, maxWidth)) + 'px';
                if (height >= minHeight && top >= minTop) {
                    window.style.height = height + 'px';
                    window.style.top = top + 'px';
                } else if (top < minTop) {
                    // Prevent window from extending above viewport
                    const adjustedHeight = startHeight + (startTop - minTop);
                    if (adjustedHeight >= minHeight) {
                        window.style.height = adjustedHeight + 'px';
                        window.style.top = minTop + 'px';
                    }
                }
            } else if (classList.contains('nw')) {
                // Northwest corner - resize left and top
                const width = startWidth - (e.clientX - startX);
                const height = startHeight - (e.clientY - startY);
                const left = startLeft + (e.clientX - startX);
                const top = startTop + (e.clientY - startY);
                
                if (width >= minWidth && left >= minLeft && left + width <= maxRight) {
                    window.style.width = width + 'px';
                    window.style.left = left + 'px';
                } else if (left < minLeft) {
                    // Prevent resizing if it would move window under dock
                    const adjustedWidth = startWidth - (minLeft - startLeft);
                    if (adjustedWidth >= minWidth) {
                        window.style.width = Math.min(adjustedWidth, maxRight - minLeft) + 'px';
                        window.style.left = minLeft + 'px';
                    }
                } else if (left + width > maxRight) {
                    // Prevent window from extending beyond right edge
                    const adjustedWidth = maxRight - left;
                    if (adjustedWidth >= minWidth) {
                        window.style.width = adjustedWidth + 'px';
                    }
                }
                if (height >= minHeight && top >= minTop) {
                    window.style.height = height + 'px';
                    window.style.top = top + 'px';
                } else if (top < minTop) {
                    // Prevent window from extending above viewport
                    const adjustedHeight = startHeight + (startTop - minTop);
                    if (adjustedHeight >= minHeight) {
                        window.style.height = adjustedHeight + 'px';
                        window.style.top = minTop + 'px';
                    }
                }
            } else if (classList.contains('e')) {
                // East edge - resize right
                const width = startWidth + (e.clientX - startX);
                const maxWidth = maxRight - startLeft;
                window.style.width = Math.max(minWidth, Math.min(width, maxWidth)) + 'px';
            } else if (classList.contains('w')) {
                // West edge - resize left
                const width = startWidth - (e.clientX - startX);
                const left = startLeft + (e.clientX - startX);
                
                if (width >= minWidth && left >= minLeft && left + width <= maxRight) {
                    window.style.width = width + 'px';
                    window.style.left = left + 'px';
                } else if (left < minLeft) {
                    // Prevent resizing if it would move window under dock
                    const adjustedWidth = startWidth - (minLeft - startLeft);
                    if (adjustedWidth >= minWidth) {
                        window.style.width = Math.min(adjustedWidth, maxRight - minLeft) + 'px';
                        window.style.left = minLeft + 'px';
                    }
                } else if (left + width > maxRight) {
                    // Prevent window from extending beyond right edge
                    const adjustedWidth = maxRight - left;
                    if (adjustedWidth >= minWidth) {
                        window.style.width = adjustedWidth + 'px';
                    }
                }
            } else if (classList.contains('s')) {
                // South edge - resize bottom
                const height = startHeight + (e.clientY - startY);
                const maxHeight = maxBottom - startTop;
                window.style.height = Math.max(minHeight, Math.min(height, maxHeight)) + 'px';
            } else if (classList.contains('n')) {
                // North edge - resize top
                const height = startHeight - (e.clientY - startY);
                const top = startTop + (e.clientY - startY);
                
                if (height >= minHeight && top >= minTop) {
                    window.style.height = height + 'px';
                    window.style.top = top + 'px';
                } else if (top < minTop) {
                    // Prevent window from extending above viewport
                    const adjustedHeight = startHeight + (startTop - minTop);
                    if (adjustedHeight >= minHeight) {
                        window.style.height = adjustedHeight + 'px';
                        window.style.top = minTop + 'px';
                    }
                }
            }
            
            // Final validation after resize to ensure window stays within bounds
            validateAndFixWindowPosition(window);
            
            if (onResize) {
                onResize(window);
            }
        }
        
        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
            if (onResize) {
                onResize(window);
            }
        }
    });
}

// Settings Window Functionality
// Global window count for Settings app to persist across initSettingsWindow calls
let settingsWindowCount = 0;
// Track if Settings has been initialized to prevent multiple restorations
let settingsInitialized = false;
let globalSaveSettingsWindowsState = null;

// Global image cache to prevent flickering and improve performance
// Maps imagePath -> { url: blobURL, blob: Blob }
const globalImageCache = new Map();

function initSettingsWindow() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');
    
    if (!windowsContainer || !dockApps) {
        // If DOM isn't ready yet, try again after a short delay
        setTimeout(() => {
            initSettingsWindow();
        }, 100);
        return;
    }
    
    // Save all Settings windows state
    function saveSettingsWindowsState() {
        const settingsWindows = Array.from(document.querySelectorAll('[data-settings-window]'));
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const minLeft = 0;
        
        const windowsState = settingsWindows.map(window => {
            const isMinimized = window.style.display === 'none';
            // Get active page
            // Note: Some pages (like About) are reachable via the footer and may not have a sidebar item.
            // Prefer the active page element, fall back to active sidebar item, then default.
            const activePageElement = window.querySelector('.settings-page.active');
            const activeSidebarItem = window.querySelector('.settings-sidebar .sidebar-item.active');
            const activePage =
                (activePageElement && activePageElement.id ? activePageElement.id.replace(/-page$/, '') : null) ||
                (activeSidebarItem && activeSidebarItem.dataset && activeSidebarItem.dataset.page ? activeSidebarItem.dataset.page : null) ||
                'users';
            
            // Get current position and dimensions
            let left = parseInt(window.style.left) || window.offsetLeft || 200;
            let top = parseInt(window.style.top) || window.offsetTop || 100;
            let width = parseInt(window.style.width) || window.offsetWidth || 900;
            let height = parseInt(window.style.height) || window.offsetHeight || 650;
            
            // Sanitize values before saving - ensure they're valid
            const maxLeft = viewportWidth - width;
            if (left > maxLeft || left + width > viewportWidth) {
                left = Math.max(minLeft, maxLeft);
            }
            if (left < minLeft) {
                left = minLeft;
            }
            
            // Ensure width isn't too large
            if (width > viewportWidth - minLeft) {
                width = Math.max(600, viewportWidth - minLeft - 20);
            }
            
            return {
                windowId: window.id,
                left: left + 'px',
                top: top + 'px',
                width: width + 'px',
                height: height + 'px',
                minimized: isMinimized,
                activePage: activePage
            };
        });
        localStorage.setItem('settingsWindowsState', JSON.stringify(windowsState));
    }
    
    // Make saveSettingsWindowsState accessible globally for beforeunload
    globalSaveSettingsWindowsState = saveSettingsWindowsState;
    
    // Get saved Settings windows state
    function getSavedSettingsWindowsState() {
        const saved = localStorage.getItem('settingsWindowsState');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                return [];
            }
        }
        return [];
    }
    
    function createSettingsWindow(restoreState = null) {
        const windowId = restoreState ? restoreState.windowId : `settings-window-${settingsWindowCount++}`;
        const window = document.createElement('div');
        window.className = 'window';
        window.id = windowId;
        window.setAttribute('id', windowId); // Set both property and attribute
        window.setAttribute('data-settings-window', 'true');

        // Restore minimized state early (before inserting into DOM) to avoid flicker on refresh.
        const isMinimized = !!(restoreState && restoreState.minimized);
        window.style.display = isMinimized ? 'none' : 'flex';
        
        // Use restore state if provided, otherwise use defaults
        if (restoreState) {
            // Sanitize saved position values before applying them
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const minLeft = 0;
            
            let savedLeft = parseInt(restoreState.left) || 200;
            let savedTop = parseInt(restoreState.top) || 100;
            let savedWidth = parseInt(restoreState.width) || 900;
            let savedHeight = parseInt(restoreState.height) || 650;
            
            // Validate saved width/height aren't too large
            if (savedWidth > viewportWidth - minLeft) {
                savedWidth = Math.max(600, viewportWidth - minLeft - 20);
            }
            if (savedHeight > (document.documentElement.clientHeight || window.innerHeight)) {
                savedHeight = Math.max(400, (document.documentElement.clientHeight || window.innerHeight) - 20);
            }
            
            // Validate saved position - if window would extend beyond viewport, adjust it
            const maxLeft = viewportWidth - savedWidth;
            if (savedLeft > maxLeft || savedLeft + savedWidth > viewportWidth) {
                savedLeft = Math.max(minLeft, maxLeft);
            }
            if (savedLeft < minLeft) {
                savedLeft = minLeft;
            }
            
            window.style.left = savedLeft + 'px';
            window.style.top = savedTop + 'px';
            window.style.width = savedWidth + 'px';
            window.style.height = savedHeight + 'px';
        } else {
            // Calculate staggered position for new windows
            const staggeredPos = calculateStaggeredPosition('settings', 200, 100);
            window.style.left = staggeredPos.left + 'px';
            window.style.top = staggeredPos.top + 'px';
            window.style.width = '900px';
            window.style.height = '650px';
        }
        
        // Validate and fix window position to ensure it's fully visible
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 0);
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 200);
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 500);
        
        // Final aggressive check - detect if controls are off-screen and force fix
        setTimeout(() => {
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const windowRight = parseInt(window.style.left) + (window.offsetWidth || parseInt(window.style.width));
            if (windowRight > viewportWidth) {
                const minLeft = 0;
                const windowWidth = window.offsetWidth || parseInt(window.style.width) || 900;
                const maxLeft = viewportWidth - windowWidth;
                window.style.left = Math.max(minLeft, maxLeft) + 'px';
                if (saveSettingsWindowsState) {
                    saveSettingsWindowsState();
                }
            }
        }, 1000);
        
        window.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    Settings
                </div>
                <div class="window-controls">
                    <div class="window-control minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content settings-content">
                <div class="settings-body">
                    <div class="settings-sidebar">
                        <div class="settings-sidebar-search" style="padding: 0 12px 12px 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); position: relative;">
                            <div class="file-explorer-search expanded" style="display: flex; align-items: center; justify-content: flex-start; gap: 0px; padding: 6px 12px; background: rgba(40, 40, 50, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; min-width: 200px; width: 100%; height: 32px; box-sizing: border-box; margin: 0;">
                                <button class="file-explorer-search-icon-btn" style="border: none; background: transparent; color: rgba(255, 255, 255, 0.7); cursor: default; padding: 0; margin: 0; display: flex; align-items: center; justify-content: flex-start; width: 32px; height: 32px; flex-shrink: 0; pointer-events: none; box-sizing: border-box;">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="position: static; transform: none; margin: 0; margin-left: -2px; padding: 0; opacity: 0.7; display: block;">
                                        <circle cx="11" cy="11" r="8"></circle>
                                        <path d="m21 21-4.35-4.35"></path>
                                    </svg>
                                </button>
                                <input type="text" id="settings-search-input" placeholder="" class="file-explorer-search-input" style="flex: 1; border: none; background: transparent; color: rgba(255, 255, 255, 0.7); font-size: 13px; font-family: inherit; font-weight: inherit; outline: none; width: auto; min-width: 0; opacity: 1; margin-left: -8px; padding: 0; padding-left: 0px; margin-right: 0;" />
                            </div>
                            <div id="settings-search-results" style="display: none; position: absolute; top: 100%; left: 12px; right: 12px; margin-top: 8px; background: rgba(25, 25, 35, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; max-height: 400px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
                                <!-- Search results will be populated here -->
                            </div>
                        </div>
                        <div class="sidebar-section">
                            <div class="sidebar-item active" data-page="users">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                    <circle cx="9" cy="7" r="4"></circle>
                                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                                </svg>
                                <span>Users</span>
                            </div>
                            <div class="sidebar-item" data-page="network">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M5 12.55a11 11 0 0 1 14.08 0"></path>
                                    <path d="M1.42 9a16 16 0 0 1 21.16 0"></path>
                                    <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                                    <line x1="12" y1="20" x2="12.01" y2="20"></line>
                                </svg>
                                <span>Network</span>
                            </div>
                            <div class="sidebar-item" data-page="bluetooth">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M6.5 6.5l11 11L12 23V1l5.5 5.5-11 11"></path>
                                </svg>
                                <span>Bluetooth & Devices</span>
                            </div>
                            <div class="sidebar-item" data-page="sound">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                </svg>
                                <span>Sound</span>
                            </div>
                            <div class="sidebar-item" data-page="display">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                                    <line x1="8" y1="21" x2="16" y2="21"></line>
                                    <line x1="12" y1="17" x2="12" y2="21"></line>
                                </svg>
                                <span>Appearance</span>
                            </div>
                            <div class="sidebar-item" data-page="notifications">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                                    <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                                </svg>
                                <span>Notifications</span>
                            </div>
                            <div class="sidebar-item" data-page="privacy">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                                </svg>
                                <span>Privacy & Security</span>
                            </div>
                            <div class="sidebar-item" data-page="accessibility">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M12 16v-4"></path>
                                    <path d="M12 8h.01"></path>
                                </svg>
                                <span>Accessibility</span>
                            </div>
                            <div class="sidebar-item" data-page="language">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="2" y1="12" x2="22" y2="12"></line>
                                    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                                </svg>
                                <span>Language & Region</span>
                            </div>
                            <div class="sidebar-item" data-page="power">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                                    <line x1="12" y1="2" x2="12" y2="12"></line>
                                </svg>
                                <span>Power</span>
                            </div>
                            <div class="sidebar-item" data-page="applications">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="3" width="7" height="7"></rect>
                                    <rect x="14" y="3" width="7" height="7"></rect>
                                    <rect x="14" y="14" width="7" height="7"></rect>
                                    <rect x="3" y="14" width="7" height="7"></rect>
                                </svg>
                                <span>Applications</span>
                            </div>
                            <div class="sidebar-item" data-page="system">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>
                                </svg>
                                <span>System</span>
                            </div>
                            </div>
                        <div class="settings-sidebar-footer" style="position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); background: rgba(25, 25, 35, 0.85); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; padding: 8px 12px; font-size: 12px; color: rgba(255, 255, 255, 0.9); z-index: 10; pointer-events: all; cursor: pointer; display: flex; align-items: center; gap: 4px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.2s;" data-page="about">
                            <span id="settings-os-name" style="color: rgba(255, 255, 255, 0.8);">PilkOS</span>
                            <span id="settings-os-version" style="color: rgba(255, 255, 255, 0.9);">v0.1.3</span>
                        </div>
                    </div>
                    <div class="settings-main">
                        <div class="settings-page" id="system-page">
                    </div>
                        <div class="settings-page active" id="users-page">
                        <div class="settings-section">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                <h3 style="margin: 0;">User Accounts</h3>
                                <button id="add-user-btn" class="nav-button settings-panel-btn">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                </button>
                            </div>
                            <div id="users-list" style="display: flex; flex-direction: column; gap: 8px;">
                                <!-- Users will be populated here -->
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="network-page">
                        <div class="settings-section">
                            <h3>Networks</h3>
                            <div class="settings-item">
                                <label>Network Status</label>
                                <div style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-top: 4px;" id="network-wifi-status">Connected</div>
                            </div>
                            <div class="settings-item">
                                <label>Signal Strength</label>
                                <div style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-top: 4px;" id="network-wifi-strength">Strong</div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Network Information</h3>
                            <div class="settings-item">
                                <label>Connection Type</label>
                                <div style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-top: 4px;">Wireless</div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="bluetooth-page">
                        <div class="settings-section">
                            <h3>Bluetooth</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Bluetooth</span>
                                    <div class="settings-toggle" id="bluetooth-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <label>Device Status</label>
                                <div style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-top: 4px;" id="bluetooth-status">Off</div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Devices</h3>
                            <div class="settings-item">
                                <label>Connected Devices</label>
                                <div style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-top: 4px;">No devices connected</div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="display-page">
                        <div class="settings-section">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <h3 style="margin: 0;">Background</h3>
                                <button id="add-background-btn" class="nav-button settings-panel-btn">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                </button>
                            </div>
                            <div class="settings-item">
                                <div class="background-options" style="display: grid; grid-template-columns: repeat(auto-fit, 100px); gap: 5px; margin-bottom: 10px;">
                                    <div class="background-option" data-bg="default" style="cursor: pointer; padding: 10px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 6px; background-image: url('../assets/images/Peak.jpg'); background: url('../assets/images/Peak.jpg'), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%); background-size: cover; background-position: center; background-repeat: no-repeat; position: relative; overflow: visible;">
                                        <div class="background-option-tooltip tooltip">Peak</div>
                                    </div>
                                    <div class="background-option" data-bg="dark-blue" style="cursor: pointer; padding: 10px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 6px; background-image: url('../assets/images/Mountain.jpg'); background: url('../assets/images/Mountain.jpg'), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%); background-size: cover; background-position: center; background-repeat: no-repeat; position: relative; overflow: visible;">
                                        <div class="background-option-tooltip tooltip">Mountain</div>
                                    </div>
                                    </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Brightness</h3>
                            <div class="settings-item" style="position: relative;">
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px;">
                                    <div class="settings-slider-container">
                                        <input type="range" min="0" max="100" value="80" class="settings-slider" id="display-brightness">
                                        <div class="settings-slider-value" id="display-brightness-value">80%</div>
                                    </div>
                                    <div style="display: flex; gap: 8px; align-items: center;">
                                        <button id="night-light-button" class="nav-button settings-panel-btn">
                                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                                            </svg>
                                            <svg class="night-light-diagonal" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" style="position: absolute; display: none;">
                                                <line x1="1" y1="1" x2="23" y2="23"></line>
                                            </svg>
                                        </button>
                                        <button id="auto-brightness-button" class="nav-button settings-panel-btn">
                                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="5"></circle>
                                                <line x1="12" y1="1" x2="12" y2="3"></line>
                                                <line x1="12" y1="21" x2="12" y2="23"></line>
                                                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                                                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                                                <line x1="1" y1="12" x2="3" y2="12"></line>
                                                <line x1="21" y1="12" x2="23" y2="12"></line>
                                                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                                                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                                            </svg>
                                            <svg class="auto-brightness-diagonal" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" style="position: absolute; display: block;">
                                                <line x1="1" y1="1" x2="23" y2="23"></line>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section dock-settings-section">
                            <h3>Dock</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Auto-Hide Dock</span>
                                    <div class="settings-toggle" id="dock-auto-hide-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Show App Labels</span>
                                    <div class="settings-toggle active" id="taskbar-show-labels-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Show Weather</span>
                                    <div class="settings-toggle" id="weather-icon-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">24-Hour Format</span>
                                    <div class="settings-toggle" id="clock-24-hour-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="sound-page">
                        <div class="settings-section">
                            <h3>Output</h3>
                            <div class="settings-item">
                                <label style="margin-bottom: 12px;">Master Volume</label>
                                <div class="settings-slider-container">
                                    <input type="range" min="0" max="100" value="70" class="settings-slider" id="sound-volume-slider">
                                    <div class="settings-slider-value" id="sound-volume-value">70%</div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <label>Output Device</label>
                                <select class="settings-select" id="sound-output-device" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Default Output Device</option>
                                    <option>Speakers</option>
                                    <option>Headphones</option>
                                </select>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Input</h3>
                            <div class="settings-item">
                                <label>Input Device</label>
                                <select class="settings-select" id="sound-input-device" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Default Input Device</option>
                                    <option>Microphone</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label style="margin-bottom: 12px;">Input Volume</label>
                                <div class="settings-slider-container">
                                    <input type="range" min="0" max="100" value="50" class="settings-slider" id="sound-input-volume-slider">
                                    <div class="settings-slider-value" id="sound-input-volume-value">50%</div>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Sound Effects</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">System sounds</span>
                                    <div class="settings-toggle active" id="sound-system-sounds-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Volume feedback</span>
                                    <div class="settings-toggle active" id="sound-volume-feedback-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="notifications-page">
                        <div class="settings-section">
                            <h3>Notification Settings</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Do Not Disturb</span>
                                    <div class="settings-toggle" id="notifications-dnd-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Show notifications</span>
                                    <div class="settings-toggle active" id="notifications-show-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Notification sounds</span>
                                    <div class="settings-toggle active" id="notifications-sounds-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Notification Preferences</h3>
                            <div class="settings-item">
                                <label>Notification Position</label>
                                <select class="settings-select" id="notifications-position" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Top Right</option>
                                    <option>Top Left</option>
                                    <option>Bottom Right</option>
                                    <option>Bottom Left</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label style="margin-bottom: 12px;">Notification Duration (seconds)</label>
                                <div class="settings-slider-container">
                                    <input type="range" min="2" max="10" value="5" class="settings-slider" id="notifications-duration-slider">
                                    <div class="settings-slider-value" id="notifications-duration-value">5 seconds</div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="privacy-page">
                        <div class="settings-section">
                            <h3>Privacy</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Location Services</span>
                                    <div class="settings-toggle active" id="privacy-location-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Camera Access</span>
                                    <div class="settings-toggle active" id="privacy-camera-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Microphone Access</span>
                                    <div class="settings-toggle active" id="privacy-microphone-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">File System Access</span>
                                    <div class="settings-toggle active" id="privacy-filesystem-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Security</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Firewall</span>
                                    <div class="settings-toggle active" id="security-firewall-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Automatic Updates</span>
                                    <div class="settings-toggle active" id="security-updates-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <label>Security Level</label>
                                <select class="settings-select" id="security-level" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Standard</option>
                                    <option>Enhanced</option>
                                    <option>Maximum</option>
                                </select>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="accessibility-page">
                        <div class="settings-section">
                            <h3>Visual</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">High Contrast Mode</span>
                                    <div class="settings-toggle" id="accessibility-high-contrast-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Reduce Motion</span>
                                    <div class="settings-toggle" id="accessibility-reduce-motion-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <label style="margin-bottom: 12px;">Text Size</label>
                                <div class="settings-slider-container">
                                    <input type="range" min="12" max="24" value="14" class="settings-slider" id="accessibility-text-size-slider">
                                    <div class="settings-slider-value" id="accessibility-text-size-value">14px</div>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Keyboard</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Sticky Keys</span>
                                    <div class="settings-toggle" id="accessibility-sticky-keys-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Slow Keys</span>
                                    <div class="settings-toggle" id="accessibility-slow-keys-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <label style="margin-bottom: 12px;">Repeat Delay</label>
                                <div class="settings-slider-container">
                                    <input type="range" min="200" max="1000" value="500" step="100" class="settings-slider" id="accessibility-repeat-delay-slider">
                                    <div class="settings-slider-value" id="accessibility-repeat-delay-value">500ms</div>
                                </div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Mouse & Touchpad</h3>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Mouse Keys</span>
                                    <div class="settings-toggle" id="accessibility-mouse-keys-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <label style="margin-bottom: 12px;">Double-click Speed</label>
                                <div class="settings-slider-container">
                                    <input type="range" min="100" max="900" value="500" step="100" class="settings-slider" id="accessibility-double-click-slider">
                                    <div class="settings-slider-value" id="accessibility-double-click-value">500ms</div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="language-page">
                        <div class="settings-section">
                            <h3>Language</h3>
                            <div class="settings-item">
                                <label>Display Language</label>
                                <select class="settings-select" id="language-display" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>English (United States)</option>
                                    <option>English (United Kingdom)</option>
                                    <option>Spanish</option>
                                    <option>French</option>
                                    <option>German</option>
                                    <option>Japanese</option>
                                    <option>Chinese</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label>Input Language</label>
                                <select class="settings-select" id="language-input" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>English (US)</option>
                                    <option>English (UK)</option>
                                    <option>Spanish</option>
                                    <option>French</option>
                                    <option>German</option>
                                </select>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Region</h3>
                            <div class="settings-item">
                                <label>Country/Region</label>
                                <select class="settings-select" id="region-country" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>United States</option>
                                    <option>United Kingdom</option>
                                    <option>Canada</option>
                                    <option>Australia</option>
                                    <option>Germany</option>
                                    <option>France</option>
                                    <option>Japan</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label>Date Format</label>
                                <select class="settings-select" id="region-date-format" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>MM/DD/YYYY</option>
                                    <option>DD/MM/YYYY</option>
                                    <option>YYYY-MM-DD</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label>Time Zone</label>
                                <select class="settings-select" id="region-timezone" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>UTC-8 (Pacific Time)</option>
                                    <option>UTC-5 (Eastern Time)</option>
                                    <option>UTC+0 (GMT)</option>
                                    <option>UTC+1 (Central European Time)</option>
                                    <option>UTC+9 (Japan Standard Time)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="power-page">
                        <div class="settings-section">
                            <h3>Power Management</h3>
                            <div class="settings-item">
                                <label>Power Profile</label>
                                <select class="settings-select" id="power-profile" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Balanced</option>
                                    <option>Power Saver</option>
                                    <option>High Performance</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label>Screen Timeout</label>
                                <select class="settings-select" id="power-screen-timeout" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Never</option>
                                    <option>1 minute</option>
                                    <option>5 minutes</option>
                                    <option>10 minutes</option>
                                    <option>15 minutes</option>
                                    <option>30 minutes</option>
                                </select>
                            </div>
                            <div class="settings-item">
                                <label>Sleep After</label>
                                <select class="settings-select" id="power-sleep-after" style="width: 100%; padding: 8px; margin-top: 8px;">
                                    <option>Never</option>
                                    <option>5 minutes</option>
                                    <option>15 minutes</option>
                                    <option>30 minutes</option>
                                    <option>1 hour</option>
                                    <option>2 hours</option>
                                </select>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Battery</h3>
                            <div class="settings-item">
                                <label>Battery Status</label>
                                <div style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-top: 4px;" id="power-battery-status">Not Available</div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Battery Saver Mode</span>
                                    <div class="settings-toggle" id="power-battery-saver-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-item">
                                <div class="settings-toggle-container">
                                    <span class="settings-toggle-label">Show Battery Percentage</span>
                                    <div class="settings-toggle active" id="power-battery-percentage-toggle">
                                        <div class="settings-toggle-slider"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="applications-page">
                        <div class="settings-section">
                            <h3>Installed Applications</h3>
                            <div class="settings-item">
                                <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 8px;">
</div>
                            </div>
                        </div>
                    </div>
                        <div class="settings-page" id="about-page">
                            <div class="settings-section">
                                <div class="pilkos-logo-container">
                                    <img class="pilkos-logo" src="../assets/icons/pilkos-logo.svg" alt="PilkOS logo">
                                </div>
                                <h3>PilkOS</h3>
                                <div class="settings-item">
                                    <p style="color: rgba(255, 255, 255, 0.7); font-size: 13px; margin-bottom: 12px; line-height: 1.6;">A modern desktop environment built with web technologies.</p>
                                    <p style="color: rgba(255, 255, 255, 0.7); font-size: 13px;"> 2026 PilkOS</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        windowsContainer.appendChild(window);
        
        // Save initial position to ensure window state is tracked
        // Use setTimeout to ensure window is rendered before saving
        setTimeout(() => {
            saveSettingsWindowsState();
        }, 0);
        
        makeWindowDraggable(window, { onDragEnd: saveSettingsWindowsState });
        makeWindowResizable(window, { onResize: saveSettingsWindowsState });
        setupWindowControls(window);
        setupSettingsSidebar(window);
        setupUserManagement(window);
        
        // Restore active sidebar page or default to "users" if window was closed
        let activePageToRestore = 'users'; // Default
        if (restoreState && restoreState.activePage) {
            // Check if window was closed (should default to users)
            const wasClosed = localStorage.getItem(`settingsWindowClosed_${windowId}`) === 'true';
            if (!wasClosed) {
                activePageToRestore = restoreState.activePage;
            }
            // Clear the closed flag since we're restoring/opening
            localStorage.removeItem(`settingsWindowClosed_${windowId}`);
        } else {
            // New window - clear any closed flag and default to users
            localStorage.removeItem(`settingsWindowClosed_${windowId}`);
        }
        
        // Set the active sidebar item and page
        const sidebarItems = window.querySelectorAll('.settings-sidebar .sidebar-item');
        const pages = window.querySelectorAll('.settings-page');
        sidebarItems.forEach(item => {
            if (item.dataset.page === activePageToRestore) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });
        pages.forEach(page => {
            if (page.id === `${activePageToRestore}-page`) {
                page.classList.add('active');
            } else {
                page.classList.remove('active');
            }
        });
        
        // Add icon to App bar (uses window.id automatically)
        addToAppBar(window);
        // Ensure dock icon reflects minimized/restored state on creation/restoration
        updateWindowAppBarState(window, false, isMinimized);
        
        // Focus the window (unless minimized)
        if (!isMinimized) {
            focusWindow(window);
        }
        
        // Focus window when clicked
        window.addEventListener('mousedown', function() {
            if (window.style.display !== 'none') {
                focusWindow(window);
            }
        });
        
        return window;
    }
    
    function addToAppBar(window) {
        return addWindowToAppBar(window, {
            iconSvg: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>`,
            onIconClick: function() {
                toggleWindowFromDock(window, saveSettingsWindowsState);
            }
        });
    }
    
    function setupWindowControls(window) {
        const closeBtn = window.querySelector('.window-control.close');
        const minimizeBtn = window.querySelector('.window-control.minimize');
        const maximizeBtn = window.querySelector('.window-control.maximize');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                // Get window ID before removing from DOM
                const windowId = window.id;
                // Mark that this window was closed (so it defaults to "users" on next open)
                localStorage.setItem(`settingsWindowClosed_${windowId}`, 'true');
                window.remove();
                saveSettingsWindowsState();
                if (windowId) {
                    removeWindowFromAppBar(windowId);
                }
            });
        }
        
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', function() {
                const isMinimized = window.style.display === 'none';
                if (isMinimized) {
                    window.style.display = 'flex';
                    focusWindow(window);
                    updateWindowAppBarState(window, true, false);
                } else {
                    window.style.display = 'none';
                    window.classList.remove('window-focused');
                    updateWindowAppBarState(window, false, true);
                }
                saveSettingsWindowsState();
            });
        }
        
        if (maximizeBtn) {
            // Store previous size/position for restore and track maximize state
            let previousSize = null;
            let isMaximized = false;
            
            maximizeBtn.addEventListener('click', function() {
                if (isMaximized) {
                    // Restore to previous size
                    if (previousSize) {
                        window.style.width = previousSize.width;
                        window.style.height = previousSize.height;
                        window.style.left = previousSize.left;
                        window.style.top = previousSize.top;
                    } else {
                        // Fallback to defaults
                        window.style.width = '700px';
                        window.style.height = '500px';
                        window.style.left = '200px';
                        window.style.top = '100px';
                    }
                    isMaximized = false;
                } else {
                    // Save current position before maximizing
                    previousSize = {
                        width: window.style.width || window.offsetWidth + 'px',
                        height: window.style.height || window.offsetHeight + 'px',
                        left: window.style.left || window.offsetLeft + 'px',
                        top: window.style.top || window.offsetTop + 'px'
                    };
                    maximizeWindowToBounds(window);
                    isMaximized = true;
                }
                saveSettingsWindowsState();
            });
        }
    }
    
    function setupSettingsSidebar(window) {
        const sidebarItems = window.querySelectorAll('.settings-sidebar .sidebar-item');
        const pages = window.querySelectorAll('.settings-page');
        
        // Function to navigate to a page
        function navigateToPage(targetPage, clickedItem = null) {
                // Remove active class from all sidebar items and pages
                sidebarItems.forEach(i => i.classList.remove('active'));
                pages.forEach(p => p.classList.remove('active'));
                
            // Add active class to corresponding sidebar item
            if (clickedItem) {
                clickedItem.classList.add('active');
            } else {
                const targetSidebarItem = window.querySelector(`.settings-sidebar .sidebar-item[data-page="${targetPage}"]`);
                if (targetSidebarItem) {
                    targetSidebarItem.classList.add('active');
                }
            }
            
            // Add active class to corresponding page
                const targetPageElement = window.querySelector(`#${targetPage}-page`);
                if (targetPageElement) {
                    targetPageElement.classList.add('active');
                }
                
                // Save the active page to window state
                saveSettingsWindowsState();
        }
        
        sidebarItems.forEach(item => {
            item.addEventListener('click', function() {
                const targetPage = this.dataset.page;
                navigateToPage(targetPage, this);
            });
        });
        
        // Make footer clickable to navigate to About OS page
        const footer = window.querySelector('.settings-sidebar-footer');
        if (footer) {
            footer.addEventListener('click', function() {
                navigateToPage('about');
            });
            
            // Add hover effect
            footer.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(35, 35, 45, 0.95)';
                this.style.borderColor = 'rgba(93, 173, 226, 0.3)';
            });
            footer.addEventListener('mouseleave', function() {
                this.style.background = 'rgba(25, 25, 35, 0.85)';
                this.style.borderColor = 'rgba(255, 255, 255, 0.1)';
            });
        }
        
        // Setup search functionality
        const searchInput = window.querySelector('#settings-search-input');
        const searchResults = window.querySelector('#settings-search-results');
        
        if (searchInput && searchResults) {
            // Build index of all settings
            function buildSettingsIndex() {
                const index = [];
                const pageMap = {
                    'system': 'System',
                    'users': 'Users',
                    'network': 'Network',
                    'bluetooth': 'Bluetooth & Devices',
                    'sound': 'Sound',
                    'display': 'Display',
                    'notifications': 'Notifications',
                    'privacy': 'Privacy & Security',
                    'accessibility': 'Accessibility',
                    'language': 'Language & Region',
                    'power': 'Power',
                    'applications': 'Applications',
                    'about': 'About'
                };
                
                pages.forEach(page => {
                    const pageId = page.id.replace('-page', '');
                    const pageName = pageMap[pageId] || pageId;
                    
                    // Get all section headings
                    const sections = page.querySelectorAll('.settings-section h3');
                    sections.forEach(section => {
                        const sectionName = section.textContent.trim();
                        index.push({
                            text: sectionName,
                            page: pageId,
                            pageName: pageName,
                            type: 'section',
                            element: section
                        });
                    });
                    
                    // Get all labels
                    const labels = page.querySelectorAll('.settings-item label');
                    labels.forEach(label => {
                        const labelText = label.textContent.trim();
                        if (labelText) {
                            index.push({
                                text: labelText,
                                page: pageId,
                                pageName: pageName,
                                type: 'setting',
                                element: label.closest('.settings-item') || label
                            });
                        }
                    });
                    
                    // Get all toggle labels
                    const toggleLabels = page.querySelectorAll('.settings-toggle-label');
                    toggleLabels.forEach(toggleLabel => {
                        const toggleText = toggleLabel.textContent.trim();
                        if (toggleText) {
                            index.push({
                                text: toggleText,
                                page: pageId,
                                pageName: pageName,
                                type: 'toggle',
                                element: toggleLabel.closest('.settings-item') || toggleLabel
                            });
                        }
                    });
                });
                
                return index;
            }
            
            const settingsIndex = buildSettingsIndex();
            
            function performSearch(query) {
                const lowerQuery = query.toLowerCase().trim();
                
                if (lowerQuery === '') {
                    // Show all sidebar items and hide results
                    sidebarItems.forEach(item => {
                        item.style.display = '';
                    });
                    searchResults.style.display = 'none';
                    return;
                }
                
                // Filter sidebar items
                sidebarItems.forEach(item => {
                    const itemText = item.textContent.toLowerCase();
                    if (itemText.includes(lowerQuery)) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                });
                
                // Search individual settings
                const matchingSettings = settingsIndex.filter(item => 
                    item.text.toLowerCase().includes(lowerQuery)
                );
                
                if (matchingSettings.length > 0) {
                    // Display results
                    const resultsHTML = matchingSettings.slice(0, 10).map(item => {
                        const typeIcon = item.type === 'section' ? '' : item.type === 'toggle' ? '' : '';
                        return `
                            <div class="search-result-item" data-page="${item.page}" data-type="${item.type}" data-setting-text="${item.text.replace(/"/g, '&quot;')}" style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid rgba(255, 255, 255, 0.05); transition: background 0.2s;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 14px;">${typeIcon}</span>
                                    <div style="flex: 1;">
                                        <div style="color: rgba(255, 255, 255, 0.9); font-size: 13px; font-weight: 500;">${item.text}</div>
                                        <div style="color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 2px;">${item.pageName}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    searchResults.innerHTML = resultsHTML;
                    
                    // Add hover effects
                    searchResults.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('mouseenter', function() {
                            this.style.background = 'rgba(93, 173, 226, 0.2)';
                        });
                        item.addEventListener('mouseleave', function() {
                            this.style.background = 'transparent';
                        });
                    });
                    
                    if (matchingSettings.length > 10) {
                        searchResults.innerHTML += `<div style="padding: 8px 12px; color: rgba(255, 255, 255, 0.5); font-size: 12px; text-align: center;">+${matchingSettings.length - 10} more results</div>`;
                    }
                    
                    searchResults.style.display = 'block';
                    
                    // Add click handlers to results
                    searchResults.querySelectorAll('.search-result-item').forEach(resultItem => {
                        resultItem.addEventListener('click', function() {
                            const targetPage = this.dataset.page;
                            const settingText = this.dataset.settingText;
                            
                            // Navigate to the page
                            sidebarItems.forEach(i => i.classList.remove('active'));
                            pages.forEach(p => p.classList.remove('active'));
                            
                            const targetSidebarItem = window.querySelector(`.sidebar-item[data-page="${targetPage}"]`);
                            const targetPageElement = window.querySelector(`#${targetPage}-page`);
                            
                            if (targetSidebarItem && targetPageElement) {
                                targetSidebarItem.classList.add('active');
                                targetPageElement.classList.add('active');
                                
                                // Scroll to the setting if possible
                                const settingIndex = settingsIndex.find(item => 
                                    item.page === targetPage && 
                                    item.text === settingText
                                );
                                
                                if (settingIndex && settingIndex.element) {
                                    setTimeout(() => {
                                        settingIndex.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                        // Highlight briefly
                                        const originalBg = settingIndex.element.style.backgroundColor;
                                        settingIndex.element.style.backgroundColor = 'rgba(93, 173, 226, 0.3)';
                                        settingIndex.element.style.transition = 'background-color 0.3s';
                                        setTimeout(() => {
                                            settingIndex.element.style.backgroundColor = originalBg;
                                        }, 2000);
                                    }, 100);
                                }
                            }
                            
                            // Clear search
                            searchInput.value = '';
                            searchResults.style.display = 'none';
                            sidebarItems.forEach(item => item.style.display = '');
                        });
                    });
                } else {
                    searchResults.innerHTML = '<div style="padding: 12px; color: rgba(255, 255, 255, 0.5); font-size: 13px; text-align: center;">No results found</div>';
                    searchResults.style.display = 'block';
                }
            }
            
            searchInput.addEventListener('input', function() {
                performSearch(this.value);
            });
            
            // Clear search on Escape key
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    this.value = '';
                    performSearch('');
                    this.blur();
                }
            });
            
            // Hide results when clicking outside
            document.addEventListener('click', function(e) {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.style.display = 'none';
                }
            });
        }
    }
    
    function setupUserManagement(window) {
        const usersList = window.querySelector('#users-list');
        const addUserBtn = window.querySelector('#add-user-btn');
        const permissionLevel = window.querySelector('#account-permission-level');
        const canManageUsers = window.querySelector('#account-can-manage-users');
        const canDeleteAdmin = window.querySelector('#account-can-delete-admin');
        const canModifySystem = window.querySelector('#account-can-modify-system');
        
        // Update account permissions display
        function updateAccountPermissions() {
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    const userRole = user.role || 'user';
                    const isAdmin = userRole === 'admin';
                    
                    if (permissionLevel) {
                        permissionLevel.textContent = isAdmin ? 'Administrator' : 'Standard User';
                    }
                    if (canManageUsers) {
                        canManageUsers.textContent = isAdmin ? 'Yes' : 'No';
                    }
                    if (canDeleteAdmin) {
                        canDeleteAdmin.textContent = isAdmin ? 'Yes' : 'No';
                    }
                    if (canModifySystem) {
                        canModifySystem.textContent = isAdmin ? 'Yes' : 'No';
                    }
                } catch (e) {
                    if (permissionLevel) permissionLevel.textContent = 'Not logged in';
                    if (canManageUsers) canManageUsers.textContent = 'No';
                    if (canDeleteAdmin) canDeleteAdmin.textContent = 'No';
                    if (canModifySystem) canModifySystem.textContent = 'No';
                }
            } else {
                if (permissionLevel) permissionLevel.textContent = 'Not logged in';
                if (canManageUsers) canManageUsers.textContent = 'No';
                if (canDeleteAdmin) canDeleteAdmin.textContent = 'No';
                if (canModifySystem) canModifySystem.textContent = 'No';
            }
        }
        
        // Render users list
        function renderUsersList() {
            if (!usersList) return;
            
            const users = getUsers();
            usersList.innerHTML = '';
            
            if (users.length === 0) {
                usersList.innerHTML = '<div style="color: rgba(255, 255, 255, 0.5); font-size: 13px; padding: 20px; text-align: center;">No users found. Add a user to get started.</div>';
                return;
            }
            
            // Get current logged-in user
            const loggedInUser = localStorage.getItem('loggedInUser');
            let currentUserId = null;
            let currentUserRole = null;
            if (loggedInUser) {
                try {
                    const current = JSON.parse(loggedInUser);
                    currentUserId = current.id;
                    currentUserRole = current.role || 'user';
                } catch (e) {}
            }
            
            users.forEach(user => {
                const isCurrentUser = user.id === currentUserId;
                const isAdmin = (user.role || 'user') === 'admin';
                const isCurrentUserAdmin = currentUserRole === 'admin';
                // Hide remove button if: current user OR (target is admin AND current user is not admin)
                const shouldHideRemoveButton = isCurrentUser || (isAdmin && !isCurrentUserAdmin);
                const userItem = document.createElement('div');
                userItem.className = 'user-list-item';
                userItem.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; transition: all 0.2s;';
                
                userItem.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                        <div class="user-avatar-small">${getUserAvatarInnerHTML(user)}</div>
                        <div style="flex: 1;">
                            <div style="color: rgba(255, 255, 255, 0.9); font-size: 13px; font-weight: 500;">${user.name}</div>
                            <div style="color: rgba(255, 255, 255, 0.5); font-size: 11px; margin-top: 2px;">ID: ${user.id}</div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        <button class="nav-button edit-user-btn settings-panel-btn" data-user-id="${user.id}">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </button>
                        ${shouldHideRemoveButton ? '' : `<button type="button" class="nav-button remove-user-btn settings-panel-btn" data-user-id="${user.id}" aria-label="Delete user" title="Delete user">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>`}
                    </div>
                `;
                
                // Hover effect
                userItem.addEventListener('mouseenter', function() {
                    this.style.background = 'rgba(255, 255, 255, 0.08)';
                    this.style.borderColor = 'rgba(255, 255, 255, 0.15)';
                });
                userItem.addEventListener('mouseleave', function() {
                    this.style.background = 'rgba(255, 255, 255, 0.05)';
                    this.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                });
                
                // Edit button
                const editBtn = userItem.querySelector('.edit-user-btn');
                editBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showUserModal(user);
                });
                
                // Remove button (only if not current user)
                const removeBtn = userItem.querySelector('.remove-user-btn');
                if (removeBtn) {
                    removeBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        removeUserWithConfirmation(user);
                    });
                    
                    removeBtn.addEventListener('mouseenter', function() {
                        this.style.background = 'rgba(255, 77, 77, 0.12)';
                        this.style.color = 'rgba(255, 77, 77, 0.95)';
                    });
                    removeBtn.addEventListener('mouseleave', function() {
                        this.style.background = 'transparent';
                        this.style.color = 'rgba(255, 255, 255, 0.7)';
                    });
                }
                
                // Button hover effects
                editBtn.addEventListener('mouseenter', function() {
                    this.style.background = 'rgba(93, 173, 226, 0.3)';
                    this.style.borderColor = 'rgba(93, 173, 226, 0.7)';
                });
                editBtn.addEventListener('mouseleave', function() {
                    this.style.background = 'rgba(93, 173, 226, 0.2)';
                    this.style.borderColor = 'rgba(93, 173, 226, 0.5)';
                });
                
                usersList.appendChild(userItem);
            });
        }
        
        // Show user modal for add/edit
        function showUserModal(user = null) {
            const isEdit = user !== null;
            const modal = document.createElement('div');
            modal.className = 'user-modal-overlay';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(4px); z-index: 20000; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s;';
            
            const dialog = document.createElement('div');
            dialog.className = 'user-modal-dialog';
            dialog.style.cssText = 'background: rgba(25, 25, 35, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); min-width: 400px; max-width: 500px; padding: 24px; display: flex; flex-direction: column; gap: 20px; transform: scale(0.95); transition: transform 0.2s;';
            
            dialog.innerHTML = `
                <div style="font-size: 18px; font-weight: 600; color: #5dade2; margin: 0;">${isEdit ? 'Edit User' : 'Add New User'}</div>
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <div>
                        <label style="display: block; margin-bottom: 6px; color: rgba(255, 255, 255, 0.7); font-size: 13px; font-weight: 400;">Name</label>
                        <input type="text" id="user-name-input" value="${user ? user.name : ''}" placeholder="Enter user name" style="width: 100%; padding: 10px 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 13px; font-family: inherit; outline: none; box-sizing: border-box;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 6px; color: rgba(255, 255, 255, 0.7); font-size: 13px; font-weight: 400;">Password</label>
                        <div class="user-modal-password-field">
                            <input type="password" id="user-password-input" value="${user ? user.password : ''}" placeholder="Enter password" style="width: 100%; padding: 10px 44px 10px 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 13px; font-family: inherit; outline: none; box-sizing: border-box;">
                            <button type="button" class="user-modal-password-toggle" aria-label="Show password" aria-pressed="false" title="Show password">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                    <circle cx="12" cy="12" r="3"></circle>
                                    <line x1="1" y1="1" x2="23" y2="23"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    ${isEdit ? `
                    <div style="background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 12px;">
                        <div style="color: rgba(255, 255, 255, 0.85); font-size: 13px; font-weight: 600; margin-bottom: 10px;">Account Permissions</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px 14px;">
                            <div>
                                <div style="color: rgba(255, 255, 255, 0.65); font-size: 12px; margin-bottom: 4px;">Permission Level</div>
                                <div id="edit-user-permission-level" style="color: rgba(255, 255, 255, 0.9); font-size: 13px;"></div>
                            </div>
                            <div>
                                <div style="color: rgba(255, 255, 255, 0.65); font-size: 12px; margin-bottom: 4px;">Can Manage Users</div>
                                <div id="edit-user-can-manage-users" style="color: rgba(255, 255, 255, 0.9); font-size: 13px;"></div>
                            </div>
                            <div>
                                <div style="color: rgba(255, 255, 255, 0.65); font-size: 12px; margin-bottom: 4px;">Can Delete Admin Accounts</div>
                                <div id="edit-user-can-delete-admin" style="color: rgba(255, 255, 255, 0.9); font-size: 13px;"></div>
                            </div>
                            <div>
                                <div style="color: rgba(255, 255, 255, 0.65); font-size: 12px; margin-bottom: 4px;">Can Modify System Settings</div>
                                <div id="edit-user-can-modify-system" style="color: rgba(255, 255, 255, 0.9); font-size: 13px;"></div>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    <div>
                        <label style="display: block; margin-bottom: 6px; color: rgba(255, 255, 255, 0.7); font-size: 13px; font-weight: 400;">Profile Picture</label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div id="user-avatar-preview" class="user-avatar-small" style="width: 64px; height: 64px; font-size: 24px; border-width: 2px;"></div>
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 8px;">
                                <input type="file" id="user-avatar-file-input" accept="image/*" style="display: none;" />
                                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                    <button type="button" id="user-avatar-choose-btn" style="padding: 8px 12px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; background: rgba(255, 255, 255, 0.05); color: rgba(255, 255, 255, 0.9); font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;">Choose Picture</button>
                                    <button type="button" id="user-avatar-remove-btn" style="padding: 8px 12px; border: 1px solid rgba(255, 77, 77, 0.35); border-radius: 6px; background: rgba(255, 77, 77, 0.12); color: rgba(255, 77, 77, 0.95); font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; display: none;">Remove</button>
                                </div>
                                <div style="color: rgba(255, 255, 255, 0.5); font-size: 11px; line-height: 1.4;">
                                    Uses a resized image (stored locally). If no picture is set, the default user icon is used.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 8px;">
                    <button class="user-modal-cancel" style="padding: 8px 20px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; background: rgba(255, 255, 255, 0.05); color: rgba(255, 255, 255, 0.9); font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; min-width: 80px;">Cancel</button>
                    <button class="user-modal-save" style="padding: 8px 20px; border: 1px solid rgba(93, 173, 226, 0.5); border-radius: 6px; background: rgba(93, 173, 226, 0.2); color: #5dade2; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; min-width: 80px;">${isEdit ? 'Save' : 'Add'}</button>
                </div>
            `;
            
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // Animate in
            setTimeout(() => {
                modal.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);

            // Populate Account Permissions section (Edit User dialog only)
            if (isEdit) {
                const role = (user && user.role) ? String(user.role) : 'user';
                const isAdmin = role === 'admin';
                const permissionLevelEl = dialog.querySelector('#edit-user-permission-level');
                const canManageUsersEl = dialog.querySelector('#edit-user-can-manage-users');
                const canDeleteAdminEl = dialog.querySelector('#edit-user-can-delete-admin');
                const canModifySystemEl = dialog.querySelector('#edit-user-can-modify-system');

                if (permissionLevelEl) permissionLevelEl.textContent = isAdmin ? 'Administrator' : 'Standard User';
                if (canManageUsersEl) canManageUsersEl.textContent = isAdmin ? 'Yes' : 'No';
                if (canDeleteAdminEl) canDeleteAdminEl.textContent = isAdmin ? 'Yes' : 'No';
                if (canModifySystemEl) canModifySystemEl.textContent = isAdmin ? 'Yes' : 'No';
            }
            
            // Focus name input
            const nameInput = dialog.querySelector('#user-name-input');
            if (nameInput) {
                setTimeout(() => nameInput.focus(), 100);
            }

            // Password show/hide toggle (same eye icon as Files app)
            const userPasswordInput = dialog.querySelector('#user-password-input');
            const userPasswordToggle = dialog.querySelector('.user-modal-password-toggle');
            const userPasswordToggleSvg = userPasswordToggle ? userPasswordToggle.querySelector('svg') : null;
            let userPasswordVisible = false;

            const setUserPasswordVisible = (visible) => {
                if (!userPasswordInput) return;
                userPasswordVisible = !!visible;
                userPasswordInput.type = userPasswordVisible ? 'text' : 'password';

                if (userPasswordToggle) {
                    userPasswordToggle.setAttribute('aria-pressed', userPasswordVisible ? 'true' : 'false');
                    userPasswordToggle.setAttribute('aria-label', userPasswordVisible ? 'Hide password' : 'Show password');
                    userPasswordToggle.title = userPasswordVisible ? 'Hide password' : 'Show password';
                }

                if (userPasswordToggleSvg) {
                    if (userPasswordVisible) {
                        userPasswordToggleSvg.innerHTML = `
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        `;
                    } else {
                        userPasswordToggleSvg.innerHTML = `
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                            <line x1="1" y1="1" x2="23" y2="23"></line>
                        `;
                    }
                }
            };

            if (userPasswordInput && userPasswordToggle) {
                setUserPasswordVisible(false);
                userPasswordToggle.addEventListener('click', () => {
                    setUserPasswordVisible(!userPasswordVisible);
                    try { userPasswordInput.focus(); } catch (e) {}
                });
            }
            
            // Cancel button
            dialog.querySelector('.user-modal-cancel').addEventListener('click', function() {
                closeModal();
            });

            // Avatar upload/preview handling
            const avatarPreview = dialog.querySelector('#user-avatar-preview');
            const chooseAvatarBtn = dialog.querySelector('#user-avatar-choose-btn');
            const removeAvatarBtn = dialog.querySelector('#user-avatar-remove-btn');
            const avatarFileInput = dialog.querySelector('#user-avatar-file-input');

            let pendingAvatarImage = (user && user.avatarImage) ? user.avatarImage : null;

            const renderAvatarPreview = () => {
                if (!avatarPreview) return;
                if (pendingAvatarImage) {
                    avatarPreview.innerHTML = `<img src="${pendingAvatarImage}" alt="" draggable="false" />`;
                    if (removeAvatarBtn) removeAvatarBtn.style.display = 'inline-flex';
                } else {
                    avatarPreview.innerHTML = getUserAvatarInnerHTML({ avatarImage: null });
                    if (removeAvatarBtn) removeAvatarBtn.style.display = 'none';
                }
            };

            renderAvatarPreview();

            const nameInputEl = dialog.querySelector('#user-name-input');
            if (nameInputEl) {
                nameInputEl.addEventListener('input', () => {
                    if (!pendingAvatarImage) renderAvatarPreview();
                });
            }

            if (chooseAvatarBtn && avatarFileInput) {
                chooseAvatarBtn.addEventListener('click', () => avatarFileInput.click());
            }

            if (avatarFileInput) {
                avatarFileInput.addEventListener('change', async () => {
                    const file = avatarFileInput.files && avatarFileInput.files[0] ? avatarFileInput.files[0] : null;
                    if (!file) return;
                    try {
                        pendingAvatarImage = await resizeImageFileToDataUrl(file, 128, 0.85);
                        renderAvatarPreview();
                    } catch (err) {
                        alert((err && err.message) ? err.message : 'Failed to set profile picture.');
                    }
                });
            }

            if (removeAvatarBtn) {
                removeAvatarBtn.addEventListener('click', () => {
                    pendingAvatarImage = null;
                    if (avatarFileInput) avatarFileInput.value = '';
                    renderAvatarPreview();
                });
            }
            
            // Save button
            dialog.querySelector('.user-modal-save').addEventListener('click', function() {
                const name = dialog.querySelector('#user-name-input').value.trim();
                const password = dialog.querySelector('#user-password-input').value.trim();
                const avatarImage = pendingAvatarImage;
                
                if (!name) {
                    alert('Please enter a user name');
                    return;
                }
                if (!password) {
                    alert('Please enter a password');
                    return;
                }
                
                if (isEdit) {
                    updateUser(user.id, { name, password, avatarImage });
                } else {
                    addUser({ name, password, avatarImage });
                }
                
                renderUsersList();
                refreshLoginScreen();
                closeModal();
            });
            
            // Close on overlay click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // Close on Escape
            function handleEscape(e) {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', handleEscape);
                }
            }
            document.addEventListener('keydown', handleEscape);
            
            function closeModal() {
                modal.style.opacity = '0';
                dialog.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    modal.remove();
                }, 200);
            }
        }
        
        // Remove user with confirmation
        function removeUserWithConfirmation(user) {
            const users = getUsers();
            if (users.length <= 1) {
                alert('Cannot remove the last user. At least one user must exist.');
                return;
            }
            
            // Check if this is the currently logged in user
            const loggedInUser = localStorage.getItem('loggedInUser');
            let isCurrentUser = false;
            let currentUserRole = null;
            if (loggedInUser) {
                try {
                    const current = JSON.parse(loggedInUser);
                    isCurrentUser = current.id === user.id;
                    currentUserRole = current.role || 'user';
                } catch (e) {}
            }
            
            // Prevent removing the current user
            if (isCurrentUser) {
                alert('You cannot remove your own account while logged in. Please log out and use a different account to remove this user.');
                return;
            }
            
            // Check if trying to remove an admin account as a non-admin user
            const targetUserRole = user.role || 'user';
            if (targetUserRole === 'admin' && currentUserRole !== 'admin') {
                alert('You do not have permission to remove administrator accounts. Only administrators can remove other administrator accounts.');
                return;
            }
            
            const message = `Are you sure you want to remove "${user.name}"?`;
            
            if (confirm(message)) {
                removeUser(user.id);
                renderUsersList();
                refreshLoginScreen();
            }
        }
        
        // Add user button
        if (addUserBtn) {
            addUserBtn.addEventListener('click', function() {
                showUserModal();
            });
            
            // Hover effect
            addUserBtn.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(93, 173, 226, 0.3)';
                this.style.borderColor = 'rgba(93, 173, 226, 0.7)';
            });
            addUserBtn.addEventListener('mouseleave', function() {
                this.style.background = 'rgba(93, 173, 226, 0.2)';
                this.style.borderColor = 'rgba(93, 173, 226, 0.5)';
            });
        }
        
        // Initial render
        renderUsersList();
        updateAccountPermissions();
        
        // Re-render when users page becomes active
        const usersPage = window.querySelector('#users-page');
        if (usersPage) {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        if (usersPage.classList.contains('active')) {
                            renderUsersList();
                            updateAccountPermissions();
                        }
                    }
                });
            });
            observer.observe(usersPage, { attributes: true });
        }
        
        // Setup display brightness slider
        const brightnessSlider = window.querySelector('#display-brightness');
        const brightnessValue = window.querySelector('#display-brightness-value');
        
        if (brightnessSlider && brightnessValue) {
            // Function to update brightness slider progress bar
            function updateBrightnessSliderProgress(value) {
                brightnessSlider.style.setProperty('--slider-percent', value + '%');
            }
            
            // Initialize progress bar with saved or default value
            const savedBrightness = localStorage.getItem('displayBrightness') || brightnessSlider.value;
            brightnessSlider.value = savedBrightness;
            updateBrightnessSliderProgress(savedBrightness);
            
            // Apply saved brightness if auto is disabled (access function directly from window)
            const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
            if (!autoBrightnessEnabled && window.applyBrightness) {
                window.applyBrightness(savedBrightness);
            }
            
            brightnessSlider.addEventListener('input', function() {
                const value = parseInt(this.value, 10);
                brightnessValue.textContent = value + '%';
                updateBrightnessSliderProgress(value);
                // Save brightness to localStorage
                localStorage.setItem('displayBrightness', value.toString());
                
                // Disable auto-brightness if user manually adjusts
                const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
                if (autoBrightnessEnabled) {
                    localStorage.setItem('autoBrightnessEnabled', 'false');
                    const autoButton = window.querySelector('#auto-brightness-button');
                    if (autoButton) {
                        const diagonal = autoButton.querySelector('.auto-brightness-diagonal');
                        if (diagonal) diagonal.style.display = 'block';
                    }
                }
                
                // Apply manual brightness (access function directly from window)
                if (window.applyBrightness) {
                    window.applyBrightness(value);
                } else {
                    // Fallback: apply brightness directly if function not available
                    let overlay = document.getElementById('auto-brightness-overlay');
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.id = 'auto-brightness-overlay';
                        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; z-index: 999999; transition: opacity 0.5s ease; opacity: 0;';
                        document.body.appendChild(overlay);
                    }
                    const opacity = ((100 - value) / 100) * 0.8;
                    overlay.style.opacity = opacity.toString();
                }
            });
            
            // Note: Auto-brightness interval is already set up globally in initAutoBrightness()
            // Just do initial update if auto is enabled
            if (autoBrightnessEnabled && window.updateAutoBrightness) {
                window.updateAutoBrightness();
            }
            
            // Setup auto-brightness button (inside brightness slider scope to access functions)
            const autoBrightnessButton = window.querySelector('#auto-brightness-button');
            if (autoBrightnessButton) {
                // Load saved preference
                const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled');
                const shouldEnableAutoBrightness = autoBrightnessEnabled === 'true'; // Default to disabled
                const diagonalLine = autoBrightnessButton.querySelector('.auto-brightness-diagonal');
                
                if (shouldEnableAutoBrightness) {
                    if (diagonalLine) diagonalLine.style.display = 'none';
                } else {
                    if (diagonalLine) diagonalLine.style.display = 'block';
                }
                
                // Setup tooltip for auto-brightness button
                const autoBrightnessTooltip = setupNavButtonTooltip(autoBrightnessButton, () => {
                    const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
                    return 'Toggle Auto Mode';
                });
                
                autoBrightnessButton.addEventListener('click', function() {
                    const diagonal = this.querySelector('.auto-brightness-diagonal');
                    const isDisabled = diagonal && diagonal.style.display === 'block';
                    if (isDisabled) {
                        // Enable auto-brightness
                        if (diagonal) diagonal.style.display = 'none';
                        localStorage.setItem('autoBrightnessEnabled', 'true');
                        // Update brightness immediately based on time of day
                        // Force update by calling updateAutoBrightness or calculating manually
                        if (window.updateAutoBrightness) {
                            // Call the function which will check localStorage and apply brightness
                            window.updateAutoBrightness();
                        }
                        // Always also calculate and apply brightness directly to ensure it works
                        const now = new Date();
                        const hour = now.getHours();
                        let brightness = 80;
                        if (hour >= 6 && hour < 8) {
                            const progress = (hour - 6) / 2;
                            brightness = 30 + (progress * 40);
                        } else if (hour >= 8 && hour < 18) {
                            if (hour < 12) {
                                const progress = (hour - 8) / 4;
                                brightness = 70 + (progress * 30);
                            } else {
                                const progress = (18 - hour) / 6;
                                brightness = 70 + (progress * 30);
                            }
                        } else if (hour >= 18 && hour < 22) {
                            const progress = (hour - 18) / 4;
                            brightness = 70 - (progress * 20);
                        } else {
                            const progress = hour >= 22 ? (hour - 22) / 8 : (hour + 2) / 8;
                            brightness = 50 - (Math.min(progress, 1) * 20);
                        }
                        brightness = Math.max(30, Math.min(100, Math.round(brightness)));
                        // Apply brightness - try global function first, then fallback
                        if (window.applyBrightness) {
                            window.applyBrightness(brightness);
                        } else {
                            // Fallback: apply brightness directly
                            let overlay = document.getElementById('auto-brightness-overlay');
                            if (!overlay) {
                                overlay = document.createElement('div');
                                overlay.id = 'auto-brightness-overlay';
                                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; z-index: 999999; transition: opacity 0.5s ease; opacity: 0;';
                                document.body.appendChild(overlay);
                            }
                            const opacity = ((100 - brightness) / 100) * 0.8;
                            overlay.style.opacity = opacity.toString();
                            // Update slider if it exists
                            const brightnessSlider = window.querySelector('#display-brightness');
                            const brightnessValue = window.querySelector('#display-brightness-value');
                            if (brightnessSlider && brightnessValue) {
                                brightnessSlider.value = brightness;
                                brightnessValue.textContent = brightness + '%';
                                brightnessSlider.style.setProperty('--slider-percent', brightness + '%');
                            }
                            localStorage.setItem('displayBrightness', brightness.toString());
                        }
                    } else {
                        // Disable auto-brightness
                        if (diagonal) diagonal.style.display = 'block';
                        localStorage.setItem('autoBrightnessEnabled', 'false');
                        // Restore manual brightness setting
                        const savedBrightness = localStorage.getItem('displayBrightness') || '80';
                        if (window.applyBrightness) {
                            window.applyBrightness(parseInt(savedBrightness, 10));
                        }
                    }
                    // Update tooltip immediately
                    if (autoBrightnessTooltip && autoBrightnessTooltip.updateTooltip) {
                        autoBrightnessTooltip.updateTooltip();
                    }
                });
            }
        }
        
        // Setup weather icon toggle
        const weatherIconToggle = window.querySelector('#weather-icon-toggle');
        const weatherControlItem = document.querySelector('#weather-icon')?.closest('.dock-control-item');
        
        // Load saved preference
        const weatherIconVisible = localStorage.getItem('weatherIconVisible');
        const shouldShowWeather = weatherIconVisible === null || weatherIconVisible === 'true'; // Default to visible
        
        if (weatherIconToggle) {
            // Set initial toggle state
            if (shouldShowWeather) {
                weatherIconToggle.classList.add('active');
            } else {
                weatherIconToggle.classList.remove('active');
            }
            
            // Apply initial state
            if (weatherControlItem) {
                weatherControlItem.style.display = shouldShowWeather ? 'flex' : 'none';
            }
            
            // Handle toggle click
            weatherIconToggle.addEventListener('click', function() {
                this.classList.toggle('active');
                const isVisible = this.classList.contains('active');
                localStorage.setItem('weatherIconVisible', isVisible.toString());
                
                if (weatherControlItem) {
                    weatherControlItem.style.display = isVisible ? 'flex' : 'none';
                }
            });
        }

        // Setup dock controls visibility toggles
        const dockVisibilityConfigs = [];

        const alwaysVisibleDockItems = [
            document.querySelector('#volume-icon')?.closest('.dock-control-item'),
            document.querySelector('#wifi-icon')?.closest('.dock-control-item'),
            document.querySelector('#bluetooth-icon')?.closest('.dock-control-item'),
            document.querySelector('#battery-icon')?.closest('.dock-control-item')
        ];

        alwaysVisibleDockItems.forEach(item => {
            if (item) {
                item.style.display = 'flex';
            }
        });

        dockVisibilityConfigs.forEach(config => {
            const toggle = window.querySelector(`#${config.toggleId}`);
            const savedState = localStorage.getItem(config.storageKey);
            const isVisible = savedState !== null ? savedState === 'true' : config.defaultVisible;

            if (toggle) {
                toggle.classList.toggle('active', isVisible);
                toggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const nextVisible = this.classList.contains('active');
                    localStorage.setItem(config.storageKey, nextVisible.toString());
                    if (config.element) {
                        config.element.style.display = nextVisible ? config.display : 'none';
                    }
                });
            }

            if (config.element) {
                config.element.style.display = isVisible ? config.display : 'none';
            }
        });
        
        // Setup night light button
        const nightLightButton = window.querySelector('#night-light-button');
        if (nightLightButton) {
            // Load saved preference
            const nightLightEnabled = localStorage.getItem('nightLightEnabled');
            const shouldEnableNightLight = nightLightEnabled === 'true'; // Default to disabled
            const diagonalLine = nightLightButton.querySelector('.night-light-diagonal');
            
            if (shouldEnableNightLight) {
                if (diagonalLine) diagonalLine.style.display = 'none';
            } else {
                if (diagonalLine) diagonalLine.style.display = 'block';
            }
            
            // Setup tooltip for night light button
            const nightLightTooltip = setupNavButtonTooltip(nightLightButton, () => {
                const nightLightEnabled = localStorage.getItem('nightLightEnabled') === 'true';
                return 'Toggle Night Mode';
            });
            
            nightLightButton.addEventListener('click', function() {
                const diagonal = this.querySelector('.night-light-diagonal');
                const isDisabled = diagonal && diagonal.style.display === 'block';
                if (isDisabled) {
                    // Enable night light
                    if (diagonal) diagonal.style.display = 'none';
                    localStorage.setItem('nightLightEnabled', 'true');
                    // Access function directly from window
                    if (window.applyNightLight) {
                        window.applyNightLight(true);
                    } else {
                        // Fallback: apply night light directly
                        let overlay = document.getElementById('night-light-overlay');
                        if (!overlay) {
                            overlay = document.createElement('div');
                            overlay.id = 'night-light-overlay';
                            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 165, 0, 0.15); pointer-events: none; z-index: 999998; transition: opacity 0.5s ease; opacity: 0; mix-blend-mode: multiply;';
                            document.body.appendChild(overlay);
                        }
                        overlay.style.opacity = '1';
                    }
                } else {
                    // Disable night light
                    if (diagonal) diagonal.style.display = 'block';
                    localStorage.setItem('nightLightEnabled', 'false');
                    // Access function directly from window
                    if (window.applyNightLight) {
                        window.applyNightLight(false);
                    } else {
                        // Fallback: disable night light directly
                        const overlay = document.getElementById('night-light-overlay');
                        if (overlay) {
                            overlay.style.opacity = '0';
                        }
                    }
                }
                    // Update tooltip immediately
                    if (nightLightTooltip && nightLightTooltip.updateTooltip) {
                        nightLightTooltip.updateTooltip();
                    }
                    // Also update the tooltip element directly if it exists
                    if (nightLightButton._tooltipElement) {
                        const nightLightEnabled = localStorage.getItem('nightLightEnabled') === 'true';
                        nightLightButton._tooltipElement.textContent = 'Toggle Night Mode';
                    }
            });
        }
        
        // Setup taskbar settings
        const taskbarShowToggle = window.querySelector('#taskbar-show-toggle');
        if (taskbarShowToggle) {
            const taskbarShowEnabled = localStorage.getItem('taskbarShow') !== 'false'; // Default to enabled
            if (taskbarShowEnabled) {
                taskbarShowToggle.classList.add('active');
            }
            taskbarShowToggle.addEventListener('click', function() {
                this.classList.toggle('active');
                const isEnabled = this.classList.contains('active');
                localStorage.setItem('taskbarShow', isEnabled.toString());
            });
        }
        
        const taskbarPosition = window.querySelector('#taskbar-position');
        if (taskbarPosition) {
            const savedPosition = localStorage.getItem('taskbarPosition') || 'Left';
            taskbarPosition.value = savedPosition;
            taskbarPosition.addEventListener('change', function() {
                localStorage.setItem('taskbarPosition', this.value);
            });
        }

        // Dock auto-hide toggle
        const dockAutoHideToggle = window.querySelector('#dock-auto-hide-toggle');
        if (dockAutoHideToggle) {
            const enabled = localStorage.getItem(DOCK_AUTO_HIDE_STORAGE_KEY) === 'true';
            dockAutoHideToggle.classList.toggle('active', enabled);

            // Apply setting immediately when Settings window is created.
            if (typeof globalThis.updateDockAutoHideState === 'function') {
                globalThis.updateDockAutoHideState();
            }

            dockAutoHideToggle.addEventListener('click', function() {
                this.classList.toggle('active');
                const isEnabled = this.classList.contains('active');
                localStorage.setItem(DOCK_AUTO_HIDE_STORAGE_KEY, isEnabled.toString());
                if (typeof globalThis.updateDockAutoHideState === 'function') {
                    globalThis.updateDockAutoHideState();
                }
            });
        }
        
        const taskbarShowLabelsToggle = window.querySelector('#taskbar-show-labels-toggle');
        if (taskbarShowLabelsToggle) {
            // Load saved state or use default (enabled)
            const savedState = localStorage.getItem('taskbarShowLabels');
            const shouldBeActive = savedState !== null 
                ? savedState === 'true' 
                : true; // Default to enabled
            
            // Set initial state based on saved preference
            if (shouldBeActive) {
                taskbarShowLabelsToggle.classList.add('active');
            } else {
                taskbarShowLabelsToggle.classList.remove('active');
            }
            
            // Apply setting immediately when Settings window is created
            updateDockTooltipsVisibility();
            
            taskbarShowLabelsToggle.addEventListener('click', function() {
                this.classList.toggle('active');
                const isEnabled = this.classList.contains('active');
                localStorage.setItem('taskbarShowLabels', isEnabled.toString());
                // Update all dock tooltips visibility
                updateDockTooltipsVisibility();
            });
        }
        
        // Setup all other toggles with localStorage persistence
        const toggleConfigs = [
            { id: 'sound-system-sounds-toggle', key: 'soundSystemSounds', defaultActive: true },
            { id: 'sound-volume-feedback-toggle', key: 'soundVolumeFeedback', defaultActive: true },
            { id: 'notifications-dnd-toggle', key: 'notificationsDND', defaultActive: false },
            { id: 'notifications-show-toggle', key: 'notificationsShow', defaultActive: true },
            { id: 'notifications-sounds-toggle', key: 'notificationsSounds', defaultActive: true },
            { id: 'privacy-location-toggle', key: 'privacyLocation', defaultActive: true },
            { id: 'privacy-camera-toggle', key: 'privacyCamera', defaultActive: true },
            { id: 'privacy-microphone-toggle', key: 'privacyMicrophone', defaultActive: true },
            { id: 'privacy-filesystem-toggle', key: 'privacyFilesystem', defaultActive: true },
            { id: 'security-firewall-toggle', key: 'securityFirewall', defaultActive: true },
            { id: 'security-updates-toggle', key: 'securityUpdates', defaultActive: true },
            { id: 'accessibility-high-contrast-toggle', key: 'accessibilityHighContrast', defaultActive: false },
            { id: 'accessibility-reduce-motion-toggle', key: 'accessibilityReduceMotion', defaultActive: false },
            { id: 'accessibility-sticky-keys-toggle', key: 'accessibilityStickyKeys', defaultActive: false },
            { id: 'accessibility-slow-keys-toggle', key: 'accessibilitySlowKeys', defaultActive: false },
            { id: 'accessibility-mouse-keys-toggle', key: 'accessibilityMouseKeys', defaultActive: false },
            { id: 'power-battery-saver-toggle', key: 'powerBatterySaver', defaultActive: false },
            { id: 'power-battery-percentage-toggle', key: 'powerBatteryPercentage', defaultActive: true }
        ];
        
        toggleConfigs.forEach(config => {
            const toggle = window.querySelector(`#${config.id}`);
            if (toggle) {
                // Load saved state or use default
                const savedState = localStorage.getItem(config.key);
                const shouldBeActive = savedState !== null 
                    ? savedState === 'true' 
                    : config.defaultActive;
                
                // Set initial state
                if (shouldBeActive) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
                
                // Add click handler to save state
                toggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const isActive = this.classList.contains('active');
                    localStorage.setItem(config.key, isActive.toString());
                });
            }
        });
        
        const taskbarSizeSlider = window.querySelector('#taskbar-size-slider');
        const taskbarSizeValue = window.querySelector('#taskbar-size-value');
        if (taskbarSizeSlider && taskbarSizeValue) {
            const savedSize = localStorage.getItem('taskbarSize') || '60';
            taskbarSizeSlider.value = savedSize;
            taskbarSizeValue.textContent = savedSize + 'px';
            taskbarSizeSlider.style.setProperty('--slider-percent', savedSize + '%');
            
            taskbarSizeSlider.addEventListener('input', function() {
                const value = this.value;
                taskbarSizeValue.textContent = value + 'px';
                taskbarSizeSlider.style.setProperty('--slider-percent', value + '%');
                localStorage.setItem('taskbarSize', value);
            });
        }
        
        // Setup 24-hour format toggle
        const clock24HourToggle = window.querySelector('#clock-24-hour-toggle');
        if (clock24HourToggle) {
            // Load saved preference (default to true/24-hour if not set)
            const clockFormatSetting = localStorage.getItem('clock24HourFormat');
            const use24Hour = clockFormatSetting === null ? true : clockFormatSetting === 'true';
            
            if (use24Hour) {
                clock24HourToggle.classList.add('active');
                // Set the value in localStorage if it wasn't set
                if (clockFormatSetting === null) {
                    localStorage.setItem('clock24HourFormat', 'true');
                }
            } else {
                clock24HourToggle.classList.remove('active');
            }
            
            clock24HourToggle.addEventListener('click', function() {
                this.classList.toggle('active');
                const is24Hour = this.classList.contains('active');
                localStorage.setItem('clock24HourFormat', is24Hour.toString());
                
                // Immediately update the clock display
                const clockElement = document.getElementById('clock-time');
                if (clockElement) {
                    const now = new Date();
                    let hours = now.getHours();
                    const minutes = String(now.getMinutes()).padStart(2, '0');
                    
                    if (is24Hour) {
                        // 24-hour format: HH:MM
                        hours = String(hours).padStart(2, '0');
                        clockElement.textContent = `${hours}:${minutes}`;
                    } else {
                        // 12-hour format: H:MM AM/PM
                        const ampm = hours >= 12 ? 'PM' : 'AM';
                        hours = hours % 12;
                        hours = hours ? hours : 12; // Convert 0 to 12 for midnight/noon
                        clockElement.textContent = `${hours}:${minutes} ${ampm}`;
                    }
                }
            });
        }
        
        // Setup background options
        const desktop = document.querySelector('.desktop');
        let currentBackground = localStorage.getItem('desktopBackground') || 'default';
        
        // Get custom backgrounds from localStorage
        // Note: Uses globalImageCache for blob URL caching (defined at top level)
        
        function getCustomBackgrounds() {
            const stored = localStorage.getItem('customBackgrounds');
            return stored ? JSON.parse(stored) : [];
        }
        
        // Save custom backgrounds to localStorage
        function saveCustomBackgrounds(backgrounds) {
            localStorage.setItem('customBackgrounds', JSON.stringify(backgrounds));
        }
        
        // Get or create blob URL for a custom background path (with caching)
        // Uses global image cache for consistency
        async function getCachedBlobUrl(imagePath) {
            return await getImageUrlFromFilesystem(imagePath);
        }
        
        // Render custom backgrounds
        async function renderCustomBackgrounds() {
            const backgroundOptionsContainer = window.querySelector('.background-options');
            if (!backgroundOptionsContainer) {
                console.warn('Background options container not found');
                return;
            }
            
            const customBackgrounds = getCustomBackgrounds();
            const existingCustom = backgroundOptionsContainer.querySelectorAll('.background-option[data-bg^="custom-"]');
            existingCustom.forEach(el => el.remove());
            
            for (const bg of customBackgrounds) {
                const option = document.createElement('div');
                option.className = 'background-option';
                option.dataset.bg = `custom-${bg.path}`;
                option.dataset.customPath = bg.path;
                option.style.cssText = 'cursor: pointer; padding: 10px; border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 6px; background-size: cover; background-position: center; background-repeat: no-repeat; position: relative; overflow: visible; width: 100px; height: 100px;';
                
                // Load image preview using cached blob URL
                const imageUrl = await getCachedBlobUrl(bg.path);
                if (imageUrl) {
                    option.style.backgroundImage = `url("${imageUrl}")`;
                    // Store the blob URL on the element for reference
                    option.dataset.blobUrl = imageUrl;
                }
                
                // Add delete button (shown on hover) - store path in data attribute for later reference
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'background-delete-btn';
                deleteBtn.dataset.deletePath = bg.path;
                deleteBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
                deleteBtn.style.cssText = 'position: absolute; top: 4px; right: 4px; width: 24px; height: 24px; background: rgba(220, 53, 69, 0.9); border: none; border-radius: 4px; color: white; cursor: pointer; display: none; align-items: center; justify-content: center; padding: 0; z-index: 10; transition: all 0.2s;';
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const pathToDelete = e.currentTarget.dataset.deletePath;
                    const confirmed = await showConfirmationDialog(`Are you sure you want to delete this background?`, 'Delete Background');
                    if (confirmed) {
                        const customBackgrounds = getCustomBackgrounds();
                        const updated = customBackgrounds.filter(b => b.path !== pathToDelete);
                        saveCustomBackgrounds(updated);
                        
                        // If this was the active background, reset to default
                        if (currentBackground === `custom-${pathToDelete}`) {
                            currentBackground = 'default';
                            localStorage.setItem('desktopBackground', 'default');
                            localStorage.removeItem('customBackgroundPath');
                            applyBackground('default', null);
                        }
                        
                        await renderCustomBackgrounds();
                        updateBackgroundSelection();
                    }
                });
                option.appendChild(deleteBtn);
                
                // Show delete button on hover
                option.addEventListener('mouseenter', () => {
                    deleteBtn.style.display = 'flex';
                });
                option.addEventListener('mouseleave', () => {
                    deleteBtn.style.display = 'none';
                });
                
                // Add tooltip (without file extension)
                const tooltip = document.createElement('div');
                tooltip.className = 'background-option-tooltip tooltip';
                let tooltipText = bg.name || bg.path.split('/').pop();
                // Remove file extension
                if (tooltipText.includes('.')) {
                    tooltipText = tooltipText.substring(0, tooltipText.lastIndexOf('.'));
                }
                tooltip.textContent = tooltipText;
                option.appendChild(tooltip);
                
                backgroundOptionsContainer.appendChild(option);
            }
            
            // Re-setup all background options after rendering custom ones
            await setupBackgroundOptions();
        }
        
        // Setup all background options (preset + custom)
        async function setupBackgroundOptions() {
            const backgroundOptions = window.querySelectorAll('.background-option');
            
            // Ensure all borders are white initially
            backgroundOptions.forEach(opt => {
                opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            });
            
            for (const option of backgroundOptions) {
                // Remove existing click handlers to avoid duplicates
                const newOption = option.cloneNode(true);
                option.parentNode.replaceChild(newOption, option);
                
                // Re-attach hover listeners for delete button on custom backgrounds
                if (newOption.dataset.bg && newOption.dataset.bg.startsWith('custom-')) {
                    // Re-load image preview using cached blob URL
                    const customPath = newOption.dataset.customPath || newOption.dataset.bg.replace('custom-', '');
                    if (customPath) {
                        const imageUrl = await getCachedBlobUrl(customPath);
                        if (imageUrl) {
                            newOption.style.backgroundImage = `url("${imageUrl}")`;
                            // Store the blob URL on the element for reference
                            newOption.dataset.blobUrl = imageUrl;
                        }
                    }
                    
                    const deleteBtn = newOption.querySelector('.background-delete-btn');
                    if (deleteBtn) {
                        // Re-attach delete button click handler using data attribute
                        const pathToDelete = deleteBtn.dataset.deletePath;
                        if (pathToDelete) {
                            // Remove old handler and add new one
                            const newDeleteBtn = deleteBtn.cloneNode(true);
                            deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
                            newDeleteBtn.addEventListener('click', async (e) => {
                                e.stopPropagation();
                                const confirmed = await showConfirmationDialog(`Are you sure you want to delete this background?`, 'Delete Background');
                                if (confirmed) {
                                    const customBackgrounds = getCustomBackgrounds();
                                    const updated = customBackgrounds.filter(b => b.path !== pathToDelete);
                                    saveCustomBackgrounds(updated);
                                    
                                    // If this was the active background, reset to default
                                    if (currentBackground === `custom-${pathToDelete}`) {
                                        currentBackground = 'default';
                                        localStorage.setItem('desktopBackground', 'default');
                                        localStorage.removeItem('customBackgroundPath');
                                        applyBackground('default', null);
                                    }
                                    
                                    await renderCustomBackgrounds();
                                    updateBackgroundSelection();
                                }
                            });
                        }
                        
                        newOption.addEventListener('mouseenter', () => {
                            const btn = newOption.querySelector('.background-delete-btn');
                            if (btn) btn.style.display = 'flex';
                        });
                        newOption.addEventListener('mouseleave', () => {
                            const btn = newOption.querySelector('.background-delete-btn');
                            if (btn) btn.style.display = 'none';
                        });
                    }
                }
                
            // Setup click handler
                newOption.addEventListener('click', async function(e) {
                    // Don't trigger if clicking delete button
                    if (e.target.closest('.background-delete-btn')) return;
                    
                const bgType = this.dataset.bg;
                    const customPath = this.dataset.customPath;
                
                    // Remove eyeball icons from all options
                    const allOptions = window.querySelectorAll('.background-option');
                    allOptions.forEach(opt => {
                    opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                        const existingEye = opt.querySelector('.background-active-indicator');
                        if (existingEye) {
                            existingEye.remove();
                        }
                    });
                    
                    // Add eyeball icon to selected option
                    let eyeIcon = this.querySelector('.background-active-indicator');
                    if (!eyeIcon) {
                        eyeIcon = document.createElement('div');
                        eyeIcon.className = 'background-active-indicator';
                        eyeIcon.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>';
                        eyeIcon.style.cssText = 'position: absolute; top: 4px; left: 4px; width: 24px; height: 24px; background: rgba(25, 25, 35, 0.9); border-radius: 4px; color: rgba(255, 255, 255, 0.9); display: flex; align-items: center; justify-content: center; padding: 0; z-index: 10;';
                        this.appendChild(eyeIcon);
                    }
                currentBackground = bgType;
                
                // Save background selection to localStorage
                localStorage.setItem('desktopBackground', bgType);
                    if (customPath) {
                        localStorage.setItem('customBackgroundPath', customPath);
                    } else if (!bgType.startsWith('custom-')) {
                        localStorage.removeItem('customBackgroundPath');
                    }
                
                // Apply background
                    applyBackground(bgType, customPath);
                    
                    // Update selection highlighting
                    updateBackgroundSelection();
            });
            
            // Setup tooltip - find it fresh each time to ensure it exists
                const tooltip = newOption.querySelector('.background-option-tooltip');
            
            if (!tooltip) {
                return;
            }
            
            // Ensure tooltip text always matches the image filename (minus extension).
            // - Presets: derive from background-image URL in inline styles.
            // - Custom backgrounds: derive from the stored filesystem path (dataset.customPath).
            try {
                let labelSource = '';
                const bgType = newOption.dataset.bg || '';
                if (bgType.startsWith('custom-')) {
                    labelSource = newOption.dataset.customPath || bgType.slice('custom-'.length);
                } else {
                    // Prefer backgroundImage; fall back to background shorthand.
                    const bgImg = newOption.style.backgroundImage || newOption.style.background || '';
                    const m = bgImg.match(/url\((['"]?)(.*?)\1\)/i);
                    labelSource = (m && m[2]) ? m[2] : '';
                }

                if (labelSource) {
                    const fileName = labelSource.split(/[\\/]/).pop() || labelSource;
                    const baseName = fileName.includes('.') ? fileName.slice(0, fileName.lastIndexOf('.')) : fileName;
                    if (baseName) tooltip.textContent = baseName;
                }
            } catch (e) {
                // Keep existing tooltip text as fallback.
            }

            // Hide the original tooltip element (we'll create a new one dynamically)
            tooltip.style.display = 'none';
            
            // Store tooltip text for later use
            const tooltipText = tooltip.textContent;
            
            // Create closure to capture references
            (function(opt, tip, text) {
                let tooltipElement = null;
                
                function createTooltip() {
                    // Create tooltip element and append to body
                    tooltipElement = document.createElement('div');
                    tooltipElement.className = 'background-option-tooltip tooltip';
                    tooltipElement.textContent = text;
                    tooltipElement.style.position = 'fixed';
                    tooltipElement.style.opacity = '0';
                    tooltipElement.style.visibility = 'hidden';
                    tooltipElement.style.pointerEvents = 'none';
                    tooltipElement.style.zIndex = '10001';
                    document.body.appendChild(tooltipElement);
                }
                
                function updateTooltipPosition() {
                    if (!tooltipElement) return;
                    const rect = opt.getBoundingClientRect();
                    // Position tooltip below the button, centered horizontally
                    tooltipElement.style.top = (rect.bottom + 8) + 'px';
                    tooltipElement.style.left = (rect.left + rect.width / 2) + 'px';
                    tooltipElement.style.transform = 'translateX(-50%)';
                }
                
                function showTooltip() {
                    if (!tooltipElement) {
                        createTooltip();
                    }
                    updateTooltipPosition();
                    tooltipElement.style.opacity = '1';
                    tooltipElement.style.visibility = 'visible';
                }
                
                function hideTooltip() {
                    if (tooltipElement) {
                        tooltipElement.style.opacity = '0';
                        tooltipElement.style.visibility = 'hidden';
                    }
                }
                
                opt.addEventListener('mouseenter', function(e) {
                    // Update border color
                    if (this.style.borderColor !== 'rgb(93, 173, 226)') {
                        this.style.borderColor = 'rgba(255, 255, 255, 0.4)';
                    }
                    // Show tooltip
                    showTooltip();
                });
                
                opt.addEventListener('mousemove', function(e) {
                    // Update tooltip position as mouse moves
                    if (tooltipElement && tooltipElement.style.visibility === 'visible') {
                        updateTooltipPosition();
                    }
                });
                
                opt.addEventListener('mouseleave', function(e) {
                    // Update border color
                    if (this.style.borderColor !== 'rgb(93, 173, 226)') {
                        this.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    }
                    // Hide tooltip
                    hideTooltip();
                });
                })(newOption, tooltip, tooltipText);
            }
            
            // Update selection highlighting after setting up all options
            updateBackgroundSelection();
        }
        
        // Helper function to apply background
        async function applyBackground(bgType, customPath) {
            if (!desktop) return;
            
            if (bgType.startsWith('custom-') && customPath) {
                const imageUrl = await getImageUrlFromFilesystem(customPath);
                if (imageUrl) {
                    desktop.style.backgroundImage = `url("${imageUrl}")`;
                    desktop.style.background = `url("${imageUrl}"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)`;
                    desktop.style.backgroundSize = 'cover';
                    desktop.style.backgroundPosition = 'center';
                    desktop.style.backgroundRepeat = 'no-repeat';
                    desktop.style.animation = 'none';
                }
            } else {
                switch(bgType) {
                    case 'default':
                        desktop.style.backgroundImage = 'url("../assets/images/Peak.jpg")';
                        desktop.style.background = 'url("../assets/images/Peak.jpg"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)';
                        desktop.style.backgroundSize = 'cover';
                        desktop.style.backgroundPosition = 'center';
                        desktop.style.backgroundRepeat = 'no-repeat';
                        desktop.style.animation = 'none';
                        break;
                    case 'dark-blue':
                        desktop.style.backgroundImage = 'url("../assets/images/Mountain.jpg")';
                        desktop.style.background = 'url("../assets/images/Mountain.jpg"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)';
                        desktop.style.backgroundSize = 'cover';
                        desktop.style.backgroundPosition = 'center';
                        desktop.style.backgroundRepeat = 'no-repeat';
                        desktop.style.animation = 'none';
                        break;
                    case 'mountain':
                        desktop.style.backgroundImage = 'url("../assets/images/Mountain.jpg")';
                        desktop.style.background = 'url("../assets/images/Mountain.jpg"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)';
                        desktop.style.backgroundSize = 'cover';
                        desktop.style.backgroundPosition = 'center';
                        desktop.style.backgroundRepeat = 'no-repeat';
                        desktop.style.animation = 'none';
                        break;
                }
            }
        }
        
        // Update background selection highlighting - add/remove eyeball icon
        function updateBackgroundSelection() {
            // Read current background from localStorage to ensure we have the latest value
            const savedBg = localStorage.getItem('desktopBackground') || 'default';
            currentBackground = savedBg;
            
            const allOptions = window.querySelectorAll('.background-option');
            
            // Remove eyeball icon from all options and ensure borders are white
            allOptions.forEach(opt => {
                opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                const existingEye = opt.querySelector('.background-active-indicator');
                if (existingEye) {
                    existingEye.remove();
                }
            });
            
            // Add eyeball icon to selected option
            const savedOption = window.querySelector(`.background-option[data-bg="${currentBackground}"]`);
            if (savedOption) {
                // Check if eyeball icon already exists
                let eyeIcon = savedOption.querySelector('.background-active-indicator');
                if (!eyeIcon) {
                    eyeIcon = document.createElement('div');
                    eyeIcon.className = 'background-active-indicator';
                    eyeIcon.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>';
                    eyeIcon.style.cssText = 'position: absolute; top: 4px; left: 4px; width: 24px; height: 24px; background: rgba(25, 25, 35, 0.9); border-radius: 4px; color: rgba(255, 255, 255, 0.9); display: flex; align-items: center; justify-content: center; padding: 0; z-index: 10;';
                    savedOption.appendChild(eyeIcon);
                }
            } else {
                // Fallback to default if saved option doesn't exist
                const defaultOption = window.querySelector('.background-option[data-bg="default"]');
                if (defaultOption) {
                    let eyeIcon = defaultOption.querySelector('.background-active-indicator');
                    if (!eyeIcon) {
                        eyeIcon = document.createElement('div');
                        eyeIcon.className = 'background-active-indicator';
                        eyeIcon.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>';
                        eyeIcon.style.cssText = 'position: absolute; top: 4px; left: 4px; width: 24px; height: 24px; background: rgba(25, 25, 35, 0.9); border-radius: 4px; color: rgba(255, 255, 255, 0.9); display: flex; align-items: center; justify-content: center; padding: 0; z-index: 10;';
                        defaultOption.appendChild(eyeIcon);
                    }
                    currentBackground = 'default';
                    localStorage.setItem('desktopBackground', 'default');
                }
            }
        }
        
        // Setup "Add Background" button
        const addBackgroundBtn = window.querySelector('#add-background-btn');
        if (addBackgroundBtn) {
            // Setup tooltip for Add Background button
            setupNavButtonTooltip(addBackgroundBtn, 'Add Background');
            
            addBackgroundBtn.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(93, 173, 226, 0.3)';
            });
            addBackgroundBtn.addEventListener('mouseleave', function() {
                this.style.background = 'rgba(93, 173, 226, 0.2)';
            });
            addBackgroundBtn.addEventListener('click', async function() {
                // Show file browser dialog to select image from virtual filesystem
                const selectedPath = await showImageFilePicker();
                if (!selectedPath) return;
                
                try {
                    // Add to custom backgrounds
                    const customBackgrounds = getCustomBackgrounds();
                    const fileName = selectedPath.split('/').pop();
                    const exists = customBackgrounds.some(bg => bg.path === selectedPath);
                    
                    if (!exists) {
                        const newBg = {
                            path: selectedPath,
                            name: fileName
                        };
                        customBackgrounds.push(newBg);
                        saveCustomBackgrounds(customBackgrounds);
                    }
                    
                    // Render custom backgrounds and update selection
                    await renderCustomBackgrounds();
                    updateBackgroundSelection();
                    
                    // Optionally set as active background
                    const setAsActive = confirm('Background added. Would you like to set it as your desktop background?');
                    if (setAsActive) {
                        currentBackground = `custom-${selectedPath}`;
                        localStorage.setItem('desktopBackground', currentBackground);
                        localStorage.setItem('customBackgroundPath', selectedPath);
                        await applyBackground(currentBackground, selectedPath);
                        // Re-render to ensure the new background option exists, then update selection
                        await renderCustomBackgrounds();
                        updateBackgroundSelection();
                    }
                } catch (error) {
                    alert('Error adding background: ' + error.message);
                    console.error('Error adding background:', error);
                }
            });
        }
        
        // Listen for refresh events (when background is added from context menu)
        window.addEventListener('refreshBackgrounds', async () => {
            await renderCustomBackgrounds();
            updateBackgroundSelection();
        });
        
        // Initialize: render custom backgrounds and setup options
        // Ensure this runs after window is in DOM and container exists
        const initCustomBackgrounds = async () => {
            const backgroundOptionsContainer = window.querySelector('.background-options');
            if (backgroundOptionsContainer) {
                await renderCustomBackgrounds();
                updateBackgroundSelection();
            } else {
                // Retry if container not found yet (window might not be fully initialized)
                setTimeout(initCustomBackgrounds, 50);
            }
        };
        // Start initialization after a short delay to ensure DOM is ready
        setTimeout(initCustomBackgrounds, 100);
        
        
        // Initialize Sound settings
        const soundVolumeSlider = window.querySelector('#sound-volume-slider');
        const soundVolumeValue = window.querySelector('#sound-volume-value');
        if (soundVolumeSlider && soundVolumeValue) {
            const savedVolume = localStorage.getItem('soundVolume') || soundVolumeSlider.value;
            soundVolumeSlider.value = savedVolume;
            soundVolumeValue.textContent = savedVolume + '%';
            soundVolumeSlider.addEventListener('input', function() {
                const value = this.value;
                soundVolumeValue.textContent = value + '%';
                localStorage.setItem('soundVolume', value);
            });
        }
        
        const soundInputVolumeSlider = window.querySelector('#sound-input-volume-slider');
        const soundInputVolumeValue = window.querySelector('#sound-input-volume-value');
        if (soundInputVolumeSlider && soundInputVolumeValue) {
            soundInputVolumeSlider.addEventListener('input', function() {
                const value = this.value;
                soundInputVolumeValue.textContent = value + '%';
            });
        }
        
        // Initialize Notification settings
        const notificationsDurationSlider = window.querySelector('#notifications-duration-slider');
        const notificationsDurationValue = window.querySelector('#notifications-duration-value');
        if (notificationsDurationSlider && notificationsDurationValue) {
            notificationsDurationSlider.addEventListener('input', function() {
                const value = this.value;
                notificationsDurationValue.textContent = value + ' seconds';
            });
        }
        
        // Initialize Accessibility settings
        const accessibilityTextSizeSlider = window.querySelector('#accessibility-text-size-slider');
        const accessibilityTextSizeValue = window.querySelector('#accessibility-text-size-value');
        if (accessibilityTextSizeSlider && accessibilityTextSizeValue) {
            accessibilityTextSizeSlider.addEventListener('input', function() {
                const value = this.value;
                accessibilityTextSizeValue.textContent = value + 'px';
            });
        }
        
        const accessibilityRepeatDelaySlider = window.querySelector('#accessibility-repeat-delay-slider');
        const accessibilityRepeatDelayValue = window.querySelector('#accessibility-repeat-delay-value');
        if (accessibilityRepeatDelaySlider && accessibilityRepeatDelayValue) {
            accessibilityRepeatDelaySlider.addEventListener('input', function() {
                const value = this.value;
                accessibilityRepeatDelayValue.textContent = value + 'ms';
            });
        }
        
        const accessibilityDoubleClickSlider = window.querySelector('#accessibility-double-click-slider');
        const accessibilityDoubleClickValue = window.querySelector('#accessibility-double-click-value');
        if (accessibilityDoubleClickSlider && accessibilityDoubleClickValue) {
            accessibilityDoubleClickSlider.addEventListener('input', function() {
                const value = this.value;
                accessibilityDoubleClickValue.textContent = value + 'ms';
            });
        }
        
        // Initialize Power settings - Battery status
        const powerBatteryStatus = window.querySelector('#power-battery-status');
        if (powerBatteryStatus && 'getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                const updateBatteryStatus = () => {
                    const percentage = Math.round(battery.level * 100);
                    const charging = battery.charging ? ' (Charging)' : '';
                    powerBatteryStatus.textContent = `${percentage}%${charging}`;
                };
                updateBatteryStatus();
                battery.addEventListener('chargingchange', updateBatteryStatus);
                battery.addEventListener('levelchange', updateBatteryStatus);
            }).catch(() => {
                powerBatteryStatus.textContent = 'Not Available';
            });
        }
        
        // Initialize OS name and version in sidebar footer
        const osNameElement = window.querySelector('#settings-os-name');
        const osVersionElement = window.querySelector('#settings-os-version');
        if (osNameElement) {
            osNameElement.textContent = 'PilkOS';
        }
        if (osVersionElement) {
            // Try to get version from localStorage
            const versionData = localStorage.getItem('appVersion');
            if (versionData) {
                try {
                    const version = JSON.parse(versionData);
                    if (version.major !== undefined && version.minor !== undefined && version.patch !== undefined) {
                        osVersionElement.textContent = `v${version.major}.${version.minor}.${version.patch}`;
                    } else {
                        osVersionElement.textContent = 'v0.1.3';
                    }
                } catch (e) {
                    osVersionElement.textContent = 'v0.1.3';
                }
            } else {
                osVersionElement.textContent = 'v0.1.3';
            }
        }
    }
    
    // Restore all windows on page load if they were open before (only once)
    if (!settingsInitialized) {
        settingsInitialized = true;
        const savedWindowsState = getSavedSettingsWindowsState();
        if (savedWindowsState && savedWindowsState.length > 0) {
            // Restore all saved windows
            savedWindowsState.forEach(state => {
                createSettingsWindow(state);
            });
        }
    }
    
    // Return function to open Settings window (called from Start Menu)
    return createSettingsWindow;
}

// Virtual File System (IndexedDB)
class VirtualFileSystem {
    constructor() {
        this.dbName = 'PilkOS_FileSystem';
        this.dbVersion = 1;
        this.db = null;
        // Fixed filesystem size limit: 25 GB
        this.maxSize = 25 * 1024 * 1024 * 1024; // 25 GB in bytes
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // Files store: stores file metadata and content
                if (!db.objectStoreNames.contains('files')) {
                    const filesStore = db.createObjectStore('files', { keyPath: 'path' });
                    filesStore.createIndex('parent', 'parent', { unique: false });
                    filesStore.createIndex('type', 'type', { unique: false });
                }

                // Folders store: stores folder metadata
                if (!db.objectStoreNames.contains('folders')) {
                    const foldersStore = db.createObjectStore('folders', { keyPath: 'path' });
                    foldersStore.createIndex('parent', 'parent', { unique: false });
                }
            };
        });
    }

    // Normalize path (remove leading/trailing slashes, handle .. and .)
    normalizePath(path) {
        if (!path || path === '/') return '/';
        let parts = path.split('/').filter(p => p && p !== '.');
        let result = [];
        for (let part of parts) {
            if (part === '..') {
                if (result.length > 0) result.pop();
            } else {
                result.push(part);
            }
        }
        return '/' + result.join('/');
    }

    // Get parent path
    getParentPath(path) {
        const normalized = this.normalizePath(path);
        if (normalized === '/') return null;
        const parts = normalized.split('/').filter(p => p);
        parts.pop();
        return parts.length === 0 ? '/' : '/' + parts.join('/');
    }

    // Create a folder
    async createFolder(path, name) {
        const normalizedPath = this.normalizePath(path === '/' ? `/${name}` : `${path}/${name}`);
        const parent = this.getParentPath(normalizedPath);

        // Check if folder already exists
        const existing = await this.getFolder(normalizedPath);
        if (existing) {
            throw new Error('Folder already exists');
        }

        // Check if parent exists
        if (parent && parent !== '/') {
            const parentFolder = await this.getFolder(parent);
            if (!parentFolder) {
                throw new Error('Parent folder does not exist');
            }
        }

        const folder = {
            path: normalizedPath,
            name: name,
            parent: parent || null,
            created: Date.now(),
            modified: Date.now()
        };

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['folders'], 'readwrite');
            const store = transaction.objectStore('folders');
            const request = store.add(folder);

            request.onsuccess = () => {
                // Auto-refresh Files windows after folder creation
                setTimeout(() => {
                    refreshAllFilesWindows(normalizedPath).catch(err => console.warn('Error refreshing after folder creation:', err));
                }, 100);
                resolve(folder);
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Get a folder
    async getFolder(path) {
        const normalizedPath = this.normalizePath(path);
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['folders'], 'readonly');
            const store = transaction.objectStore('folders');
            const request = store.get(normalizedPath);

            request.onsuccess = () => resolve(request.result || null);
            request.onerror = () => reject(request.error);
        });
    }

    // List folders in a directory
    async listFolders(parentPath) {
        const normalized = this.normalizePath(parentPath || '/');
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['folders'], 'readonly');
            const store = transaction.objectStore('folders');
            const index = store.index('parent');
            const request = index.getAll(normalized);

            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
    }

    // Create or update a file
    async createFile(path, name, content = '', type = 'text') {
        const normalizedPath = this.normalizePath(path === '/' ? `/${name}` : `${path}/${name}`);
        const parent = this.getParentPath(normalizedPath);

        // Check if parent exists
        if (parent && parent !== '/') {
            const parentFolder = await this.getFolder(parent);
            if (!parentFolder) {
                throw new Error('Parent folder does not exist');
            }
        }

        // Convert content to ArrayBuffer if it's a Blob
        let contentData = content;
        let isBinary = false;
        let contentSize = 0;
        
        if (content instanceof Blob) {
            contentData = await content.arrayBuffer();
            isBinary = true;
            contentSize = contentData.byteLength;
        } else if (typeof content === 'string') {
            // Convert string to ArrayBuffer and calculate size
            const encoder = new TextEncoder();
            const encoded = encoder.encode(content);
            contentData = encoded.buffer;
            contentSize = encoded.byteLength; // Use the encoded array's byteLength, not the buffer's
        } else if (content instanceof ArrayBuffer) {
            contentData = content;
            contentSize = content.byteLength;
        } else if (content && typeof content === 'object' && content.byteLength !== undefined) {
            // Already an ArrayBuffer-like object
            contentData = content;
            contentSize = content.byteLength;
        } else {
            // Fallback: try to get size from contentData
            contentSize = contentData?.byteLength || contentData?.length || 0;
        }
        
        // Check if file already exists (for updates)
        const existingFile = await this.getFile(normalizedPath);
        const existingSize = existingFile ? (existingFile.size || 0) : 0;
        
        // Check if this would exceed the limit
        await this.checkSizeLimit(contentSize, existingSize);

        // Ensure contentSize is a valid number
        if (isNaN(contentSize) || contentSize < 0) {
            contentSize = 0;
        }

        const file = {
            path: normalizedPath,
            name: name,
            parent: parent || null,
            type: type,
            content: contentData,
            isBinary: isBinary,
            size: Number(contentSize), // Ensure it's a number
            created: existingFile ? existingFile.created : Date.now(),
            modified: Date.now()
        };
        
        // Debug log for file creation
        if (contentSize > 0) {
        }

        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            const request = store.put(file);

            request.onsuccess = () => {
                // Verify the file was stored with size
                const verifyRequest = store.get(normalizedPath);
                verifyRequest.onsuccess = () => {
                    const storedFile = verifyRequest.result;
                    if (storedFile) {
                        if (!storedFile.size || storedFile.size === 0) {
                            console.warn(`WARNING: File ${normalizedPath} was stored without size property!`);
                        }
                    }
                };
                // Auto-refresh Files windows after file creation/update
                setTimeout(() => {
                    refreshAllFilesWindows(normalizedPath).catch(err => console.warn('Error refreshing after file operation:', err));
                    // Also trigger filesystem size update for all Files windows
                    const fileExplorerWindows = Array.from(document.querySelectorAll('[data-file-explorer-window]'));
                    fileExplorerWindows.forEach(window => {
                        if (window.updateFsSize && typeof window.updateFsSize === 'function') {
                            window.updateFsSize().catch(() => {});
                        }
                    });
                }, 100);
                resolve(file);
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Get a file
    async getFile(path) {
        const normalizedPath = this.normalizePath(path);
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');
            const request = store.get(normalizedPath);

            request.onsuccess = () => resolve(request.result || null);
            request.onerror = () => reject(request.error);
        });
    }

    // Get file content as string
    async getFileContent(path) {
        const file = await this.getFile(path);
        if (!file) return null;

        if (file.isBinary) {
            // Return as Blob
            return new Blob([file.content]);
        } else {
            // Decode ArrayBuffer to string
            const decoder = new TextDecoder();
            return decoder.decode(file.content);
        }
    }

    // List files in a directory
    async listFiles(parentPath) {
        const normalized = this.normalizePath(parentPath || '/');
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');
            const index = store.index('parent');
            const request = index.getAll(normalized);

            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
    }

    // List all items (files and folders) in a directory
    async listDirectory(path) {
        const [files, folders] = await Promise.all([
            this.listFiles(path),
            this.listFolders(path)
        ]);

        return {
            files: files,
            folders: folders
        };
    }

    // Move file to trash
    async moveToTrash(path) {
        const normalizedPath = this.normalizePath(path);
        const file = await this.getFile(normalizedPath);
        if (!file) throw new Error('File not found');
        
        // Get user-specific Trash path (require logged-in user)
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (!loggedInUser) {
            throw new Error('User must be logged in to use Trash');
        }
        
        let trashPath;
        try {
            const user = JSON.parse(loggedInUser);
            trashPath = `/Users/${user.name}/Trash`;
        } catch (e) {
            throw new Error('Could not parse logged-in user');
        }
        
        // Ensure Trash folder exists
        let trashFolder = await this.getFolder(trashPath);
        if (!trashFolder) {
            const pathParts = trashPath.split('/').filter(p => p);
            const folderName = pathParts.pop();
            const parentPath = '/' + pathParts.join('/');
            await this.createFolder(parentPath, folderName);
        }
        
        // Generate unique name for trash
        let trashName = file.name;
        let counter = 1;
        while (true) {
            const testPath = `${trashPath}/${trashName}`;
            const exists = await this.getFile(testPath);
            if (!exists) break;
            const ext = file.name.includes('.') ? file.name.substring(file.name.lastIndexOf('.')) : '';
            const base = file.name.includes('.') ? file.name.substring(0, file.name.lastIndexOf('.')) : file.name;
            trashName = `${base} (${counter})${ext}`;
            counter++;
        }
        
        // Store original path in metadata
        file.originalPath = normalizedPath;
        file.originalParent = file.parent;
        file.deletedAt = Date.now();
        file.path = `${trashPath}/${trashName}`;
        file.parent = trashPath;
        file.name = trashName;
        
        // Delete from original location and add to trash
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            const deleteReq = store.delete(normalizedPath);
            
            deleteReq.onsuccess = () => {
                const addReq = store.add(file);
                addReq.onsuccess = () => resolve(file);
                addReq.onerror = () => reject(addReq.error);
            };
            deleteReq.onerror = () => reject(deleteReq.error);
        });
    }
    
    // Move folder to trash (recursively)
    async moveFolderToTrash(path) {
        const normalizedPath = this.normalizePath(path);
        
        // Prevent moving protected sidebar folders to trash
        if (isProtectedSidebarFolder(normalizedPath)) {
            throw new Error('Cannot delete this folder. Sidebar folders cannot be deleted.');
        }
        
        const folder = await this.getFolder(normalizedPath);
        if (!folder) throw new Error('Folder not found');
        
        // Get user-specific Trash path (require logged-in user)
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (!loggedInUser) {
            throw new Error('User must be logged in to use Trash');
        }
        
        let trashPath;
        try {
            const user = JSON.parse(loggedInUser);
            trashPath = `/Users/${user.name}/Trash`;
        } catch (e) {
            throw new Error('Could not parse logged-in user');
        }
        
        // Ensure Trash folder exists
        let trashFolder = await this.getFolder(trashPath);
        if (!trashFolder) {
            const pathParts = trashPath.split('/').filter(p => p);
            const folderName = pathParts.pop();
            const parentPath = '/' + pathParts.join('/');
            await this.createFolder(parentPath, folderName);
        }
        
        // Generate unique name for trash
        let trashName = folder.name;
        let counter = 1;
        while (true) {
            const testPath = `${trashPath}/${trashName}`;
            const exists = await this.getFolder(testPath);
            if (!exists) break;
            trashName = `${folder.name} (${counter})`;
            counter++;
        }
        
        // Store original path
        folder.originalPath = normalizedPath;
        folder.originalParent = folder.parent;
        folder.deletedAt = Date.now();
        const newPath = `${trashPath}/${trashName}`;
        folder.path = newPath;
        folder.parent = trashPath;
        folder.name = trashName;
        
        // Get all children
        const [subFolders, subFiles] = await Promise.all([
            this.listFolders(normalizedPath),
            this.listFiles(normalizedPath)
        ]);
        
        // Move all files
        for (const file of subFiles) {
            await this.moveToTrash(file.path);
        }
        
        // Move all subfolders recursively
        for (const subFolder of subFolders) {
            await this.moveFolderToTrash(subFolder.path);
        }
        
        // Update folder location
        const transaction = this.db.transaction(['folders'], 'readwrite');
        const store = transaction.objectStore('folders');
        await new Promise((resolve, reject) => {
            const deleteReq = store.delete(normalizedPath);
            deleteReq.onsuccess = () => {
                const addReq = store.add(folder);
                addReq.onsuccess = () => resolve();
                addReq.onerror = () => reject(addReq.error);
            };
            deleteReq.onerror = () => reject(deleteReq.error);
        });
        
        return folder;
    }
    
    // Permanently delete a file (from trash)
    async deleteFile(path) {
        const normalizedPath = this.normalizePath(path);
        const parentPath = this.getParentPath(normalizedPath);
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            const request = store.delete(normalizedPath);

            request.onsuccess = () => {
                // Auto-refresh Files windows after file deletion
                setTimeout(() => {
                    refreshAllFilesWindows(parentPath || '/').catch(err => console.warn('Error refreshing after file deletion:', err));
                }, 100);
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Delete a folder (and all its contents)
    async deleteFolder(path) {
        const normalizedPath = this.normalizePath(path);

        // Prevent deletion of protected sidebar folders
        if (isProtectedSidebarFolder(normalizedPath)) {
            throw new Error('Cannot delete this folder. Sidebar folders cannot be deleted.');
        }

        // Get all subfolders and files
        const [subFolders, subFiles] = await Promise.all([
            this.listFolders(normalizedPath),
            this.listFiles(normalizedPath)
        ]);

        // Recursively delete subfolders
        for (const folder of subFolders) {
            await this.deleteFolder(folder.path);
        }

        // Delete all files
        for (const file of subFiles) {
            await this.deleteFile(file.path);
        }

        // Delete the folder itself
        const parentPath = this.getParentPath(normalizedPath);
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['folders'], 'readwrite');
            const store = transaction.objectStore('folders');
            const request = store.delete(normalizedPath);

            request.onsuccess = () => {
                // Auto-refresh Files windows after folder deletion
                setTimeout(() => {
                    refreshAllFilesWindows(parentPath || '/').catch(err => console.warn('Error refreshing after folder deletion:', err));
                }, 100);
                resolve();
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Rename a file or folder
    async rename(path, newName) {
        const normalizedPath = this.normalizePath(path);
        const parent = this.getParentPath(normalizedPath);
        const newPath = this.normalizePath(parent === '/' ? `/${newName}` : `${parent}/${newName}`);

        // Check if new name already exists
        const file = await this.getFile(newPath);
        const folder = await this.getFolder(newPath);
        if (file || folder) {
            throw new Error('A file or folder with that name already exists');
        }

        // Try file first
        const existingFile = await this.getFile(normalizedPath);
        if (existingFile) {
            // Update file
            existingFile.name = newName;
            existingFile.path = newPath;
            existingFile.modified = Date.now();

            // Delete old and add new
            const transaction = this.db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            await new Promise((resolve, reject) => {
                const deleteReq = store.delete(normalizedPath);
                deleteReq.onsuccess = () => {
                    const addReq = store.add(existingFile);
                    addReq.onsuccess = () => {
                        // Wait for transaction to complete before resolving
                        transaction.oncomplete = () => {
                            // Auto-refresh Files windows after file rename
                            setTimeout(() => {
                                refreshAllFilesWindows(parent || '/').catch(err => console.warn('Error refreshing after file rename:', err));
                            }, 50);
                            resolve();
                        };
                        transaction.onerror = () => reject(transaction.error);
                    };
                    addReq.onerror = () => reject(addReq.error);
                };
                deleteReq.onerror = () => reject(deleteReq.error);
            });

            return existingFile;
        }

        // Try folder
        const existingFolder = await this.getFolder(normalizedPath);
        if (existingFolder) {
            // Update folder and all children
            existingFolder.name = newName;
            existingFolder.path = newPath;
            existingFolder.modified = Date.now();

            // Get all children
            const [subFolders, subFiles] = await Promise.all([
                this.listFolders(normalizedPath),
                this.listFiles(normalizedPath)
            ]);

            const transaction = this.db.transaction(['folders', 'files'], 'readwrite');
            const foldersStore = transaction.objectStore('folders');
            const filesStore = transaction.objectStore('files');

            // Delete old folder
            await new Promise((resolve, reject) => {
                const deleteReq = foldersStore.delete(normalizedPath);
                deleteReq.onsuccess = () => resolve();
                deleteReq.onerror = () => reject(deleteReq.error);
            });

            // Update all children paths
            for (const folder of subFolders) {
                folder.path = folder.path.replace(normalizedPath, newPath);
                folder.parent = folder.parent === normalizedPath ? newPath : folder.parent;
                await new Promise((resolve, reject) => {
                    const deleteReq = foldersStore.delete(normalizedPath + '/' + folder.name);
                    deleteReq.onsuccess = () => {
                        const addReq = foldersStore.add(folder);
                        addReq.onsuccess = () => resolve();
                        addReq.onerror = () => reject(addReq.error);
                    };
                    deleteReq.onerror = () => reject(deleteReq.error);
                });
            }

            for (const file of subFiles) {
                file.path = file.path.replace(normalizedPath, newPath);
                file.parent = file.parent === normalizedPath ? newPath : file.parent;
                await new Promise((resolve, reject) => {
                    const deleteReq = filesStore.delete(normalizedPath + '/' + file.name);
                    deleteReq.onsuccess = () => {
                        const addReq = filesStore.add(file);
                        addReq.onsuccess = () => resolve();
                        addReq.onerror = () => reject(addReq.error);
                    };
                    deleteReq.onerror = () => reject(deleteReq.error);
                });
            }

            // Add updated folder
            await new Promise((resolve, reject) => {
                const addReq = foldersStore.add(existingFolder);
                addReq.onsuccess = () => {
                    // Wait for transaction to complete before resolving
                    transaction.oncomplete = () => {
                        // Auto-refresh Files windows after folder rename
                        setTimeout(() => {
                            refreshAllFilesWindows(parent || '/').catch(err => console.warn('Error refreshing after folder rename:', err));
                        }, 50);
                        resolve();
                    };
                    transaction.onerror = () => reject(transaction.error);
                };
                addReq.onerror = () => reject(addReq.error);
            });

            return existingFolder;
        }

        throw new Error('File or folder not found');
    }
    
    // Move a file or folder to a new location
    async move(sourcePath, destinationPath, newName = null) {
        const normalizedSource = this.normalizePath(sourcePath);
        const normalizedDest = this.normalizePath(destinationPath);

        const mapConstraintError = (err) => {
            if (!err) return err;
            const name = err.name || '';
            const msg = (err.message || String(err) || '').toLowerCase();
            if (name === 'ConstraintError' || msg.includes('key already exists')) {
                return new Error('An item with that name already exists in the destination');
            }
            return err;
        };
        
        // Prevent moving protected sidebar folders
        if (isProtectedSidebarFolder(normalizedSource)) {
            throw new Error('Cannot move this folder. Sidebar folders cannot be moved.');
        }
        
        // Check if destination is a folder
        const destFolder = await this.getFolder(normalizedDest);
        if (!destFolder) {
            throw new Error('Destination must be a folder');
        }
        
        // Get source item
        const sourceFile = await this.getFile(normalizedSource);
        const sourceFolder = await this.getFolder(normalizedSource);
        
        if (!sourceFile && !sourceFolder) {
            throw new Error('Source file or folder not found');
        }
        
        // Prevent moving into itself or its children
        if (normalizedSource === normalizedDest || normalizedDest.startsWith(normalizedSource + '/')) {
            throw new Error('Cannot move a folder into itself or its children');
        }
        
        const originalName = sourceFile ? sourceFile.name : sourceFolder.name;
        const itemName = (newName && typeof newName === 'string' && newName.trim() !== '') ? newName.trim() : originalName;
        const newPath = normalizedDest === '/' ? `/${itemName}` : `${normalizedDest}/${itemName}`;
        
        // Check if item with same name already exists in destination
        const existingFile = await this.getFile(newPath);
        const existingFolder = await this.getFolder(newPath);
        if (existingFile || existingFolder) {
            throw new Error('An item with that name already exists in the destination');
        }
        
        if (sourceFile) {
            // Move file
            sourceFile.name = itemName;
            sourceFile.path = newPath;
            sourceFile.parent = normalizedDest;
            sourceFile.modified = Date.now();
            
            const transaction = this.db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            await new Promise((resolve, reject) => {
                const deleteReq = store.delete(normalizedSource);
                deleteReq.onsuccess = () => {
                    const addReq = store.add(sourceFile);
                    addReq.onsuccess = () => {
                        // Auto-refresh Files windows after file move
                        setTimeout(() => {
                            const sourceParent = normalizedSource.substring(0, normalizedSource.lastIndexOf('/')) || '/';
                            Promise.all([
                                refreshAllFilesWindows(sourceParent),
                                refreshAllFilesWindows(normalizedDest)
                            ]).catch(err => console.warn('Error refreshing after file move:', err));
                        }, 100);
                        resolve();
                    };
                    addReq.onerror = () => reject(mapConstraintError(addReq.error));
                };
                deleteReq.onerror = () => reject(deleteReq.error);
            });
            
            return sourceFile;
        } else {
            // Move folder (recursively update all children)
            sourceFolder.name = itemName;
            sourceFolder.path = newPath;
            sourceFolder.parent = normalizedDest;
            sourceFolder.modified = Date.now();
            
            // Get all children
            const [subFolders, subFiles] = await Promise.all([
                this.listFolders(normalizedSource),
                this.listFiles(normalizedSource)
            ]);
            
            const foldersTransaction = this.db.transaction(['folders'], 'readwrite');
            const foldersStore = foldersTransaction.objectStore('folders');
            const filesTransaction = this.db.transaction(['files'], 'readwrite');
            const filesStore = filesTransaction.objectStore('files');
            
            // Update all subfolders recursively
            for (const subFolder of subFolders) {
                const oldSubPath = subFolder.path;
                subFolder.path = subFolder.path.replace(normalizedSource, newPath);
                subFolder.parent = subFolder.parent === normalizedSource ? newPath : subFolder.parent.replace(normalizedSource, newPath);
                
                await new Promise((resolve, reject) => {
                    const deleteReq = foldersStore.delete(oldSubPath);
                    deleteReq.onsuccess = () => {
                        const addReq = foldersStore.add(subFolder);
                        addReq.onsuccess = () => resolve();
                        addReq.onerror = () => reject(mapConstraintError(addReq.error));
                    };
                    deleteReq.onerror = () => reject(deleteReq.error);
                });
            }
            
            // Update all files
            for (const file of subFiles) {
                const oldFilePath = file.path;
                file.path = file.path.replace(normalizedSource, newPath);
                file.parent = file.parent === normalizedSource ? newPath : file.parent.replace(normalizedSource, newPath);
                
                await new Promise((resolve, reject) => {
                    const deleteReq = filesStore.delete(oldFilePath);
                    deleteReq.onsuccess = () => {
                        const addReq = filesStore.add(file);
                        addReq.onsuccess = () => resolve();
                        addReq.onerror = () => reject(mapConstraintError(addReq.error));
                    };
                    deleteReq.onerror = () => reject(deleteReq.error);
                });
            }
            
            // Update folder itself
            await new Promise((resolve, reject) => {
                const deleteReq = foldersStore.delete(normalizedSource);
                deleteReq.onsuccess = () => {
                    const addReq = foldersStore.add(sourceFolder);
                    addReq.onsuccess = () => {
                        // Auto-refresh Files windows after folder move
                        setTimeout(() => {
                            const sourceParent = normalizedSource.substring(0, normalizedSource.lastIndexOf('/')) || '/';
                            Promise.all([
                                refreshAllFilesWindows(sourceParent),
                                refreshAllFilesWindows(normalizedDest)
                            ]).catch(err => console.warn('Error refreshing after folder move:', err));
                        }, 100);
                        resolve();
                    };
                    addReq.onerror = () => reject(mapConstraintError(addReq.error));
                };
                deleteReq.onerror = () => reject(deleteReq.error);
            });
            
            return sourceFolder;
        }
    }
    
    // Restore file from trash
    async restoreFile(path) {
        const file = await this.getFile(path);
        if (!file || !file.originalPath) throw new Error('File not in trash or missing original path');
        
        // Check if original location still exists
        const originalParent = file.originalParent;
        if (originalParent && originalParent !== '/') {
            const parentExists = await this.getFolder(originalParent);
            if (!parentExists) {
                throw new Error('Original location no longer exists');
            }
        }
        
        // Check if name conflict exists
        const testPath = originalParent === '/' ? `/${file.name}` : `${originalParent}/${file.name}`;
        const conflict = await this.getFile(testPath);
        if (conflict) {
            throw new Error('A file with that name already exists in the original location');
        }
        
        // Restore file
        file.path = file.originalPath;
        file.parent = file.originalParent;
        delete file.originalPath;
        delete file.originalParent;
        delete file.deletedAt;
        
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            const deleteReq = store.delete(path);
            
            deleteReq.onsuccess = () => {
                const addReq = store.add(file);
                addReq.onsuccess = () => resolve(file);
                addReq.onerror = () => reject(addReq.error);
            };
            deleteReq.onerror = () => reject(deleteReq.error);
        });
    }
    
    // Restore folder from trash (recursively)
    async restoreFolder(path) {
        const folder = await this.getFolder(path);
        if (!folder || !folder.originalPath) throw new Error('Folder not in trash or missing original path');
        
        // Check if original location still exists
        const originalParent = folder.originalParent;
        if (originalParent && originalParent !== '/') {
            const parentExists = await this.getFolder(originalParent);
            if (!parentExists) {
                throw new Error('Original location no longer exists');
            }
        }
        
        // Check if name conflict exists
        const testPath = originalParent === '/' ? `/${folder.name}` : `${originalParent}/${folder.name}`;
        const conflict = await this.getFolder(testPath);
        if (conflict) {
            throw new Error('A folder with that name already exists in the original location');
        }
        
        // Get all children
        const [subFolders, subFiles] = await Promise.all([
            this.listFolders(path),
            this.listFiles(path)
        ]);
        
        // Restore all files
        for (const file of subFiles) {
            await this.restoreFile(file.path);
        }
        
        // Restore all subfolders recursively
        for (const subFolder of subFolders) {
            await this.restoreFolder(subFolder.path);
        }
        
        // Restore folder itself
        folder.path = folder.originalPath;
        folder.parent = folder.originalParent;
        delete folder.originalPath;
        delete folder.originalParent;
        delete folder.deletedAt;
        
        const transaction = this.db.transaction(['folders'], 'readwrite');
        const store = transaction.objectStore('folders');
        await new Promise((resolve, reject) => {
            const deleteReq = store.delete(path);
            deleteReq.onsuccess = () => {
                const addReq = store.add(folder);
                addReq.onsuccess = () => resolve();
                addReq.onerror = () => reject(addReq.error);
            };
            deleteReq.onerror = () => reject(deleteReq.error);
        });
        
        return folder;
    }

    // Get total filesystem size
    async getTotalSize() {
        return new Promise((resolve, reject) => {
            if (!this.db) {
                console.warn('getTotalSize: Database not initialized');
                resolve(0);
                return;
            }
            
            const transaction = this.db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');
            const request = store.getAll();

            request.onsuccess = () => {
                const files = request.result || [];
                let totalSize = 0;
                let filesWithoutSize = 0;
                let filesWithZeroSize = 0;
                
                
                files.forEach(file => {
                    // Always try to calculate size from content first (most reliable)
                    let fileSize = 0;
                    let calculatedFromContent = false;
                    
                    // First, try to calculate from content
                    if (file.content) {
                        try {
                            // IndexedDB may store ArrayBuffer in different formats
                            if (file.content instanceof ArrayBuffer) {
                                fileSize = file.content.byteLength;
                                calculatedFromContent = true;
                            } else if (file.content.byteLength !== undefined) {
                                fileSize = file.content.byteLength;
                                calculatedFromContent = true;
                            } else if (file.content instanceof Uint8Array) {
                                fileSize = file.content.byteLength;
                                calculatedFromContent = true;
                            } else if (typeof file.content === 'string') {
                                fileSize = new TextEncoder().encode(file.content).byteLength;
                                calculatedFromContent = true;
                            } else if (Array.isArray(file.content)) {
                                // If content is an array, sum up the sizes
                                fileSize = file.content.reduce((sum, item) => {
                                    if (item instanceof ArrayBuffer) return sum + item.byteLength;
                                    if (item.byteLength !== undefined) return sum + item.byteLength;
                                    if (typeof item === 'string') return sum + new TextEncoder().encode(item).byteLength;
                                    return sum;
                                }, 0);
                                calculatedFromContent = true;
                            } else {
                                // Try Blob as last resort
                                try {
                                    const blob = new Blob([file.content]);
                                    fileSize = blob.size;
                                    calculatedFromContent = true;
                                } catch (e) {
                                    // Blob creation failed
                                }
                            }
                        } catch (e) {
                            console.warn('Error calculating content size for file:', file.path, e);
                        }
                    }
                    
                    // If we couldn't calculate from content, use stored size
                    if (!calculatedFromContent || fileSize === 0) {
                        if (file.size !== undefined && file.size !== null && !isNaN(file.size) && file.size > 0) {
                            fileSize = Number(file.size);
                        } else {
                            if (file.size === 0) {
                                filesWithZeroSize++;
                            } else {
                                filesWithoutSize++;
                            }
                            if (!file.content) {
                                console.warn(`File ${file.path} has no content and no valid size property`);
                            }
                        }
                    }
                    
                    // If we calculated from content and it differs from stored size, update it
                    if (calculatedFromContent && fileSize > 0) {
                        const storedSize = file.size || 0;
                        if (Math.abs(fileSize - storedSize) > 0) {
                            // Update the file with the calculated size (async, don't wait)
                            this.updateFileSize(file.path, fileSize).catch(() => {});
                        }
                    }
                    
                    totalSize += fileSize;
                });
                
                // Log for debugging
                
                // If we have files but totalSize is 0, log details about first few files
                if (files.length > 0 && totalSize === 0) {
                    console.warn('WARNING: Found files but total size is 0!');
                    files.slice(0, 5).forEach((file, idx) => {
                    });
                }
                
                resolve(totalSize);
            };
            request.onerror = () => {
                console.error('Error getting total size:', request.error);
                reject(request.error);
            };
        });
    }
    
    // Helper method to update file size if missing
    async updateFileSize(path, size) {
        try {
            const file = await this.getFile(path);
            if (file && (!file.size || file.size === 0)) {
                file.size = size;
                const transaction = this.db.transaction(['files'], 'readwrite');
                const store = transaction.objectStore('files');
                await new Promise((resolve, reject) => {
                    const request = store.put(file);
                    request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
            }
        } catch (e) {
            // Silently fail - this is just a background update
        }
    }
    
    // Check if an operation would exceed the size limit
    async checkSizeLimit(newFileSize = 0, existingFileSize = 0) {
        const currentSize = await this.getTotalSize();
        const sizeChange = newFileSize - existingFileSize;
        const newTotalSize = currentSize + sizeChange;
        
        if (newTotalSize > this.maxSize) {
            const available = Math.max(0, this.maxSize - currentSize);
            const formatSize = (bytes) => {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
            };
            throw new Error(`Filesystem is full. Available space: ${formatSize(available)}`);
        }
        return true;
    }
    
    // Helper to format size
    formatSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }
}

// Global file system instance
let fileSystem = null;

// Initialize file system
// Create user-specific folders
async function createUserFolders(username, fs = null) {
    try {
        // Use provided filesystem or get it (but avoid circular dependency)
        if (!fs) {
    if (!fileSystem) {
        fileSystem = new VirtualFileSystem();
        await fileSystem.init();
            }
            fs = fileSystem;
        }
        
        const userFolders = ['Desktop', 'Documents', 'Downloads', 'Music', 'Pictures', 'Trash', 'Videos'];
        const usersPath = '/Users';
        
        // Create /Users folder if it doesn't exist
        let usersFolder = await fs.getFolder(usersPath);
        if (!usersFolder) {
            await fs.createFolder('/', 'Users');
        }
        
        // Create user folder if it doesn't exist
        const userPath = `/Users/${username}`;
        let userFolder = await fs.getFolder(userPath);
        if (!userFolder) {
            await fs.createFolder('/Users', username);
        }
        
        // Create user-specific folders
        for (const folderName of userFolders) {
            try {
                const folderPath = `${userPath}/${folderName}`;
                const existing = await fs.getFolder(folderPath);
                if (!existing) {
                    await fs.createFolder(userPath, folderName);
                }
            } catch (e) {
            }
        }

        // Ensure /Users/<username>/Pictures/Screenshots exists
        try {
            const screenshotsPath = `${userPath}/Pictures/Screenshots`;
            const existingScreenshots = await fs.getFolder(screenshotsPath);
            if (!existingScreenshots) {
                await fs.createFolder(`${userPath}/Pictures`, 'Screenshots');
            }
        } catch (e) {
        }
    } catch (e) {
        console.error('Error creating user folders:', e);
    }
}

// Initialize user folders for all existing users
async function initializeAllUserFolders(fs) {
    try {
        const users = getUsers();
        for (const user of users) {
            await createUserFolders(user.name, fs);
        }
    } catch (e) {
        console.error('Error initializing user folders:', e);
    }
}

// Helper function to check if a path is a protected sidebar folder
function isProtectedSidebarFolder(path) {
    const normalizedPath = path.replace(/\/+/g, '/').replace(/\/$/, '') || '/';
    
    // Protected sidebar folders (including Desktop)
    const protectedFolders = ['Desktop', 'Documents', 'Downloads', 'Music', 'Pictures', 'Videos', 'Trash'];
    
    // Resolve username if available (some paths are user-scoped, others can be root-scoped fallback)
    let username = null;
    const loggedInUser = localStorage.getItem('loggedInUser');
    if (loggedInUser) {
        try {
            const user = JSON.parse(loggedInUser);
            username = user && user.name ? String(user.name) : null;
        } catch (e) {
            console.warn('Could not parse logged-in user:', e);
        }
    }

    // Fallback: if localStorage parsing fails, try reading the username from the sidebar label
    if (!username) {
        const nameEl = document.querySelector('#user-home-sidebar-name');
        const label = nameEl ? String(nameEl.textContent || '').trim() : '';
        if (label && label.toLowerCase() !== 'user') {
            username = label;
        }
    }

    // Check if path matches any protected folder in the current user's directory.
    for (const folderName of protectedFolders) {
        if (username) {
            const userScoped = `/Users/${username}/${folderName}`;
            if (normalizedPath === userScoped) return true;
        }
    }
    
    return false;
}

async function initFileSystem() {
    if (!fileSystem) {
        fileSystem = new VirtualFileSystem();
        await fileSystem.init();

        // Create Users folder structure for all users
        await initializeAllUserFolders(fileSystem);

        // Cleanup legacy root-level Pictures folder (older builds created /Pictures in root).
        // We now store screenshots under the logged-in user's Pictures (or /Temp Files when no user),
        // so /Pictures should not exist in root anymore.
        try {
            const legacyRootPictures = await fileSystem.getFolder('/Pictures');
            if (legacyRootPictures) {
                await fileSystem.deleteFolder('/Pictures');
            }
        } catch (e) {
            console.warn('Error cleaning up legacy root /Pictures folder:', e);
        }

        // Create Temp Files folder in root directory
        try {
            const tempFilesFolder = await fileSystem.getFolder('/Temp Files');
            if (!tempFilesFolder) {
                await fileSystem.createFolder('/', 'Temp Files');
            }
        } catch (e) {
            console.error('Error creating Temp Files folder:', e);
        }

        // Create System folder in root directory
        try {
            const systemFolder = await fileSystem.getFolder('/System');
            if (!systemFolder) {
                await fileSystem.createFolder('/', 'System');
            }
            
            // Create Backgrounds folder inside System folder
            const backgroundsFolder = await fileSystem.getFolder('/System/Backgrounds');
            if (!backgroundsFolder) {
                await fileSystem.createFolder('/System', 'Backgrounds');
            }
            
        } catch (e) {
            console.error('Error creating System folder:', e);
        }

        // README.txt file creation has been disabled - no default files will be created
        
        // Recalculate sizes for any files that might be missing size property
        try {
            const transaction = fileSystem.db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');
            const request = store.getAll();
            
            request.onsuccess = async () => {
                const files = request.result || [];
                let updatedCount = 0;
                for (const file of files) {
                    if (!file.size || file.size === 0) {
                        if (file.content) {
                            let contentSize = 0;
                            try {
                                if (file.content instanceof ArrayBuffer) {
                                    contentSize = file.content.byteLength;
                                } else if (file.content.byteLength !== undefined) {
                                    contentSize = file.content.byteLength;
                                } else if (file.content instanceof Uint8Array) {
                                    contentSize = file.content.byteLength;
                                } else if (typeof file.content === 'string') {
                                    contentSize = new TextEncoder().encode(file.content).byteLength;
                                } else {
                                    const blob = new Blob([file.content]);
                                    contentSize = blob.size;
                                }
                                
                                if (contentSize > 0) {
                                    file.size = contentSize;
                                    const writeTransaction = fileSystem.db.transaction(['files'], 'readwrite');
                                    const writeStore = writeTransaction.objectStore('files');
                                    await new Promise((resolve, reject) => {
                                        const putRequest = writeStore.put(file);
                                        putRequest.onsuccess = () => resolve();
                                        putRequest.onerror = () => reject(putRequest.error);
                                    });
                                    updatedCount++;
                                }
                            } catch (e) {
                                console.warn('Error updating size for file:', file.path, e);
                            }
                        }
                    }
                }
                if (updatedCount > 0) {
                    // Trigger size update in all Files windows
                    setTimeout(() => {
                        const fileExplorerWindows = Array.from(document.querySelectorAll('[data-file-explorer-window]'));
                        fileExplorerWindows.forEach(window => {
                            if (window.updateFsSize && typeof window.updateFsSize === 'function') {
                                window.updateFsSize().catch(() => {});
                            }
                        });
                    }, 200);
                }
            };
        } catch (e) {
            console.warn('Error recalculating file sizes:', e);
        }
        
        // Note: App shortcuts are created in initStartMenu() to ensure they match the actual Start Menu apps
    }
    return fileSystem;
}

// Get filesystem size utility function
async function getFileSystemSize() {
    try {
    const fs = await initFileSystem();
        // Ensure database is ready
        if (!fs || !fs.db) {
            // Wait a bit and try again
            await new Promise(resolve => setTimeout(resolve, 100));
            if (!fs || !fs.db) {
                return {
                    bytes: 0,
                    maxBytes: 25 * 1024 * 1024 * 1024,
                    formatted: '0 B',
                    percentage: 0
                };
            }
        }
    const totalSize = await fs.getTotalSize();
    const maxSize = fs.maxSize;
    
    const formatSize = (bytes) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i)) + ' ' + sizes[i];
    };
    
    return {
        bytes: totalSize,
        maxBytes: maxSize,
            formatted: formatSize(totalSize),
        percentage: Math.round((totalSize / maxSize) * 100)
    };
    } catch (error) {
        console.error('Error getting filesystem size:', error);
        return {
            bytes: 0,
            maxBytes: 25 * 1024 * 1024 * 1024,
            formatted: '0 B',
            percentage: 0
        };
    }
}

// Task Manager Window Functionality
// Global window count for Task Manager app
let taskManagerWindowCount = 0;
const TASK_MANAGER_OPEN_STORAGE_KEY = 'taskManagerOpen';
const TASK_MANAGER_WINDOW_STATE_KEY = 'taskManagerWindowState';

// Global helper: save Task Manager window geometry so it can be restored on refresh.
// (We keep the last known geometry even after closing, so the next open feels consistent.)
function saveTaskManagerWindowState() {
    try {
        const win = document.querySelector('.window[data-task-manager-window]');
        if (!win) return;
        const isMinimized = win.style.display === 'none';
        const state = {
            left: win.style.left || (win.offsetLeft + 'px'),
            top: win.style.top || (win.offsetTop + 'px'),
            width: win.style.width || (win.offsetWidth + 'px'),
            height: win.style.height || (win.offsetHeight + 'px'),
            minimized: isMinimized
        };
        localStorage.setItem(TASK_MANAGER_WINDOW_STATE_KEY, JSON.stringify(state));
    } catch (e) {
        // ignore storage errors
    }
}
window.saveTaskManagerWindowState = saveTaskManagerWindowState;

function initTaskManager() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');
    
    if (!windowsContainer || !dockApps) {
        setTimeout(() => {
            initTaskManager();
        }, 100);
        return;
    }
    
    function createTaskManagerWindow(options = {}) {
        const isRestore = !!(options && options.restore);
        // Prevent duplicate Task Manager windows (e.g. if restore/init runs twice on refresh)
        const existingTaskManagers = Array.from(document.querySelectorAll('.window[data-task-manager-window]'));
        if (existingTaskManagers.length > 0) {
            const existing = existingTaskManagers[existingTaskManagers.length - 1];
            // Un-minimize if needed
            if (existing.style.display === 'none') {
                existing.style.display = 'flex';
            }
            // Mark as open for future restores
            try {
                localStorage.setItem(TASK_MANAGER_OPEN_STORAGE_KEY, 'true');
            } catch (e) {
                // ignore storage errors
            }
            // Focus the existing window and return it
            try {
                focusWindow(existing);
            } catch (e) {
                // ignore focus errors
            }
            return existing;
        }

        const windowId = `task-manager-window-${taskManagerWindowCount++}`;
        const window = document.createElement('div');
        window.className = 'window';
        window.id = windowId;
        window.setAttribute('id', windowId);
        window.setAttribute('data-task-manager-window', 'true');
        
        // Persist "open" state (even if minimized later)
        try {
            localStorage.setItem(TASK_MANAGER_OPEN_STORAGE_KEY, 'true');
        } catch (e) {
            // ignore storage errors (private mode / quotas)
        }
        
        // Restore last known Task Manager window geometry (ONLY when restoring on refresh).
        // Fresh opens should default to centered like other apps.
        let restored = null;
        if (isRestore) {
            try {
                const saved = localStorage.getItem(TASK_MANAGER_WINDOW_STATE_KEY);
                if (saved) restored = JSON.parse(saved);
            } catch (e) {
                restored = null;
            }
        }
        
        const staggeredPos = calculateStaggeredPosition('task-manager', 200, 100);
        window.style.position = 'absolute';
        window.style.display = (restored && restored.minimized) ? 'none' : 'flex';
        window.style.left = (restored && restored.left) ? restored.left : (staggeredPos.left + 'px');
        window.style.top = (restored && restored.top) ? restored.top : (staggeredPos.top + 'px');
        // Match default app window size (e.g. Settings / Files)
        window.style.width = (restored && restored.width) ? restored.width : '900px';
        window.style.height = (restored && restored.height) ? restored.height : '650px';
        
        // Validate and fix window position
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 0);
        
        window.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="3" x2="9" y2="21"></line>
                        <line x1="3" y1="9" x2="21" y2="9"></line>
                    </svg>
                    Tasks
                </div>
                <div class="window-controls">
                    <div class="window-control minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content" style="display: flex; flex-direction: column; height: calc(100% - 40px); overflow: hidden;">
                <div style="padding: 16px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h3 style="margin: 0; color: rgba(255, 255, 255, 0.9); font-size: 14px; font-weight: 600;">System Information</h3>
                        <button id="task-manager-refresh-btn" class="nav-button" title="Refresh">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="task-manager-system-info" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                        <!-- System info will be populated here -->
                    </div>
                </div>
                <div style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                    <div style="padding: 12px 16px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                        <h3 style="margin: 0; color: rgba(255, 255, 255, 0.9); font-size: 14px; font-weight: 600;">Running Processes</h3>
                    </div>
                    <div style="flex: 1; overflow-y: auto; padding: 8px;">
                        <table id="task-manager-processes" style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                            <colgroup>
                                <col>
                                <col>
                                <col style="width: 88px;">
                            </colgroup>
                            <thead>
                                <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                                    <th style="text-align: left; padding: 8px; color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: 600;">Process Name</th>
                                    <th style="text-align: left; padding: 8px; color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: 600;">Status</th>
                                    <th style="width: 88px; text-align: center; padding: 8px; color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: 600;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="task-manager-processes-body">
                                <!-- Processes will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="window-resize-handle n"></div>
            <div class="window-resize-handle s"></div>
            <div class="window-resize-handle e"></div>
            <div class="window-resize-handle w"></div>
            <div class="window-resize-handle ne"></div>
            <div class="window-resize-handle nw"></div>
            <div class="window-resize-handle se"></div>
            <div class="window-resize-handle sw"></div>
        `;
        
        windowsContainer.appendChild(window);
        
        // Setup window controls
        const closeBtn = window.querySelector('.window-control.close');
        const minimizeBtn = window.querySelector('.window-control.minimize');
        const maximizeBtn = window.querySelector('.window-control.maximize');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const windowId = window.id;
                window.remove();
                if (windowId) {
                    removeWindowFromAppBar(windowId);
                }
            });
        }
        
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const wasMinimized = window.style.display === 'none';
                if (wasMinimized) {
                    window.style.display = 'flex';
                    focusWindow(window);
                } else {
                    window.style.display = 'none';
                    window.classList.remove('window-focused');
                }
                const nowMinimized = window.style.display === 'none';
                const isFocused = window.classList.contains('window-focused') && !nowMinimized;
                updateWindowAppBarState(window, isFocused, nowMinimized);
                saveTaskManagerWindowState();
            });
        }
        
        if (maximizeBtn) {
            let previousSize = null;
            let isMaximized = false;
            
            maximizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (isMaximized) {
                    // Restore to previous size
                    if (previousSize) {
                        window.style.width = previousSize.width;
                        window.style.height = previousSize.height;
                        window.style.left = previousSize.left;
                        window.style.top = previousSize.top;
                    } else {
                        // Fallback to defaults
                        window.style.width = '900px';
                        window.style.height = '650px';
                        window.style.left = '200px';
                        window.style.top = '100px';
                    }
                    isMaximized = false;
                } else {
                    // Save current position before maximizing
                    previousSize = {
                        width: window.style.width || window.offsetWidth + 'px',
                        height: window.style.height || window.offsetHeight + 'px',
                        left: window.style.left || window.offsetLeft + 'px',
                        top: window.style.top || window.offsetTop + 'px'
                    };
                    maximizeWindowToBounds(window);
                    isMaximized = true;
                }
                validateAndFixWindowPosition(window);
                saveTaskManagerWindowState();
            });
        }
        
        // Setup window interactions
        makeWindowDraggable(window, { onDragEnd: saveTaskManagerWindowState });
        makeWindowResizable(window, { minWidth: 600, minHeight: 400, onResize: saveTaskManagerWindowState });
        
        // Focus window after a small delay to ensure DOM is ready
        setTimeout(() => {
            if (window.style.display !== 'none') {
                focusWindow(window);
            }
            saveTaskManagerWindowState();
        }, 0);
        
        // Add to app bar
        const iconSvg = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="3" x2="9" y2="21"></line>
                <line x1="3" y1="9" x2="21" y2="9"></line>
            </svg>
        `;
        
        addWindowToAppBar(window, {
            appId: windowId,
            iconSvg: iconSvg,
            label: 'Tasks',
            onIconClick: () => {
                toggleWindowFromDock(window, saveTaskManagerWindowState);
            }
        });

        // Ensure the app bar reflects minimized/restored state after refresh
        updateWindowAppBarState(window, false, window.style.display === 'none');
        
        // Function to get all windows/processes
        function getAllProcesses() {
            const allWindows = Array.from(document.querySelectorAll('.window'));
            const processes = [];
            
            allWindows.forEach(win => {
                if (win.id === windowId) return; // Don't show Task Manager itself
                
                const titleElement = win.querySelector('.window-title');
                let processName = 'Unknown';
                if (titleElement) {
                    const titleClone = titleElement.cloneNode(true);
                    const svgElements = titleClone.querySelectorAll('svg');
                    svgElements.forEach(svg => svg.remove());
                    processName = titleClone.textContent.trim() || 'Unknown';
                }
                
                const isMinimized = win.style.display === 'none';
                const status = isMinimized ? 'Minimized' : 'Running';
                
                processes.push({
                    window: win,
                    name: processName,
                    status: status,
                    id: win.id,
                    isMinimized: isMinimized
                });
            });
            
            return processes;
        }
        
        // Function to get system information
        async function getSystemInfo() {
            const fs = await initFileSystem();
            const fsSize = await getFileSystemSize();
            
            // Get window count
            const allWindows = Array.from(document.querySelectorAll('.window'));
            const windowCount = allWindows.length;
            
            // Calculate "memory" usage (simulated based on open windows and file system)
            const memoryUsage = Math.min(100, (windowCount * 5) + (fsSize.percentage || 0) * 0.3);
            
            return {
                windows: windowCount,
                memory: Math.round(memoryUsage),
                storage: fsSize.percentage || 0,
                storageUsed: fsSize.formatted || '0 B',
                storageMax: '25 GB'
            };
        }
        
        // Function to update system info display
        async function updateSystemInfo() {
            const systemInfo = await getSystemInfo();
            const infoContainer = window.querySelector('#task-manager-system-info');
            
            infoContainer.innerHTML = `
                <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 6px;">
                    <div style="color: rgba(255, 255, 255, 0.6); font-size: 11px; margin-bottom: 4px;">Open Windows</div>
                    <div style="color: rgba(255, 255, 255, 0.9); font-size: 18px; font-weight: 600;">${systemInfo.windows}</div>
                </div>
                <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 6px;">
                    <div style="color: rgba(255, 255, 255, 0.6); font-size: 11px; margin-bottom: 4px;">Memory Usage</div>
                    <div style="color: rgba(255, 255, 255, 0.9); font-size: 18px; font-weight: 600;">${systemInfo.memory}%</div>
                    <div style="width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; margin-top: 6px; overflow: hidden;">
                        <div style="width: ${systemInfo.memory}%; height: 100%; background: #5dade2; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 6px;">
                    <div style="color: rgba(255, 255, 255, 0.6); font-size: 11px; margin-bottom: 4px;">Storage</div>
                    <div style="color: rgba(255, 255, 255, 0.9); font-size: 14px; font-weight: 600;">${systemInfo.storageUsed} / ${systemInfo.storageMax}</div>
                    <div style="width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; margin-top: 6px; overflow: hidden;">
                        <div style="width: ${systemInfo.storage}%; height: 100%; background: #5dade2; transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
        }
        
        // Function to update processes list
        function updateProcessesList() {
            const processes = getAllProcesses();
            const tbody = window.querySelector('#task-manager-processes-body');
            
            tbody.innerHTML = '';
            
            if (processes.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="3" style="text-align: center; padding: 24px; color: rgba(255, 255, 255, 0.5);">
                            No processes running
                        </td>
                    </tr>
                `;
                return;
            }
            
            processes.forEach(process => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid rgba(255, 255, 255, 0.05)';
                row.style.cursor = 'pointer';
                row.addEventListener('mouseenter', () => {
                    row.style.background = 'rgba(93, 173, 226, 0.1)';
                });
                row.addEventListener('mouseleave', () => {
                    row.style.background = 'transparent';
                });
                
                const statusColor = process.isMinimized ? 'rgba(255, 255, 255, 0.5)' : '#5dade2';
                
                row.innerHTML = `
                    <td style="padding: 10px 8px; color: rgba(255, 255, 255, 0.9); font-size: 13px;">
                        ${process.name}
                    </td>
                    <td style="padding: 10px 8px;">
                        <span style="color: ${statusColor}; font-size: 12px;">${process.status}</span>
                    </td>
                    <td style="width: 88px; min-width: 88px; max-width: 88px; padding: 8px; text-align: center;">
                        <button class="nav-button nav-button-danger end-process-btn" data-window-id="${process.id}" title="End Process">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                <octagon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></octagon>
                                <line x1="15" y1="9" x2="9" y2="15"></line>
                                <line x1="9" y1="9" x2="15" y2="15"></line>
                            </svg>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Add event listeners to end process buttons
            window.querySelectorAll('.end-process-btn').forEach(btn => {
                setupNavButtonTooltip(btn, 'End Process');
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const windowId = btn.dataset.windowId;
                    const targetWindow = document.getElementById(windowId);
                    
                    if (targetWindow) {
                        const titleElement = targetWindow.querySelector('.window-title');
                        let processName = 'Unknown';
                        if (titleElement) {
                            const titleClone = titleElement.cloneNode(true);
                            const svgElements = titleClone.querySelectorAll('svg');
                            svgElements.forEach(svg => svg.remove());
                            processName = titleClone.textContent.trim() || 'Unknown';
                        }
                        
                        const confirmed = await showConfirmationDialog(
                            `Are you sure you want to end the process "${processName}"?`,
                            'End Process',
                            window
                        );
                        
                        if (confirmed) {
                            // Remove from app bar if it exists
                            const appBarId = targetWindow.id || targetWindow.dataset.app;
                            if (appBarId) {
                                removeWindowFromAppBar(appBarId);
                            }
                            
                            // Remove window
                            targetWindow.remove();
                            
                            // Refresh the processes list
                            updateProcessesList();
                            updateSystemInfo();
                        }
                    }
                });
            });
        }
        
        // Function to refresh all data
        async function refreshData() {
            await updateSystemInfo();
            updateProcessesList();
        }
        
        // Initial refresh
        refreshData();
        
        // Refresh button
        const refreshBtn = window.querySelector('#task-manager-refresh-btn');
        if (refreshBtn) {
            setupNavButtonTooltip(refreshBtn, 'Refresh');
            refreshBtn.addEventListener('click', () => {
                refreshData();
            });
        }
        
        // Auto-refresh every 2 seconds
        let refreshInterval = setInterval(() => {
            if (window.style.display !== 'none' && document.body.contains(window)) {
                refreshData();
            }
        }, 2000);
        
        // Clean up interval when window is closed
        window.addEventListener('remove', () => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });
        
        // Also clean up on beforeunload
        const originalRemove = window.remove;
        window.remove = function() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
            if (originalRemove) {
                originalRemove.call(this);
            }
            // Persist "closed" state only if no Task Manager windows remain
            try {
                const anyRemaining = document.querySelector('[data-task-manager-window]') != null;
                localStorage.setItem(TASK_MANAGER_OPEN_STORAGE_KEY, anyRemaining ? 'true' : 'false');
            } catch (e) {
                // ignore storage errors
            }
        };
        
        return window;
    }
    
    return createTaskManagerWindow;
}

// File Explorer Window Functionality

// Global window count for Files app to persist across initFileExplorer calls
let fileExplorerWindowCount = 0;
// Track if File Explorer has been initialized to prevent multiple restorations
let fileExplorerInitialized = false;
// Global function to save Files windows state (accessible from beforeunload)
let globalSaveFileExplorerWindowsState = null;

// Global function to refresh all open Files app windows
// Unified refresh function that refreshes both Files windows and desktop icons
async function refreshFileSystemViews(affectedPath = null) {
    // Helper to get Desktop path
    function getDesktopPath() {
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                return `/Users/${user.name}/Desktop`;
            } catch (e) {
                return null;
            }
        }
        return null;
    }
    
    // Check if Desktop folder is affected
    const desktopPath = getDesktopPath();
    const isDesktopAffected = desktopPath && (
        affectedPath === desktopPath || 
        affectedPath?.startsWith(desktopPath + '/') ||
        !affectedPath // If no specific path, refresh desktop too
    );
    
    // Refresh desktop icons if Desktop folder is affected
    if (isDesktopAffected && window.refreshDesktopIcons && typeof window.refreshDesktopIcons === 'function') {
        try {
            await window.refreshDesktopIcons();
        } catch (error) {
            console.warn('Error refreshing desktop icons:', error);
        }
    }
    
    // Helper to get Trash path
    function getTrashPath() {
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                return `/Users/${user.name}/Trash`;
            } catch (e) {
                return null;
            }
        }
        return null;
    }
    
    // Refresh all Files app windows
    const fileExplorerWindows = Array.from(document.querySelectorAll('[data-file-explorer-window]'));
    const trashPath = getTrashPath();
    const isTrashAffected = trashPath && affectedPath === trashPath;
    
    for (const window of fileExplorerWindows) {
        // Check if window has a refresh function stored
        if (window.refreshCurrentView && typeof window.refreshCurrentView === 'function') {
            try {
                // If affectedPath is provided, only refresh if the window is viewing that path or its parent
                if (affectedPath) {
                    const tab = window.getActiveTab ? window.getActiveTab() : null;
                    if (tab && tab.currentPath) {
                        const currentPath = tab.currentPath;
                        const currentLocation = tab.currentLocation;
                        const parentPath = affectedPath.substring(0, affectedPath.lastIndexOf('/')) || '/';
                        
                        // Special case: if Trash is affected, refresh any window viewing Trash
                        let shouldRefresh = false;
                        if (isTrashAffected) {
                            // Refresh if viewing Trash (by path or location)
                            shouldRefresh = (currentPath === trashPath || currentLocation === 'trash');
                        }
                        
                        // Refresh if viewing the affected path, its parent, or root
                        if (!shouldRefresh) {
                            shouldRefresh = (currentPath === affectedPath || 
                                currentPath === parentPath || 
                                affectedPath.startsWith(currentPath + '/') ||
                                currentPath === '/');
                        }
                        
                        if (shouldRefresh) {
                            await window.refreshCurrentView();
                        }
                    } else {
                        // If no tab info, refresh anyway
                        await window.refreshCurrentView();
                    }
                } else {
                    // No specific path, refresh all windows
                    await window.refreshCurrentView();
                }
            } catch (error) {
                console.warn('Error refreshing Files window:', error);
            }
        }
    }
}

// Keep the old function name for backward compatibility
async function refreshAllFilesWindows(affectedPath = null) {
    await refreshFileSystemViews(affectedPath);
}

function initFileExplorer() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');
    
    if (!windowsContainer || !dockApps) {
        // If DOM isn't ready yet, try again after a short delay
        setTimeout(() => {
            initFileExplorer();
        }, 100);
        return;
    }
    
    let appBarIcon = null;
    let navigateToRootOnOpen = false;
    
    // Save all Files windows state (including tabs)
    function saveFileExplorerWindowsState() {
        const fileExplorerWindows = Array.from(document.querySelectorAll('[data-file-explorer-window]'));
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const minLeft = 0;
        
        const windowsState = fileExplorerWindows.map(window => {
            const isMinimized = window.style.display === 'none';
            // Get tabs state for this window (stored on the window object)
            const tabsState = window.fileExplorerTabsState || null;
            
            // Get current position and dimensions
            let left = parseInt(window.style.left) || window.offsetLeft || 200;
            let top = parseInt(window.style.top) || window.offsetTop || 100;
            let width = parseInt(window.style.width) || window.offsetWidth || 900;
            let height = parseInt(window.style.height) || window.offsetHeight || 650;
            
            // Sanitize values before saving - ensure they're valid
            // Ensure window doesn't extend beyond viewport
            const maxLeft = viewportWidth - width;
            if (left > maxLeft || left + width > viewportWidth) {
                left = Math.max(minLeft, maxLeft);
            }
            if (left < minLeft) {
                left = minLeft;
            }
            
            // Ensure width isn't too large
            if (width > viewportWidth - minLeft) {
                width = Math.max(600, viewportWidth - minLeft - 20);
            }
            
            return {
                windowId: window.id,
                left: left + 'px',
                top: top + 'px',
                width: width + 'px',
                height: height + 'px',
                minimized: isMinimized,
                tabsState: tabsState
            };
        });
        localStorage.setItem('fileExplorerWindowsState', JSON.stringify(windowsState));
    }
    
    // Make saveFileExplorerWindowsState accessible globally for beforeunload
    globalSaveFileExplorerWindowsState = saveFileExplorerWindowsState;
    
    // Get saved Files windows state
    function getSavedFileExplorerWindowsState() {
        const saved = localStorage.getItem('fileExplorerWindowsState');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                return [];
            }
        }
        return [];
    }
    
    function createFileExplorerWindow(initialPath = null, restoreState = null) {
        const windowId = restoreState ? restoreState.windowId : `file-explorer-window-${fileExplorerWindowCount++}`;
        const window = document.createElement('div');
        window.className = 'window';
        window.id = windowId;
        window.setAttribute('id', windowId); // Set both property and attribute
        window.setAttribute('data-file-explorer-window', 'true');

        // Restore minimized state early (before inserting into DOM) to avoid flicker on refresh.
        const isMinimized = !!(restoreState && restoreState.minimized);
        window.style.display = isMinimized ? 'none' : 'flex';
        
        // Use restore state if provided, otherwise use defaults
        if (restoreState) {
            // Sanitize saved position values before applying them
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const minLeft = 0;
            
            let savedLeft = parseInt(restoreState.left) || 250;
            let savedTop = parseInt(restoreState.top) || 100;
            let savedWidth = parseInt(restoreState.width) || 900;
            let savedHeight = parseInt(restoreState.height) || 650;
            
            // Validate saved width/height aren't too large
            if (savedWidth > viewportWidth - minLeft) {
                savedWidth = Math.max(600, viewportWidth - minLeft - 20);
            }
            if (savedHeight > (document.documentElement.clientHeight || window.innerHeight)) {
                savedHeight = Math.max(400, (document.documentElement.clientHeight || window.innerHeight) - 20);
            }
            
            // Validate saved position - if window would extend beyond viewport, adjust it
            const maxLeft = viewportWidth - savedWidth;
            if (savedLeft > maxLeft || savedLeft + savedWidth > viewportWidth) {
                savedLeft = Math.max(minLeft, maxLeft);
            }
            if (savedLeft < minLeft) {
                savedLeft = minLeft;
            }
            
            window.style.left = savedLeft + 'px';
            window.style.top = savedTop + 'px';
            window.style.width = savedWidth + 'px';
            window.style.height = savedHeight + 'px';
        } else {
            // Calculate staggered position for new windows
            const staggeredPos = calculateStaggeredPosition('files', 200, 100);
            window.style.left = staggeredPos.left + 'px';
            window.style.top = staggeredPos.top + 'px';
            window.style.width = '900px';
            window.style.height = '650px';
        }
        
        // Validate and fix window position to ensure it's fully visible
        // Run multiple times to ensure it works even if window dimensions aren't ready yet
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 0);
        
        // Run again after a longer delay to catch any cases where dimensions weren't ready
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 200);
        
        // Run one more time after window is fully rendered
        setTimeout(() => {
            validateAndFixWindowPosition(window);
        }, 500);
        
        // Final aggressive check - detect if controls are off-screen and force fix
        setTimeout(() => {
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const windowRight = parseInt(window.style.left) + (window.offsetWidth || parseInt(window.style.width));
            // If window extends beyond viewport, force it back
            if (windowRight > viewportWidth) {
                const minLeft = 0;
                const windowWidth = window.offsetWidth || parseInt(window.style.width) || 900;
                const maxLeft = viewportWidth - windowWidth;
                window.style.left = Math.max(minLeft, maxLeft) + 'px';
                // Save the corrected position
                if (saveFileExplorerWindowsState) {
                    saveFileExplorerWindowsState();
                }
            }
        }, 1000);
        
        window.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <path d="M14 2v6h6"></path>
                        <path d="M16 13H8"></path>
                        <path d="M16 17H8"></path>
                        <path d="M10 9H8"></path>
                    </svg>
                    Files
                </div>
                <div class="window-controls">
                    <div class="window-control minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content file-explorer-content">
                <div class="file-explorer-tabs">
                    <button class="file-explorer-tab-new" id="new-tab-button" title="New Tab">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <div class="file-explorer-tabs-list" id="tabs-list">
                        <!-- Tabs will be dynamically added here -->
                    </div>
                </div>
                <div class="file-explorer-toolbar">
                    <div class="file-explorer-nav-buttons">
                        <button class="nav-button" id="back-button" title="Back">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7"></path>
                            </svg>
                        </button>
                        <button class="nav-button" id="forward-button" title="Forward">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M5 12h14M12 5l7 7-7 7"></path>
                            </svg>
                        </button>
                        <button class="nav-button" id="refresh-button" title="Refresh">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                        </button>
                        <button class="nav-button" id="view-toggle-button" title="Toggle View">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" id="view-toggle-icon">
                                <rect x="3" y="3" width="7" height="7"></rect>
                                <rect x="14" y="3" width="7" height="7"></rect>
                                <rect x="14" y="14" width="7" height="7"></rect>
                                <rect x="3" y="14" width="7" height="7"></rect>
                            </svg>
                        </button>
                        <button class="nav-button" id="icon-size-toggle-button" title="Icon Size">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" id="icon-size-toggle-icon">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="9" y1="9" x2="15" y2="9"></line>
                                <line x1="9" y1="12" x2="15" y2="12"></line>
                                <line x1="9" y1="15" x2="15" y2="15"></line>
                                <line x1="9" y1="18" x2="15" y2="18"></line>
                            </svg>
                        </button>
                        <button class="nav-button" id="extension-toggle-button" title="Show/Hide File Extensions">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" id="extension-toggle-icon">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <div class="file-explorer-address-bar">
                        <span data-actual-path="C:">Local Disk (C:)</span>
                    </div>
                    <div class="file-explorer-search">
                        <button class="file-explorer-search-icon-btn" id="search-toggle-button" title="Search">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <path d="m21 21-4.35-4.35"></path>
                            </svg>
                        </button>
                        <input type="text" placeholder="" class="file-explorer-search-input" id="file-explorer-search-input">
                    </div>
                </div>
                <div class="file-explorer-body">
                    <div class="file-explorer-sidebar">
                        <div class="sidebar-section">
                            <div class="sidebar-item" data-location="user-home" id="user-home-sidebar-item">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                    <circle cx="12" cy="7" r="4"></circle>
                                </svg>
                                <span id="user-home-sidebar-name">User</span>
                            </div>
                            <div class="sidebar-item" data-location="desktop">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect>
                                    <line x1="8" y1="21" x2="16" y2="21"></line>
                                    <line x1="12" y1="17" x2="12" y2="21"></line>
                                </svg>
                                <span>Desktop</span>
                            </div>
                            <div class="sidebar-item" data-location="downloads">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                                <span>Downloads</span>
                            </div>
                            <div class="sidebar-item" data-location="documents">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                    <path d="M14 2v6h6"></path>
                                    <path d="M16 13H8"></path>
                                    <path d="M16 17H8"></path>
                                    <path d="M10 9H8"></path>
                                </svg>
                                <span>Documents</span>
                            </div>
                            <div class="sidebar-item" data-location="pictures">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                    <polyline points="21 15 16 10 5 21"></polyline>
                                </svg>
                                <span>Pictures</span>
                            </div>
                            <div class="sidebar-item" data-location="music">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 18V5l12-2v13"></path>
                                    <circle cx="6" cy="18" r="3"></circle>
                                    <circle cx="18" cy="16" r="3"></circle>
                                </svg>
                                <span>Music</span>
                            </div>
                            <div class="sidebar-item" data-location="videos">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polygon points="23 7 16 12 23 17 23 7"></polygon>
                                    <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                                </svg>
                                <span>Videos</span>
                            </div>
                            <div class="sidebar-item" data-location="trash" style="display: flex; align-items: center; justify-content: space-between; position: relative;">
                                <div style="display: flex; align-items: center; flex: 1; min-width: 0; gap: 12px;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    </svg>
                                    <span>Trash</span>
                                </div>
                                <button class="sidebar-empty-trash-btn" id="sidebar-empty-trash-btn" style="position: absolute; right: 16px; top: 50%; transform: translateY(-50%); width: 24px; height: 24px; border: none; background: transparent; color: rgba(255,255,255,0.6); cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; border-radius: 4px; opacity: 0; transition: opacity 0.2s, background 0.2s, color 0.2s;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    </svg>
                                </button>
                            </div>
                            <div class="sidebar-divider"></div>
                            <div class="sidebar-item active" data-location="disk-c">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <ellipse cx="12" cy="18" rx="8" ry="2.5"></ellipse>
                                    <ellipse cx="12" cy="12" rx="8" ry="2.5"></ellipse>
                                    <ellipse cx="12" cy="6" rx="8" ry="2.5"></ellipse>
                                    <line x1="4" y1="6" x2="4" y2="18"></line>
                                    <line x1="20" y1="6" x2="20" y2="18"></line>
                                </svg>
                                <span>Local Disk (C:)</span>
                                <span class="sidebar-item-meta sidebar-fs-size" data-fs-size></span>
                            </div>
                        </div>
                    </div>
                    <div class="file-explorer-main">
                        <div class="file-explorer-items">
                        </div>
                        <div class="file-explorer-size-display" id="file-explorer-size-display" style="display: none;">
                            <span id="file-explorer-file-count" class="file-count-text"></span>
                            <span id="file-explorer-size-text" class="size-text"></span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="window-resize-handle n"></div>
            <div class="window-resize-handle s"></div>
            <div class="window-resize-handle e"></div>
            <div class="window-resize-handle w"></div>
            <div class="window-resize-handle ne"></div>
            <div class="window-resize-handle nw"></div>
            <div class="window-resize-handle se"></div>
            <div class="window-resize-handle sw"></div>
        `;
        
        windowsContainer.appendChild(window);
        
        // Ensure window.id is set before adding to app bar (set both id property and attribute)
        // Double-check that window.id is set correctly - force set it again to be sure
        window.id = windowId;
        window.setAttribute('id', windowId);
        
        // Add to app bar (will add window to existing icon if it exists)
        appBarIcon = addToAppBar(window);
        
        // If visible, persist that window is not minimized (legacy key used in a few places)
        if (!isMinimized) {
            localStorage.setItem('fileExplorerWindowMinimized', 'false');
        }
        
        // Set initial app bar state (focused only if visible and focused)
        const nowMinimized = window.style.display === 'none';
        const isFocused = window.classList.contains('window-focused') && !nowMinimized;
        updateWindowAppBarState(window, isFocused, nowMinimized);
        
        // Save initial position to ensure window state is tracked
        // Use setTimeout to ensure window is rendered before saving
        setTimeout(() => {
            saveWindowPosition(window);
        }, 0);
        
        // Setup window controls
        setupWindowControls(window);
        setupFileExplorerSidebar(window, initialPath, restoreState);
        
        // Make window draggable and resizable
        makeWindowDraggable(window, { onDragEnd: saveFileExplorerWindowsState });
        makeWindowResizable(window, { minWidth: 600, minHeight: 400, onResize: saveFileExplorerWindowsState });
        
        // Add window-level drag handlers to allow desktop icons to be dragged into Files app
        // Use capture phase to ensure window receives dragover events before desktop handlers
        window.addEventListener('dragover', (e) => {
            // Only handle if dragging from desktop (use global flags; local var is the window element)
            if (globalThis.isDraggingFromDesktop) {
                // Make sure we're actually over this window (not just any window)
                const windowElement = e.target.closest('.window');
                if (windowElement === window) {
                    // IMPORTANT: don't stopPropagation here.
                    // Sidebar items / file items need to receive dragover so they can become valid drop targets.
                    if (!e.target.closest('.file-item') &&
                        !e.target.closest('.sidebar-item')) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                    }
                }
            }
        }, true); // Use capture phase to handle before desktop containers
        
        window.addEventListener('drop', async (e) => {
            // Only handle if dragging from desktop and not dropping on a specific file item or sidebar item
            if (globalThis.isDraggingFromDesktop && 
                !e.target.closest('.file-item') && 
                !e.target.closest('.sidebar-item')) {
                
                e.preventDefault();
                e.stopPropagation();
                
                const sourcePath = e.dataTransfer.getData('text/plain');
                const sourceType = e.dataTransfer.getData('item-type');
                
                if (sourcePath) {
                    try {
                        const fs = await initFileSystem();
                        const tab = getActiveTab();
                        if (tab && tab.currentPath) {
                            const targetPath = tab.currentPath;
                            
                            // Don't move if already in target directory
                            const sourceParent = fs.getParentPath(sourcePath);
                            if (sourceParent === targetPath) {
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            
                            // Prevent moving a folder into itself or its children
                            // Check if source and target are the same
                            if (sourceType === 'folder' && sourcePath === targetPath) {
                                alert('Cannot move a folder into itself');
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            
                            // Prevent moving a folder into its children
                            if (sourceType === 'folder' && targetPath.startsWith(sourcePath + '/')) {
                                alert('Cannot move a folder into itself or its children');
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            
                            try {
                                await fs.move(sourcePath, targetPath);
                            } catch (err) {
                                // For Desktop -> Files drags, "keep both" by auto-renaming on conflict
                                if (globalThis.isDraggingFromDesktop && err && err.message && err.message.includes('already exists')) {
                                    const desiredName = sourcePath.split('/').pop();
                                    const newName = await getNonConflictingName(fs, targetPath, desiredName, sourceType);
                                    await fs.move(sourcePath, targetPath, newName);
                                } else {
                                    throw err;
                                }
                            }
                            
                            // Immediately hide the dragged icon if it was from desktop
                            if (globalThis.isDraggingFromDesktop) {
                                const draggedIcon = document.querySelector(`.desktop-icon[data-file-path="${sourcePath}"]`);
                                if (draggedIcon) {
                                    draggedIcon.style.display = 'none';
                                    draggedIcon.classList.remove('dragging');
                                }
                                globalThis.isDraggingFromDesktop = false;
                            }
                            
                            // Refresh both Files windows and desktop icons
                            await refreshFileSystemViews(targetPath);
                        }
                    } catch (error) {
                        alert('Error moving item: ' + error.message);
                        globalThis.isDraggingFromDesktop = false;
                    }
                }
            }
        });
        
        // Focus window (unless minimized)
        if (!isMinimized) {
            focusWindow(window);
        }
        
        return window;
    }
    
    function setupFileExplorerSidebar(window, initialPath = null, restoreState = null) {
        const sidebarItems = window.querySelectorAll('.file-explorer-sidebar .sidebar-item');
        const itemsContainer = window.querySelector('.file-explorer-items');
        const addressBar = window.querySelector('.file-explorer-address-bar span');
        const tabsList = window.querySelector('#tabs-list');
        const newTabButton = window.querySelector('#new-tab-button');
        const fsSizeEl = window.querySelector('[data-fs-size]');
        const sizeDisplay = window.querySelector('#file-explorer-size-display');
        const sizeText = window.querySelector('#file-explorer-size-text');
        const fileCountText = window.querySelector('#file-explorer-file-count');
        
        // Setup custom tooltip for New Tab button
        if (newTabButton) {
            newTabButton.removeAttribute('title');
            setupNavButtonTooltip(newTabButton, 'New Tab');
        }
        
        // Set the logged-in user's name in the user-home sidebar item
        const userHomeSidebarItem = window.querySelector('#user-home-sidebar-item');
        const userHomeSidebarName = window.querySelector('#user-home-sidebar-name');
        if (userHomeSidebarItem && userHomeSidebarName) {
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    userHomeSidebarName.textContent = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                    userHomeSidebarName.textContent = 'User';
                }
            } else {
                userHomeSidebarName.textContent = 'User';
            }
        }
        
        // Tab management
        let tabs = [];
        let activeTabId = null;
        let tabIdCounter = 0;
        
        // Function to resize window to fit all tabs
        function resizeWindowForTabs() {
            if (!window || !tabsList || !newTabButton) return;
            
            // Get the tabs container (parent of tabsList)
            const tabsContainer = tabsList.parentElement;
            if (!tabsContainer) return;
            
            // Calculate total width needed for all tabs
            const newTabButtonWidth = newTabButton.offsetWidth || 32;
            const tabGap = 8; // gap between tabs
            let totalTabsWidth = newTabButtonWidth + tabGap;
            
            const tabElements = tabsList.querySelectorAll('.file-explorer-tab');
            tabElements.forEach(tab => {
                totalTabsWidth += tab.offsetWidth + tabGap;
            });
            
            // Get current tabs container width
            const tabsContainerWidth = tabsContainer.offsetWidth;
            const tabsContainerPadding = 20; // padding on left and right
            
            // Calculate how much width we need
            const neededTabsWidth = totalTabsWidth + tabsContainerPadding;
            
            // If we need more space, calculate the difference
            if (neededTabsWidth > tabsContainerWidth) {
                const extraWidthNeeded = neededTabsWidth - tabsContainerWidth;
                const currentWindowWidth = parseInt(window.style.width) || window.offsetWidth;
                const minWindowWidth = 600; // minimum window width
                const newWindowWidth = Math.max(minWindowWidth, currentWindowWidth + extraWidthNeeded);
                
                window.style.width = newWindowWidth + 'px';
                saveWindowPosition(window);
            }
        }
        
        // Tab data structure
        function createTabData(tabId, path = '/', location = 'disk-c') {
            return {
                id: tabId,
                currentPath: path,
                currentLocation: location,
                historyStack: [path],
                historyIndex: 0,
                isNavigatingHistory: false,
                viewMode: localStorage.getItem('fileExplorerViewMode') || 'grid' // 'grid' or 'list'
            };
        }
        
        // Get active tab data
        function getActiveTab() {
            return tabs.find(t => t.id === activeTabId);
        }

        function getCurrentPath() {
            const tab = getActiveTab();
            return tab ? tab.currentPath : '/';
        }
        
        // Save all tabs state to localStorage (including positions and active tab)
        function saveTabsState() {
            // Don't save during restoration to avoid overwriting
            if (isRestoringTabs) return;
            
            const activeTabIndex = tabs.findIndex(t => t.id === activeTabId);
            const tabsState = {
                tabs: tabs.map(tab => ({
                    path: tab.currentPath,
                    location: tab.currentLocation,
                    historyStack: tab.historyStack,
                    historyIndex: tab.historyIndex,
                    viewMode: tab.viewMode
                })),
                activeTabIndex: activeTabIndex >= 0 ? activeTabIndex : 0
            };
            localStorage.setItem('fileExplorerTabsState', JSON.stringify(tabsState));
            // Store tabs state on the window object for later retrieval
            window.fileExplorerTabsState = tabsState;
        }
        
        // Get saved tabs state from localStorage
        function getSavedTabsState() {
            const saved = localStorage.getItem('fileExplorerTabsState');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    return null;
                }
            }
            return null;
        }
        
        // Flag to prevent saving during restoration
        let isRestoringTabs = false;

        let isUpdatingFsSize = false;
        let fsSizeQueued = false;
        async function updateFsSize() {
            if (!fsSizeEl) {
                console.warn('updateFsSize: fsSizeEl not found');
                return;
            }
            if (isUpdatingFsSize) {
                fsSizeQueued = true;
                return;
            }
            isUpdatingFsSize = true;
            try {
                const sizeInfo = await getFileSystemSize();
                fsSizeEl.textContent = sizeInfo.formatted;
                // Setup tooltip if not already set up
                if (!fsSizeEl.dataset.tooltipSetup) {
                    fsSizeEl.removeAttribute('title');
                    setupNavButtonTooltip(fsSizeEl, 'Space Used');
                    fsSizeEl.dataset.tooltipSetup = 'true';
                }
            } catch (e) {
                console.error('Error updating filesystem size:', e);
            } finally {
                isUpdatingFsSize = false;
                if (fsSizeQueued) {
                    fsSizeQueued = false;
                    updateFsSize();
                }
            }
        }
        
        // Store updateFsSize on window for external access
        window.updateFsSize = updateFsSize;
        
        // Set active tab
        function setActiveTab(tabId) {
            activeTabId = tabId;
            const tab = getActiveTab();
            if (tab) {
                // Update UI to reflect active tab
                tabsList.querySelectorAll('.file-explorer-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tabId === tabId);
                });
                // Refresh content for active tab
                refreshActiveTab();
                // Save tabs state
                saveTabsState();
            }
        }
        
        // Create a new tab
        function createTab(path = '/', location = 'disk-c', savedTabData = null, skipSetActive = false) {
            const tabId = `tab-${tabIdCounter++}`;
            const tabData = createTabData(tabId, path, location);
            
            // Restore saved tab data if provided
            if (savedTabData) {
                if (savedTabData.historyStack) {
                    tabData.historyStack = savedTabData.historyStack;
                }
                if (savedTabData.historyIndex !== undefined) {
                    tabData.historyIndex = savedTabData.historyIndex;
                }
                if (savedTabData.viewMode) {
                    tabData.viewMode = savedTabData.viewMode;
                }
            }
            
            tabs.push(tabData);
            
            // Create tab UI element
            const tabElement = document.createElement('div');
            tabElement.className = 'file-explorer-tab';
            tabElement.dataset.tabId = tabId;
            tabElement.innerHTML = `
                <span class="file-explorer-tab-label">${getTabLabel(path, location)}</span>
                <button class="file-explorer-tab-close">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            `;
            
            // Setup custom tooltip for Close Tab button and close handler
            const closeButton = tabElement.querySelector('.file-explorer-tab-close');
            if (closeButton) {
                setupNavButtonTooltip(closeButton, 'Close Tab');
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeTab(tabId);
                });
            }
            
            // Tab click handler
            tabElement.addEventListener('click', (e) => {
                if (!e.target.closest('.file-explorer-tab-close')) {
                    setActiveTab(tabId);
                }
            });
            
            // Append tab element to maintain order
            tabsList.appendChild(tabElement);
            
            // Only set as active if not skipping (during restoration, we'll set active tab after all tabs are created)
            if (!skipSetActive) {
                setActiveTab(tabId);
            } else {
                // During restoration, don't set any tab as active yet
                // Just ensure we have an activeTabId reference for the first tab (will be overridden later)
                if (!activeTabId) {
                    activeTabId = tabId;
                }
            }
            
            // Resize window to fit all tabs (use setTimeout to ensure DOM is updated)
            if (!isRestoringTabs) {
                setTimeout(() => {
                    resizeWindowForTabs();
                }, 0);
            }
            
            // Save tabs state after creating (unless restoring)
            if (!isRestoringTabs) {
                saveTabsState();
            }
            
            return tabId;
        }
        
        // Close a tab
        function closeTab(tabId) {
            if (tabs.length <= 1) {
                // Don't allow closing the last tab
                return;
            }
            
            const tabIndex = tabs.findIndex(t => t.id === tabId);
            if (tabIndex === -1) return;
            
            // Remove tab from array
            tabs.splice(tabIndex, 1);
            
            // Remove tab UI element
            const tabElement = tabsList.querySelector(`[data-tab-id="${tabId}"]`);
            if (tabElement) {
                tabElement.remove();
            }
            
            // If closed tab was active, switch to another tab
            if (activeTabId === tabId) {
                const newActiveTab = tabs[Math.max(0, tabIndex - 1)];
                if (newActiveTab) {
                    setActiveTab(newActiveTab.id);
                }
            }
            
            // Resize window to fit remaining tabs (use setTimeout to ensure DOM is updated)
            setTimeout(() => {
                resizeWindowForTabs();
            }, 0);
            
            // Save tabs state after closing
            saveTabsState();
        }
        
        // Get tab label
        function getTabLabel(path, location) {
            const locationNames = {
                'desktop': 'Desktop',
                'downloads': 'Downloads',
                'documents': 'Documents',
                'pictures': 'Pictures',
                'music': 'Music',
                'videos': 'Videos',
                'trash': 'Trash',
                'disk-c': 'Local Disk (C:)'
            };
            
            if (location && locationNames[location]) {
                return locationNames[location];
            }
            
            // Otherwise use path
            if (path === '/') {
                return 'Local Disk (C:)';
            }
            
            const parts = path.split('/').filter(p => p);
            return parts.length > 0 ? parts[parts.length - 1] : 'Local Disk (C:)';
        }
        
        // Update tab label
        function updateTabLabel(tabId, path, location) {
            const tabElement = tabsList.querySelector(`[data-tab-id="${tabId}"]`);
            if (tabElement) {
                const label = tabElement.querySelector('.file-explorer-tab-label');
                if (label) {
                    label.textContent = getTabLabel(path, location);
                }
            }
        }
        
        // Helper function to update address bar
        function updateAddressBar(path) {
            if (addressBar) {
                const displayPath = formatPathForDisplay(path);
                const actualPath = getActualPath(path);
                addressBar.innerHTML = displayPath;
                addressBar.dataset.actualPath = actualPath;
                addressBar.style.cursor = 'text';
                addressBar.style.userSelect = 'text';
            }
        }
        
        // Refresh active tab content
        function refreshActiveTab() {
            const tab = getActiveTab();
            if (!tab) return;
            
            // Update address bar
            updateAddressBar(tab.currentPath);
            
            // Navigate to current path
            navigateToPath(tab.currentPath);
            
            // Update navigation buttons
            updateNavButtons();
        }
        
        // Helper function to format file name (with or without extension)
        function formatFileName(fileName) {
            const showExtensions = localStorage.getItem('showFileExtensions') === 'true'; // Default to false (hide extensions)
            if (showExtensions || fileName.lastIndexOf('.') <= 0) {
                // Show extensions or file has no extension
                return fileName;
            }
            // Hide extension (everything after the last dot)
            return fileName.substring(0, fileName.lastIndexOf('.'));
        }
        
        // Function to format size
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Function to calculate folder size and file count recursively
        async function calculateFolderSize(folderPath) {
            try {
                const fs = await initFileSystem();
                const countSize = async (path) => {
                    const dir = await fs.listDirectory(path);
                    let totalSize = 0;
                    for (const file of dir.files) {
                        totalSize += file.size || 0;
                    }
                    for (const folder of dir.folders) {
                        totalSize += await countSize(folder.path);
                    }
                    return totalSize;
                };
                return await countSize(folderPath);
            } catch (error) {
                console.error('Error calculating folder size:', error);
                return 0;
            }
        }
        
        // Function to count files recursively in a folder
        async function countFilesInFolder(folderPath) {
            try {
                const fs = await initFileSystem();
                const countFiles = async (path) => {
                    const dir = await fs.listDirectory(path);
                    let fileCount = dir.files.length;
                    for (const folder of dir.folders) {
                        fileCount += await countFiles(folder.path);
                    }
                    return fileCount;
                };
                return await countFiles(folderPath);
            } catch (error) {
                console.error('Error counting files in folder:', error);
                return 0;
            }
        }
        
        // Function to update size display for selected items
        async function updateSizeDisplay() {
            if (!sizeDisplay || !sizeText || !fileCountText) return;
            
            const selectedItems = itemsContainer.querySelectorAll('.file-item.selected');
            
            if (selectedItems.length === 0) {
                sizeDisplay.style.display = 'none';
                sizeText.textContent = '';
                fileCountText.textContent = '';
                return;
            }
            
            sizeDisplay.style.display = 'flex';
            sizeText.textContent = 'Calculating...';
            fileCountText.textContent = '';
            
            try {
                const fs = await initFileSystem();
                let totalSize = 0;
                let totalFileCount = 0;
                let hasFolders = false;
                
                for (const item of selectedItems) {
                    const path = item.dataset.path;
                    const type = item.dataset.type;
                    
                    if (type === 'file') {
                        const file = await fs.getFile(path);
                        totalSize += file.size || 0;
                        totalFileCount += 1;
                    } else if (type === 'folder') {
                        hasFolders = true;
                        const folderSize = await calculateFolderSize(path);
                        totalSize += folderSize;
                        const folderFileCount = await countFilesInFolder(path);
                        totalFileCount += folderFileCount;
                    }
                }
                
                // Display file count if there are folders selected, or if multiple items are selected
                if (hasFolders || selectedItems.length > 1) {
                    const fileText = totalFileCount === 1 ? 'file' : 'Files';
                    fileCountText.textContent = `${totalFileCount} ${fileText}, `;
                } else if (selectedItems.length === 1 && selectedItems[0].dataset.type === 'file') {
                    // Single file selected - don't show file count
                    fileCountText.textContent = '';
                } else {
                    fileCountText.textContent = '';
                }
                
                sizeText.textContent = formatSize(totalSize);
            } catch (error) {
                console.error('Error updating size display:', error);
                sizeText.textContent = 'Error';
                fileCountText.textContent = '';
            }
        }
        
        // Track last selected item for range selection
        let lastSelectedItem = null;
        
        // Function to handle file/folder selection (single click or Shift+click for range)
        function selectItem(item, isShiftClick = false) {
            const allItems = Array.from(itemsContainer.querySelectorAll('.file-item'));
            
            if (isShiftClick && lastSelectedItem) {
                // Range selection: select all items between lastSelectedItem and current item
                const lastIndex = allItems.indexOf(lastSelectedItem);
                const currentIndex = allItems.indexOf(item);
                
                if (lastIndex !== -1 && currentIndex !== -1) {
                    // Determine range
                    const startIndex = Math.min(lastIndex, currentIndex);
                    const endIndex = Math.max(lastIndex, currentIndex);
                    
                    // Select all items in range
                    for (let i = startIndex; i <= endIndex; i++) {
                        allItems[i].classList.add('selected');
                    }
                } else {
                    // Fallback to single selection if indices not found
                    item.classList.add('selected');
                    lastSelectedItem = item;
                }
            } else {
                // Single selection: clear all and select only this item
                allItems.forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
                lastSelectedItem = item;
            }
            
            // Update size display
            updateSizeDisplay();
        }

        // Navigation (per-tab)
        const backButton = window.querySelector('#back-button');
        const forwardButton = window.querySelector('#forward-button');

        function updateNavButtons() {
            const tab = getActiveTab();
            if (!tab) return;
            if (backButton) backButton.disabled = tab.historyIndex <= 0 || tab.historyStack.length <= 1;
            if (forwardButton) forwardButton.disabled = tab.historyIndex >= tab.historyStack.length - 1;
        }

        function addToHistory(path) {
            const tab = getActiveTab();
            if (!tab || tab.isNavigatingHistory) return;
            if (!path || typeof path !== 'string') return;

            // Trim forward history
            if (tab.historyIndex < tab.historyStack.length - 1) {
                tab.historyStack = tab.historyStack.slice(0, tab.historyIndex + 1);
            }

            // Avoid duplicate consecutive
            if (tab.historyStack.length > 0 && tab.historyStack[tab.historyStack.length - 1] === path) {
                return;
            }

            tab.historyStack.push(path);
            tab.historyIndex = tab.historyStack.length - 1;

            // Cap history
            if (tab.historyStack.length > 50) {
                tab.historyStack.shift();
                tab.historyIndex = Math.max(0, tab.historyIndex - 1);
            }

            updateNavButtons();
        }

        async function goBack(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            const tab = getActiveTab();
            if (!tab) return;
            if (tab.historyIndex <= 0) return;

            tab.historyIndex--;
            tab.isNavigatingHistory = true;
            const path = tab.historyStack[tab.historyIndex];
            tab.currentPath = path;
            try {
                await navigateToPath(path);
            } finally {
                tab.isNavigatingHistory = false;
                updateNavButtons();
            }
        }

        async function goForward(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            const tab = getActiveTab();
            if (!tab) return;
            if (tab.historyIndex >= tab.historyStack.length - 1) return;

            tab.historyIndex++;
            tab.isNavigatingHistory = true;
            const path = tab.historyStack[tab.historyIndex];
            tab.currentPath = path;
            try {
                await navigateToPath(path);
            } finally {
                tab.isNavigatingHistory = false;
                updateNavButtons();
            }
        }

        // Setup back and forward button handlers
        if (backButton) backButton.addEventListener('click', goBack);
        if (forwardButton) forwardButton.addEventListener('click', goForward);
        
        // Setup custom tooltips for navigation buttons and other Files app elements
        // (using global setupNavButtonTooltip function)
        setupNavButtonTooltip(backButton, 'Back');
        setupNavButtonTooltip(forwardButton, 'Forward');
        
        // Setup extension toggle button
        const extensionToggleButton = window.querySelector('#extension-toggle-button');
        if (extensionToggleButton) {
            // Update button state based on current preference
            const updateExtensionButtonState = () => {
                const showExtensions = localStorage.getItem('showFileExtensions') === 'true'; // Default to false (hide extensions)
                extensionToggleButton.classList.toggle('active', showExtensions);
                
                const icon = extensionToggleButton.querySelector('#extension-toggle-icon');
                if (icon) {
                    if (showExtensions) {
                        // Show normal eyeball (extensions visible)
                        icon.innerHTML = `
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        `;
                    } else {
                        // Show eyeball with diagonal line (extensions hidden)
                        icon.innerHTML = `
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                            <line x1="1" y1="1" x2="23" y2="23"></line>
                        `;
                    }
                }
            };
            
            // Initialize button state
            updateExtensionButtonState();
            
            // Set up click handler
            extensionToggleButton.addEventListener('click', () => {
                const currentValue = localStorage.getItem('showFileExtensions');
                const newValue = currentValue === 'false' ? 'true' : 'false';
                localStorage.setItem('showFileExtensions', newValue);
                updateExtensionButtonState();
                // Refresh current view to update file names
                refreshCurrentView();
                // Update all desktop icon labels immediately
                if (window.updateDesktopIconLabels) {
                    window.updateDesktopIconLabels();
                }
            });
            
            // Set up tooltip
            setupNavButtonTooltip(extensionToggleButton, () => {
                const showExtensions = localStorage.getItem('showFileExtensions') === 'true';
                return showExtensions ? 'Hide File Extensions' : 'Show File Extensions';
            });
        }
        
        // Setup sidebar empty trash button
        const sidebarEmptyTrashBtn = window.querySelector('#sidebar-empty-trash-btn');
        if (sidebarEmptyTrashBtn) {
            // Function to check if Trash has any content
            const checkTrashHasContent = async () => {
                try {
                    const fs = await initFileSystem();
                    const trashPath = getUserTrashPath();
                    const directory = await fs.listDirectory(trashPath);
                    return directory.files.length > 0 || directory.folders.length > 0;
                } catch (error) {
                    console.error('Error checking trash content:', error);
                    return false;
                }
            };
            
            // Function to update sidebar button visibility based on current path and trash content
            const updateSidebarEmptyTrashButton = async () => {
                const tab = getActiveTab();
                const currentPath = tab ? tab.currentPath : '/';
                const trashPath = getUserTrashPath();
                const isInTrash = currentPath === trashPath;
                const hasContent = await checkTrashHasContent();
                
                // Hide button if we're in Trash directory or if Trash is empty
                if (isInTrash || !hasContent) {
                    sidebarEmptyTrashBtn.style.display = 'none';
                } else {
                    sidebarEmptyTrashBtn.style.display = 'flex';
                }
            };
            
            // Show button on hover of trash sidebar item (only if it has content and we're not in Trash)
            const trashSidebarItem = window.querySelector('[data-location="trash"]');
            if (trashSidebarItem) {
                trashSidebarItem.addEventListener('mouseenter', async () => {
                    const tab = getActiveTab();
                    const currentPath = tab ? tab.currentPath : '/';
                    const trashPath = getUserTrashPath();
                    const hasContent = await checkTrashHasContent();
                    if (currentPath !== trashPath && hasContent) {
                        sidebarEmptyTrashBtn.style.opacity = '1';
                    }
                });
                trashSidebarItem.addEventListener('mouseleave', () => {
                    sidebarEmptyTrashBtn.style.opacity = '0';
                });
            }
            
            // Initialize button visibility
            updateSidebarEmptyTrashButton();
            
            // Store function reference for use in refreshCurrentView and navigateToPath
            window.updateSidebarEmptyTrashButton = updateSidebarEmptyTrashButton;
            
            // Handle click on empty trash button
            sidebarEmptyTrashBtn.addEventListener('click', async (e) => {
                e.stopPropagation(); // Prevent triggering sidebar item click
                const confirmed = await showConfirmationDialog('Are you sure you want to empty the trash? This will permanently delete all items.', 'Empty Trash');
                if (confirmed) {
                    try {
                        const fs = await initFileSystem();
                        const trashPath = getUserTrashPath();
                        const directory = await fs.listDirectory(trashPath);
                        
                        // Check if README.txt is in trash before deleting
                        const hasReadme = directory.files.some(file => file.name === 'README.txt');
                        
                        // Delete all files
                        for (const file of directory.files) {
                            await fs.deleteFile(file.path);
                        }
                        
                        // Track if README.txt was permanently deleted
                        if (hasReadme) {
                            localStorage.setItem('readme_txt_permanently_deleted', 'true');
                        }
                        
                        // Delete all folders recursively
                        for (const folder of directory.folders) {
                            await fs.deleteFolder(folder.path);
                        }
                        
                        // Update sidebar button visibility after emptying trash
                        if (window.updateSidebarEmptyTrashButton) {
                            await window.updateSidebarEmptyTrashButton();
                        }
                        
                        // Refresh both Files windows and desktop icons
                        await refreshFileSystemViews(trashPath);
                    } catch (error) {
                        alert('Error emptying trash: ' + error.message);
                    }
                }
            });
            
            // Setup custom tooltip for Empty Trash button
            setupNavButtonTooltip(sidebarEmptyTrashBtn, 'Empty Trash');
            
            sidebarEmptyTrashBtn.addEventListener('mouseenter', () => {
                sidebarEmptyTrashBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                sidebarEmptyTrashBtn.style.color = 'rgba(255, 255, 255, 0.9)';
            });
            sidebarEmptyTrashBtn.addEventListener('mouseleave', () => {
                sidebarEmptyTrashBtn.style.background = 'transparent';
                sidebarEmptyTrashBtn.style.color = 'rgba(255, 255, 255, 0.6)';
            });
        }
        
        // Setup new tab button
        if (newTabButton) {
            newTabButton.addEventListener('click', () => {
                // Always create new tab at root directory
                createTab('/', 'disk-c');
            });
        }

        // Keyboard shortcuts for tabs (Ctrl+T / Ctrl+W / Ctrl+Tab)
        const tabKeyHandler = (e) => {
            // Only handle when Files window is visible and not typing in inputs
            if (window.style.display === 'none' || !document.body.contains(window)) return;
            if (e.target && e.target.matches && e.target.matches('input, textarea, [contenteditable="true"]')) return;

            const isCtrl = e.ctrlKey || e.metaKey;
            if (!isCtrl) return;

            const key = (e.key || '').toLowerCase();
            if (key === 't') {
                e.preventDefault();
                // Always create new tab at root directory
                createTab('/', 'disk-c');
                return;
            }
            if (key === 'w') {
                e.preventDefault();
                if (activeTabId) closeTab(activeTabId);
                return;
            }
            if (key === 'tab') {
                if (tabs.length <= 1) return;
                e.preventDefault();
                const idx = tabs.findIndex(t => t.id === activeTabId);
                const dir = e.shiftKey ? -1 : 1;
                const nextIdx = (idx + dir + tabs.length) % tabs.length;
                setActiveTab(tabs[nextIdx].id);
            }
        };
        document.addEventListener('keydown', tabKeyHandler);
        
        // Helper function to format path for display (with arrows)
        function formatPathForDisplay(path) {
            if (path === '/') {
                return 'Local Disk (C:)';
            }
            const withDrive = `C:${path}`;
            const formatted = withDrive.replace(/^C:/, 'Local Disk (C:)');
            // Split by slashes and join with triangle icons
            const parts = formatted.split('/').filter(p => p);
            if (parts.length === 0) {
                return 'Local Disk (C:)';
            }
            // Create HTML with triangle icons between parts
            const triangleIcon = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin: 0 4px; opacity: 0.6;"><path d="M9 18l6-6-6-6"></path></svg>';
            return parts.map(part => `<span>${part}</span>`).join(triangleIcon);
        }
        
        // Helper function to get actual path (with slashes) for copy/paste
        function getActualPath(path) {
            if (path === '/') {
                return 'C:';
            }
            return `C:${path}`;
        }
        
        // Clipboard for copy/cut/paste operations
        let clipboard = {
            type: null, // 'copy' or 'cut'
            item: null, // file or folder object
            path: null
        };
        
        // Helper function to get user-specific folder path
        function getUserFolderPath(folderName) {
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    return `/Users/${user.name}/${folderName}`;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }
            return `/${folderName}`;
        }
        
        // Helper function to get user-specific Trash path
        function getUserTrashPath() {
            return getUserFolderPath('Trash');
        }
        
        // Helper function to check if a file is an image
        function isImageFile(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
            return imageExts.includes(ext);
        }
        
        // Helper function to create image preview element
        // Uses global image cache to prevent flickering
        async function createImagePreview(filePath, fileName) {
            try {
                // Use global image cache (getImageUrlFromFilesystem handles caching)
                const imageUrl = await getImageUrlFromFilesystem(filePath);
                if (!imageUrl) {
                    return null;
                }
                
                // Escape the icon HTML for use in the error handler
                const iconHtml = getFileIcon(fileName).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                return `<img src="${imageUrl}" alt="${fileName}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;" onerror="this.style.display='none'; this.parentElement.innerHTML='${iconHtml}';" />`;
            } catch (error) {
                console.warn('Error creating image preview:', error);
                return null;
            }
        }
        
        // Get icon for file type
        function getFileIcon(fileName, isFolder = false) {
            if (isFolder) {
                return '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
            }
            
            const ext = fileName.split('.').pop().toLowerCase();
            const iconMap = {
                'lnk': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>',
                'txt': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>',
                'jpg': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
                'jpeg': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
                'png': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
                'gif': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
                'mp3': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>',
                'mp4': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>',
                'zip': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
                'pdf': '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>'
            };
            return iconMap[ext] || '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>';
        }

        // Fast directory renderer for Files app:
        // - batches DOM insertion (DocumentFragment)
        // - caches icon-size settings once per render
        // - defers image previews so folders/files appear immediately
        function scheduleIdleWork(fn) {
            requestAnimationFrame(() => {
                if (typeof requestIdleCallback === 'function') {
                    requestIdleCallback(fn, { timeout: 800 });
                } else {
                    setTimeout(fn, 0);
                }
            });
        }

        function ensureFilesContainerDelegatedHandlers(containerEl) {
            if (!containerEl) return;
            if (containerEl.dataset.delegatedHandlersAdded) return;
            containerEl.dataset.delegatedHandlersAdded = 'true';

            let dragOverItem = null;
            const clearDragOver = () => {
                if (dragOverItem) {
                    dragOverItem.classList.remove('drag-over');
                    dragOverItem = null;
                }
                containerEl.classList.remove('drag-over-container');
            };

            const getItem = (target) => {
                const el = target && target.closest ? target.closest('.file-item') : null;
                return (el && containerEl.contains(el)) ? el : null;
            };

            // Selection (single delegated click)
            containerEl.addEventListener('click', (e) => {
                const item = getItem(e.target);
                if (!item) return;
                e.stopPropagation();
                selectItem(item, !!e.shiftKey);
            });

            // Open on double-click
            containerEl.addEventListener('dblclick', (e) => {
                const item = getItem(e.target);
                if (!item) return;
                const path = item.dataset.path;
                const type = item.dataset.type;
                const name = item.dataset.name || (path ? path.split('/').pop() : '');
                if (!path || !type) return;
                if (type === 'folder') {
                    navigateToPath(path);
                } else {
                    openFile(path, name);
                }
            });

            // Context menu
            containerEl.addEventListener('contextmenu', (e) => {
                const item = getItem(e.target);
                if (!item) return;
                const path = item.dataset.path;
                const type = item.dataset.type;
                const name = item.dataset.name || (path ? path.split('/').pop() : '');
                if (!path || !type) return;
                showFileContextMenu(e, path, type, name);
            });

            // Drag start/end
            containerEl.addEventListener('dragstart', (e) => {
                const item = getItem(e.target);
                if (!item) return;
                const path = item.dataset.path;
                const type = item.dataset.type || 'file';
                if (!path) return;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', path);
                e.dataTransfer.setData('item-type', type);
                item.classList.add('dragging');
                globalThis.isDraggingFromFilesApp = true;
            });

            containerEl.addEventListener('dragend', (e) => {
                const item = getItem(e.target);
                if (item) item.classList.remove('dragging');
                globalThis.isDraggingFromFilesApp = false;
                clearDragOver();
                const desktopIconsContainer = document.querySelector('.desktop-icons');
                if (desktopIconsContainer) {
                    desktopIconsContainer.style.pointerEvents = 'none';
                    desktopIconsContainer.style.zIndex = '900';
                    desktopIconsContainer.classList.remove('drag-over-desktop');
                }
            });

            // Drag over: highlight folder targets + container for empty-space drop
            containerEl.addEventListener('dragover', (e) => {
                if (!globalThis.isDraggingFromDesktop && !globalThis.isDraggingFromFilesApp) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';

                containerEl.classList.add('drag-over-container');
                const item = getItem(e.target);
                const isFolderTarget = !!(item && item.dataset.type === 'folder');
                if (isFolderTarget) {
                    if (dragOverItem && dragOverItem !== item) dragOverItem.classList.remove('drag-over');
                    dragOverItem = item;
                    dragOverItem.classList.add('drag-over');
                } else if (dragOverItem) {
                    dragOverItem.classList.remove('drag-over');
                    dragOverItem = null;
                }
            });

            containerEl.addEventListener('dragleave', (e) => {
                if (!containerEl.contains(e.relatedTarget)) {
                    clearDragOver();
                }
            });

            // Drop: if on folder item -> drop into it; else drop into current directory
            containerEl.addEventListener('drop', async (e) => {
                if (!globalThis.isDraggingFromDesktop && !globalThis.isDraggingFromFilesApp) return;

                e.preventDefault();
                e.stopPropagation();
                clearDragOver();

                const sourcePath = e.dataTransfer.getData('text/plain');
                const sourceType = e.dataTransfer.getData('item-type');
                if (!sourcePath) return;

                const item = getItem(e.target);
                const folderTargetPath = (item && item.dataset.type === 'folder') ? item.dataset.path : null;

                try {
                    const fs = await initFileSystem();
                    const tab = getActiveTab();
                    if (!tab || !tab.currentPath) return;

                    const targetPath = folderTargetPath || tab.currentPath;
                    const sourceParent = fs.getParentPath(sourcePath);
                    if (sourceParent === targetPath) {
                        globalThis.isDraggingFromDesktop = false;
                        globalThis.isDraggingFromFilesApp = false;
                        return;
                    }

                    // Prevent moving a folder into itself/children
                    if (sourceType === 'folder' && (sourcePath === targetPath || targetPath.startsWith(sourcePath + '/'))) {
                        alert('Cannot move a folder into itself or its children');
                        globalThis.isDraggingFromDesktop = false;
                        globalThis.isDraggingFromFilesApp = false;
                        return;
                    }

                    try {
                        await fs.move(sourcePath, targetPath);
                    } catch (err) {
                        // For Desktop -> Files drags, "keep both" by auto-renaming on conflict
                        if (globalThis.isDraggingFromDesktop && err && err.message && err.message.includes('already exists')) {
                            const desiredName = sourcePath.split('/').pop();
                            const newName = await getNonConflictingName(fs, targetPath, desiredName, sourceType);
                            await fs.move(sourcePath, targetPath, newName);
                        } else {
                            throw err;
                        }
                    }

                    // Immediately hide the dragged icon if it was from desktop
                    if (globalThis.isDraggingFromDesktop) {
                        const draggedIcon = document.querySelector(`.desktop-icon[data-file-path="${sourcePath}"]`);
                        if (draggedIcon) {
                            draggedIcon.style.display = 'none';
                            draggedIcon.classList.remove('dragging');
                        }
                        globalThis.isDraggingFromDesktop = false;
                    }

                    await refreshCurrentView();

                    if (window.refreshDesktopIcons) {
                        await window.refreshDesktopIcons();
                    }
                    globalThis.isDraggingFromFilesApp = false;
                } catch (error) {
                    alert('Error moving item: ' + error.message);
                    globalThis.isDraggingFromDesktop = false;
                    globalThis.isDraggingFromFilesApp = false;
                }
            });
        }

        async function renderDirectoryListingInto(containerEl, directory) {
            if (!containerEl) return;

            // Clear quickly
            containerEl.innerHTML = '';
            lastSelectedItem = null;

            // Ensure delegated handlers (click/open/contextmenu/drag+drop) exist
            ensureFilesContainerDelegatedHandlers(containerEl);

            // Cache icon size settings once
            const sizeKey = currentIconSize || localStorage.getItem('fileExplorerIconSize') || 'small';
            const sizeConfig = (iconSizes && iconSizes[sizeKey]) ? iconSizes[sizeKey] : { icon: 32, grid: 100, label: 11 };

            if (currentView === 'grid') {
                containerEl.style.gridTemplateColumns = `repeat(auto-fill, minmax(${sizeConfig.grid}px, 1fr))`;
            }

            const frag = document.createDocumentFragment();
            const previewQueue = [];
            const maxPreviews = 24;

            function applyGridSizing(fileItem) {
                if (!fileItem || currentView !== 'grid') return;
                const iconEl = fileItem.querySelector('.file-icon');
                const nameEl = fileItem.querySelector('.file-name');
                if (iconEl) {
                    iconEl.style.width = sizeConfig.icon + 'px';
                    iconEl.style.height = sizeConfig.icon + 'px';
                }
                if (nameEl) {
                    nameEl.style.fontSize = sizeConfig.label + 'px';
                }
            }

            function addItem(type, path, name) {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.dataset.path = path;
                fileItem.dataset.type = type;
                fileItem.dataset.name = name;
                fileItem.draggable = true;

                const isFolder = type === 'folder';
                const isImg = !isFolder && isImageFile(name);

                // Fast initial icon; preview swapped later
                fileItem.innerHTML = `
                    <div class="file-icon">${getFileIcon(name, isFolder)}</div>
                    <div class="file-name">${formatFileName(name)}</div>
                `;

                applyGridSizing(fileItem);

                if (isImg && currentView === 'grid' && previewQueue.length < maxPreviews) {
                    previewQueue.push({ fileItem, path, name });
                }

                frag.appendChild(fileItem);
            }

            (directory.folders || []).forEach(folder => addItem('folder', folder.path, folder.name));
            (directory.files || []).forEach(file => addItem('file', file.path, file.name));

            containerEl.appendChild(frag);

            if (previewQueue.length > 0) {
                scheduleIdleWork(() => {
                    let i = 0;
                    const tick = () => {
                        const batch = previewQueue.slice(i, i + 4);
                        i += batch.length;
                        batch.forEach(({ fileItem, path, name }) => {
                            if (!fileItem || !document.body.contains(fileItem)) return;
                            if (fileItem.dataset.path !== path) return;
                            createImagePreview(path, name).then(previewHtml => {
                                if (!previewHtml) return;
                                if (!document.body.contains(fileItem)) return;
                                if (fileItem.dataset.path !== path) return;
                                const iconDiv = fileItem.querySelector('.file-icon');
                                if (iconDiv) iconDiv.innerHTML = previewHtml;
                            });
                        });
                        if (i < previewQueue.length) setTimeout(tick, 0);
                    };
                    tick();
                });
            }
        }
        
        async function updateContent(location) {
            const tab = getActiveTab();
            if (!tab) return;
            
            // Clear search when navigating
            if (searchInput) {
                searchInput.value = '';
                isSearching = false;
            }
            
            // Remove active class from all items
            sidebarItems.forEach(item => item.classList.remove('active'));
            
            // Add active class to selected item
            const selectedItem = window.querySelector(`[data-location="${location}"]`);
            if (selectedItem) {
                selectedItem.classList.add('active');
            }
            
            // Get currently logged-in user to determine user-specific folder paths
            let currentUsername = null;
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    currentUsername = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }
            
            // Map location to path - user-specific folders point to /Users/[username]/[folder]
            const locationToPath = {
                'home': '/',
                // If we can't resolve the user, treat as invalid (prevents creating user folders in root).
                'user-home': currentUsername ? `/Users/${currentUsername}` : null,
                'desktop': currentUsername ? `/Users/${currentUsername}/Desktop` : null,
                'downloads': currentUsername ? `/Users/${currentUsername}/Downloads` : null,
                'documents': currentUsername ? `/Users/${currentUsername}/Documents` : null,
                'pictures': currentUsername ? `/Users/${currentUsername}/Pictures` : null,
                'music': currentUsername ? `/Users/${currentUsername}/Music` : null,
                'videos': currentUsername ? `/Users/${currentUsername}/Videos` : null,
                'trash': currentUsername ? `/Users/${currentUsername}/Trash` : null,
                'disk-c': '/'
            };
            
            const previousPath = tab.currentPath;
            const newPath = locationToPath[location];
            
            // Ensure we have a valid path
            if (!newPath) {
                console.warn('Unknown location:', location);
                return;
            }
            
            // Ensure the folder exists (create if missing)
            if (newPath !== '/') {
                try {
                    const fs = await initFileSystem();
                    const folder = await fs.getFolder(newPath);
                    if (!folder) {
                        // Folder doesn't exist, create it
                        const pathParts = newPath.split('/').filter(p => p);
                        const folderName = pathParts.pop();
                        const parentPath = '/' + pathParts.join('/');
                        await fs.createFolder(parentPath, folderName);
                    }
                } catch (error) {
                    console.warn('Could not ensure folder exists:', newPath, error);
                }
            }
            
            // Update tab data
            tab.currentPath = newPath;
            tab.currentLocation = location;
            updateTabLabel(tab.id, newPath, location);
            
            // Update sidebar empty trash button visibility
            if (window.updateSidebarEmptyTrashButton) {
                window.updateSidebarEmptyTrashButton();
            }
            
            // Add to history if not navigating through history and path actually changed
            if (!tab.isNavigatingHistory && previousPath !== newPath) {
                // First, ensure the previous path is in history (so back button returns to where you came from)
                // The addToHistory function will skip it if it's already the last item (duplicate prevention)
                addToHistory(previousPath);
                // Now add the new path to history
                addToHistory(tab.currentPath);
            }
            
            // Save tabs state
            saveTabsState();
            
            // Update toolbar - add Empty Trash button if in Trash
            const navButtons = window.querySelector('.file-explorer-nav-buttons');
            if (navButtons) {
                // Remove existing empty trash button
                const existingEmptyBtn = navButtons.querySelector('.empty-trash-btn');
                if (existingEmptyBtn) {
                    existingEmptyBtn.remove();
                }
                
                // Add Empty Trash button if in Trash
                const trashPath = getUserTrashPath();
                if (location === 'trash' || tab.currentPath === trashPath) {
                    const emptyBtn = document.createElement('button');
                    emptyBtn.className = 'nav-button empty-trash-btn';
                    emptyBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                    `;
                    // Setup custom tooltip for Empty Trash button
                    setupNavButtonTooltip(emptyBtn, 'Empty Trash');
                    
                    // Check if Trash has content and disable button if empty
                    const checkAndUpdateButtonState = async () => {
                        try {
                            const fs = await initFileSystem();
                            const directory = await fs.listDirectory(trashPath);
                            const hasContent = directory.files.length > 0 || directory.folders.length > 0;
                            
                            if (hasContent) {
                                emptyBtn.disabled = false;
                                emptyBtn.style.opacity = '1';
                                emptyBtn.style.cursor = 'pointer';
                            } else {
                                emptyBtn.disabled = true;
                                emptyBtn.style.opacity = '0.5';
                                emptyBtn.style.cursor = 'not-allowed';
                            }
                        } catch (error) {
                            console.error('Error checking trash content:', error);
                            emptyBtn.disabled = true;
                            emptyBtn.style.opacity = '0.5';
                            emptyBtn.style.cursor = 'not-allowed';
                        }
                    };
                    
                    // Check initial state (don't block rendering)
                    scheduleIdleWork(() => checkAndUpdateButtonState().catch(() => {}));
                    
                    // Store function to update button state
                    emptyBtn.updateState = checkAndUpdateButtonState;
                    
                    emptyBtn.addEventListener('click', async () => {
                        if (emptyBtn.disabled) return;
                        const confirmed = await showConfirmationDialog('Are you sure you want to empty the trash? This will permanently delete all items.', 'Empty Trash');
                if (confirmed) {
                            try {
                                const fs = await initFileSystem();
                                const directory = await fs.listDirectory(trashPath);
                                
                                // Check if README.txt is in trash before deleting
                                const hasReadme = directory.files.some(file => file.name === 'README.txt');
                                
                                // Delete all files
                                for (const file of directory.files) {
                                    await fs.deleteFile(file.path);
                                }
                                
                                // Track if README.txt was permanently deleted
                                if (hasReadme) {
                                    localStorage.setItem('readme_txt_permanently_deleted', 'true');
                                }
                                
                                // Delete all folders recursively
                                for (const folder of directory.folders) {
                                    await fs.deleteFolder(folder.path);
                                }
                                
                                // Update button state after emptying
                                if (emptyBtn.updateState) {
                                    await emptyBtn.updateState();
                                }
                                
                                // Refresh both Files windows and desktop icons
                                await refreshFileSystemViews(trashPath);
                            } catch (error) {
                                alert('Error emptying trash: ' + error.message);
                            }
                        }
                    });
                    navButtons.appendChild(emptyBtn);
                }
            }
            
            // Update address bar - show with arrows for display, store actual path for copy/paste
            // Update address bar
            updateAddressBar(tab.currentPath);
            
            // Update sidebar empty trash button visibility
            if (window.updateSidebarEmptyTrashButton) {
                window.updateSidebarEmptyTrashButton();
            }
            
            // Update navigation bar empty trash button state if in Trash (don't block rendering)
            const navEmptyBtn = window.querySelector('.empty-trash-btn');
            if (navEmptyBtn && navEmptyBtn.updateState) {
                scheduleIdleWork(() => navEmptyBtn.updateState().catch(() => {}));
            }
            
            // Clear and populate items container
            // Re-query itemsContainer to ensure we have the current DOM element
            const currentItemsContainer = window.querySelector('.file-explorer-items');
            if (currentItemsContainer) {
                currentItemsContainer.innerHTML = '';
                // Reset last selected item when clearing container
                lastSelectedItem = null;
                
                try {
                    // Load from file system
                    const fs = await initFileSystem();
                    const directory = await fs.listDirectory(tab.currentPath);

                    // Fast path: render via batched DOM + deferred previews, then exit (legacy renderer below is kept for reference)
                    await renderDirectoryListingInto(currentItemsContainer, directory);
                    return;
                    
                    currentItemsContainer.innerHTML = '';
                    
                    // Add folders first
                    directory.folders.forEach(folder => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.dataset.path = folder.path;
                        fileItem.dataset.type = 'folder';
                        fileItem.draggable = true;
                        fileItem.innerHTML = `
                            <div class="file-icon">
                                ${getFileIcon(folder.name, true)}
                            </div>
                            <div class="file-name">${formatFileName(folder.name)}</div>
                        `;
                        // Single click to select (for folders) - supports Shift+click for range selection
                        fileItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            selectItem(fileItem, e.shiftKey);
                        });
                        // Double click to navigate (for folders)
                        fileItem.addEventListener('dblclick', () => navigateToPath(folder.path));
                        fileItem.addEventListener('contextmenu', (e) => showFileContextMenu(e, folder.path, 'folder', folder.name));
                        
                        // Drag and drop handlers
                        fileItem.addEventListener('dragstart', (e) => {
                            e.dataTransfer.effectAllowed = 'move';
                            e.dataTransfer.setData('text/plain', folder.path);
                            e.dataTransfer.setData('item-type', 'folder');
                            fileItem.classList.add('dragging');
                            // Set global flag for desktop drag and drop
                            globalThis.isDraggingFromFilesApp = true;
                        });
                        fileItem.addEventListener('dragend', () => {
                            fileItem.classList.remove('dragging');
                            // Remove all drag-over classes
                            itemsContainer.querySelectorAll('.file-item').forEach(item => {
                                item.classList.remove('drag-over');
                            });
                            // Clean up desktop drag state
                            globalThis.isDraggingFromFilesApp = false;
                            const desktopIconsContainer = document.querySelector('.desktop-icons');
                            if (desktopIconsContainer) {
                                desktopIconsContainer.style.pointerEvents = 'none';
                                desktopIconsContainer.style.zIndex = '900';
                                desktopIconsContainer.classList.remove('drag-over-desktop');
                            }
                        });
                        fileItem.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = 'move';
                            // Only highlight if it's a folder (we'll check the path in drop event)
                            // Also allow if dragging from desktop
                            if (fileItem.dataset.type === 'folder' || globalThis.isDraggingFromDesktop) {
                                fileItem.classList.add('drag-over');
                            }
                        });
                        fileItem.addEventListener('dragleave', () => {
                            fileItem.classList.remove('drag-over');
                        });
                        fileItem.addEventListener('drop', async (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            fileItem.classList.remove('drag-over');
                            
                            const sourcePath = e.dataTransfer.getData('text/plain');
                            const sourceType = e.dataTransfer.getData('item-type');
                            
                            if (sourcePath && sourcePath !== folder.path) {
                                // Prevent moving a folder into itself or its children
                                // Check if source and target are the same (shouldn't happen due to above check, but extra safety)
                                if (sourceType === 'folder' && sourcePath === folder.path) {
                                    alert('Cannot move a folder into itself');
                                    globalThis.isDraggingFromDesktop = false;
                                    return;
                                }
                                
                                // Prevent moving a folder into its children
                                if (sourceType === 'folder' && folder.path.startsWith(sourcePath + '/')) {
                                    alert('Cannot move a folder into itself or its children');
                                    globalThis.isDraggingFromDesktop = false;
                                    return;
                                }
                                
                                try {
                                    const fs = await initFileSystem();
                                    try {
                                        await fs.move(sourcePath, folder.path);
                                    } catch (err) {
                                        // For Desktop -> Files drags, "keep both" by auto-renaming on conflict
                                        if (globalThis.isDraggingFromDesktop && err && err.message && err.message.includes('already exists')) {
                                            const desiredName = sourcePath.split('/').pop();
                                            const newName = await getNonConflictingName(fs, folder.path, desiredName, sourceType);
                                            await fs.move(sourcePath, folder.path, newName);
                                        } else {
                                            throw err;
                                        }
                                    }
                                    
                                    // Immediately hide the dragged icon if it was from desktop
                                    if (globalThis.isDraggingFromDesktop) {
                                        const draggedIcon = document.querySelector(`.desktop-icon[data-file-path="${sourcePath}"]`);
                                        if (draggedIcon) {
                                            draggedIcon.style.display = 'none';
                                            draggedIcon.classList.remove('dragging');
                                        }
                                        globalThis.isDraggingFromDesktop = false;
                                    }
                                    
                                    await refreshCurrentView();
                                    
                                    // Refresh desktop icons if item was moved from desktop
                                    if (window.refreshDesktopIcons) {
                                        await window.refreshDesktopIcons();
                                    }
                                } catch (error) {
                                    alert('Error moving item: ' + error.message);
                                    globalThis.isDraggingFromDesktop = false;
                                }
                            }
                        });
                        
                        currentItemsContainer.appendChild(fileItem);
                        
                        // Apply icon size to the newly created item
                        let iconSize = localStorage.getItem('fileExplorerIconSize');
                        if (!iconSize) {
                            iconSize = 'small';
                            localStorage.setItem('fileExplorerIconSize', 'small');
                        }
                        const iconSizes = {
                            small: { icon: 32, grid: 100, label: 11 },
                            medium: { icon: 48, grid: 120, label: 12 },
                            large: { icon: 64, grid: 140, label: 13 }
                        };
                        const sizeConfig = iconSizes[iconSize];
                        const fileIcon = fileItem.querySelector('.file-icon');
                        const fileName = fileItem.querySelector('.file-name');
                        if (fileIcon && currentView === 'grid') {
                            fileIcon.style.width = sizeConfig.icon + 'px';
                            fileIcon.style.height = sizeConfig.icon + 'px';
                        }
                        if (fileName && currentView === 'grid') {
                            fileName.style.fontSize = sizeConfig.label + 'px';
                        }
                    });
                    
                    // Update grid template columns based on icon size
                    if (currentView === 'grid') {
                        let iconSize = localStorage.getItem('fileExplorerIconSize');
                        if (!iconSize) {
                            iconSize = 'small';
                            localStorage.setItem('fileExplorerIconSize', 'small');
                        }
                        const iconSizes = {
                            small: { icon: 32, grid: 100 },
                            medium: { icon: 48, grid: 120 },
                            large: { icon: 64, grid: 140 }
                        };
                        const sizeConfig = iconSizes[iconSize];
                        currentItemsContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${sizeConfig.grid}px, 1fr))`;
                    }
                    
                    // Add files
                    directory.files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.dataset.path = file.path;
                        fileItem.dataset.type = 'file';
                        fileItem.draggable = true;
                        
                        // Check if this is an image file and load preview
                        if (isImageFile(file.name)) {
                            // Start with placeholder icon, then load image preview
                        fileItem.innerHTML = `
                            <div class="file-icon">
                                ${getFileIcon(file.name)}
                            </div>
                            <div class="file-name">${formatFileName(file.name)}</div>
                        `;
                            // Load image preview asynchronously
                            createImagePreview(file.path, file.name).then(previewHtml => {
                                if (previewHtml) {
                                    const iconDiv = fileItem.querySelector('.file-icon');
                                    if (iconDiv) {
                                        iconDiv.innerHTML = previewHtml;
                                    }
                                }
                            });
                        } else {
                            fileItem.innerHTML = `
                                <div class="file-icon">
                                    ${getFileIcon(file.name)}
                                </div>
                                <div class="file-name">${formatFileName(file.name)}</div>
                            `;
                        }
                        // Single click to select (for files) - supports Shift+click for range selection
                        fileItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            // Use currentTarget to ensure we get the fileItem even if clicking on child elements
                            selectItem(e.currentTarget, e.shiftKey);
                        });
                        // Double click to open (for files)
                        fileItem.addEventListener('dblclick', () => openFile(file.path, file.name));
                        fileItem.addEventListener('contextmenu', (e) => showFileContextMenu(e, file.path, 'file', file.name));
                        
                        // Drag and drop handlers
                        fileItem.addEventListener('dragstart', (e) => {
                            e.dataTransfer.effectAllowed = 'move';
                            e.dataTransfer.setData('text/plain', file.path);
                            e.dataTransfer.setData('item-type', 'file');
                            fileItem.classList.add('dragging');
                            // Set global flag for desktop drag and drop
                            globalThis.isDraggingFromFilesApp = true;
                        });
                        fileItem.addEventListener('dragend', () => {
                            fileItem.classList.remove('dragging');
                            // Remove all drag-over classes
                            const container = document.querySelector('.file-explorer-items');
                            if (container) {
                                container.querySelectorAll('.file-item').forEach(item => {
                                    item.classList.remove('drag-over');
                                });
                            }
                            // Clean up desktop drag state
                            globalThis.isDraggingFromFilesApp = false;
                            const desktopIconsContainer = document.querySelector('.desktop-icons');
                            if (desktopIconsContainer) {
                                desktopIconsContainer.style.pointerEvents = 'none';
                                desktopIconsContainer.style.zIndex = '900';
                                desktopIconsContainer.classList.remove('drag-over-desktop');
                            }
                        });
                        fileItem.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = 'move';
                            // Highlight if it's a folder, or if dragging from desktop (for visual feedback)
                            if (fileItem.dataset.type === 'folder' || globalThis.isDraggingFromDesktop) {
                                fileItem.classList.add('drag-over');
                            }
                        });
                        fileItem.addEventListener('dragleave', () => {
                            fileItem.classList.remove('drag-over');
                        });
                        fileItem.addEventListener('drop', async (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            fileItem.classList.remove('drag-over');
                            
                            const sourcePath = e.dataTransfer.getData('text/plain');
                            const sourceType = e.dataTransfer.getData('item-type');
                            
                            if (sourcePath && sourcePath !== file.path && fileItem.dataset.type === 'folder') {
                                // Prevent moving a folder into itself
                                if (sourceType === 'folder' && sourcePath === fileItem.dataset.path) {
                                    alert('Cannot move a folder into itself');
                                    globalThis.isDraggingFromDesktop = false;
                                    globalThis.isDraggingFromFilesApp = false;
                                    return;
                                }
                                
                                // Prevent moving a folder into its children
                                if (sourceType === 'folder' && fileItem.dataset.path.startsWith(sourcePath + '/')) {
                                    alert('Cannot move a folder into itself or its children');
                                    globalThis.isDraggingFromDesktop = false;
                                    globalThis.isDraggingFromFilesApp = false;
                                    return;
                                }
                                
                                try {
                                    const fs = await initFileSystem();
                                    await fs.move(sourcePath, fileItem.dataset.path);
                                    
                                    // Immediately hide the dragged icon if it was from desktop
                                    if (globalThis.isDraggingFromDesktop) {
                                        const draggedIcon = document.querySelector(`.desktop-icon[data-file-path="${sourcePath}"]`);
                                        if (draggedIcon) {
                                            draggedIcon.style.display = 'none';
                                            draggedIcon.classList.remove('dragging');
                                        }
                                        globalThis.isDraggingFromDesktop = false;
                                    }
                                    
                                    await refreshCurrentView();
                                    
                                    // Refresh desktop icons if item was moved from desktop
                                    if (window.refreshDesktopIcons) {
                                        await window.refreshDesktopIcons();
                                    }
                                } catch (error) {
                                    alert('Error moving item: ' + error.message);
                                    globalThis.isDraggingFromDesktop = false;
                                }
                            }
                        });
                        
                        currentItemsContainer.appendChild(fileItem);
                        
                        // Apply icon size to the newly created item
                        let iconSize = localStorage.getItem('fileExplorerIconSize');
                        if (!iconSize) {
                            iconSize = 'small';
                            localStorage.setItem('fileExplorerIconSize', 'small');
                        }
                        const iconSizes = {
                            small: { icon: 32, grid: 100, label: 11 },
                            medium: { icon: 48, grid: 120, label: 12 },
                            large: { icon: 64, grid: 140, label: 13 }
                        };
                        const sizeConfig = iconSizes[iconSize];
                        const fileIcon = fileItem.querySelector('.file-icon');
                        const fileName = fileItem.querySelector('.file-name');
                        if (fileIcon && currentView === 'grid') {
                            fileIcon.style.width = sizeConfig.icon + 'px';
                            fileIcon.style.height = sizeConfig.icon + 'px';
                        }
                        if (fileName && currentView === 'grid') {
                            fileName.style.fontSize = sizeConfig.label + 'px';
                        }
                    });
                    
                    // Update grid template columns based on icon size
                    if (currentView === 'grid') {
                        let iconSize = localStorage.getItem('fileExplorerIconSize');
                        if (!iconSize) {
                            iconSize = 'small';
                            localStorage.setItem('fileExplorerIconSize', 'small');
                        }
                        const iconSizes = {
                            small: { icon: 32, grid: 100 },
                            medium: { icon: 48, grid: 120 },
                            large: { icon: 64, grid: 140 }
                        };
                        const sizeConfig = iconSizes[iconSize];
                        currentItemsContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${sizeConfig.grid}px, 1fr))`;
                    }
                    
                    // Add drop handler to items container for dropping on empty space (current directory)
                    // Only add if not already added (check for data attribute)
                    if (!currentItemsContainer.dataset.dropHandlersAdded) {
                        currentItemsContainer.dataset.dropHandlersAdded = 'true';
                        
                        currentItemsContainer.addEventListener('dragover', (e) => {
                            if (globalThis.isDraggingFromDesktop || globalThis.isDraggingFromFilesApp) {
                                e.preventDefault();
                                e.stopPropagation();
                                e.dataTransfer.dropEffect = 'move';
                                currentItemsContainer.classList.add('drag-over-container');
                            }
                        });
                        
                        currentItemsContainer.addEventListener('dragleave', (e) => {
                            if (!currentItemsContainer.contains(e.relatedTarget)) {
                                currentItemsContainer.classList.remove('drag-over-container');
                            }
                        });
                        
                        currentItemsContainer.addEventListener('drop', async (e) => {
                            if (!globalThis.isDraggingFromDesktop && !globalThis.isDraggingFromFilesApp) return;
                            
                            e.preventDefault();
                            e.stopPropagation();
                            currentItemsContainer.classList.remove('drag-over-container');
                            
                            // Only handle if dropping on container itself (not on a file item)
                            if (e.target === currentItemsContainer || !e.target.closest('.file-item')) {
                                const sourcePath = e.dataTransfer.getData('text/plain');
                                const sourceType = e.dataTransfer.getData('item-type');
                                
                                if (sourcePath) {
                                    try {
                                        const fs = await initFileSystem();
                                        const tab = getActiveTab();
                                        if (tab && tab.currentPath) {
                                            const targetPath = tab.currentPath;
                                            
                                            // Don't move if already in target directory
                                            const sourceParent = fs.getParentPath(sourcePath);
                                            if (sourceParent === targetPath) {
                                                globalThis.isDraggingFromDesktop = false;
                                                globalThis.isDraggingFromFilesApp = false;
                                                return;
                                            }
                                            
                                            // Prevent moving a folder into itself or its children
                                            // Check if source and target are the same
                                            if (sourceType === 'folder' && sourcePath === targetPath) {
                                                alert('Cannot move a folder into itself');
                                                globalThis.isDraggingFromDesktop = false;
                                                globalThis.isDraggingFromFilesApp = false;
                                                return;
                                            }
                                            
                                            // Prevent moving a folder into its children
                                            if (sourceType === 'folder' && targetPath.startsWith(sourcePath + '/')) {
                                                alert('Cannot move a folder into itself or its children');
                                                globalThis.isDraggingFromDesktop = false;
                                                globalThis.isDraggingFromFilesApp = false;
                                                return;
                                            }
                                            
                                            try {
                                                await fs.move(sourcePath, targetPath);
                                            } catch (err) {
                                                // For Desktop -> Files drags, "keep both" by auto-renaming on conflict
                                                if (globalThis.isDraggingFromDesktop && err && err.message && err.message.includes('already exists')) {
                                                    const desiredName = sourcePath.split('/').pop();
                                                    const newName = await getNonConflictingName(fs, targetPath, desiredName, sourceType);
                                                    await fs.move(sourcePath, targetPath, newName);
                                                } else {
                                                    throw err;
                                                }
                                            }
                                            
                                            // Immediately hide the dragged icon if it was from desktop
                                            if (globalThis.isDraggingFromDesktop) {
                                                const draggedIcon = document.querySelector(`.desktop-icon[data-file-path="${sourcePath}"]`);
                                                if (draggedIcon) {
                                                    draggedIcon.style.display = 'none';
                                                    draggedIcon.classList.remove('dragging');
                                                }
                                                globalThis.isDraggingFromDesktop = false;
                                            }
                                            
                                            await refreshCurrentView();
                                            
                                            // Refresh desktop icons if item was moved from desktop
                                            if (window.refreshDesktopIcons) {
                                                await window.refreshDesktopIcons();
                                            }
                                            if (globalThis.isDraggingFromFilesApp) {
                                                globalThis.isDraggingFromFilesApp = false;
                                            }
                                        }
                                    } catch (error) {
                                        alert('Error moving item: ' + error.message);
                                        globalThis.isDraggingFromDesktop = false;
                                        globalThis.isDraggingFromFilesApp = false;
                                    }
                                }
                            }
                        });
                    }
                } catch (error) {
                    currentItemsContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: rgba(255,0,0,0.6);">Error loading directory: ${error.message}</div>`;
                }
            }
        }
        
        // Inline renaming removed - use context menu rename instead
        
        async function refreshCurrentView() {
            const tab = getActiveTab();
            if (!tab) return;
            // Don't refresh if currently searching
            if (isSearching) {
                return;
            }
            
            // Determine if currentPath is a predefined location (check both root and user-specific paths)
            const loggedInUser = localStorage.getItem('loggedInUser');
            let currentUsername = null;
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    currentUsername = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }
            
            const pathToLocation = {
                '/': 'disk-c',
                '/Desktop': 'desktop',
                '/Downloads': 'downloads',
                '/Documents': 'documents',
                '/Pictures': 'pictures',
                '/Music': 'music',
                '/Videos': 'videos'
            };
            
            // Also check user-specific paths
            if (currentUsername) {
                pathToLocation[`/Users/${currentUsername}/Desktop`] = 'desktop';
                pathToLocation[`/Users/${currentUsername}/Downloads`] = 'downloads';
                pathToLocation[`/Users/${currentUsername}/Documents`] = 'documents';
                pathToLocation[`/Users/${currentUsername}/Pictures`] = 'pictures';
                pathToLocation[`/Users/${currentUsername}/Music`] = 'music';
                pathToLocation[`/Users/${currentUsername}/Videos`] = 'videos';
                pathToLocation[`/Users/${currentUsername}/Trash`] = 'trash';
            }
            
            const location = pathToLocation[tab.currentPath];
            if (location) {
                await updateContent(location);
            } else {
                await navigateToPath(tab.currentPath);
            }

            // Don't let filesystem size computation compete with initial render
            scheduleIdleWork(() => updateFsSize());
        }
        
        async function navigateToPath(path) {
            const tab = getActiveTab();
            if (!tab) return;
            // Clear search when navigating
            if (searchInput) {
                searchInput.value = '';
                isSearching = false;
            }
            
            const previousPath = tab.currentPath;
            if (!tab.isNavigatingHistory) {
                if (previousPath !== path) addToHistory(path);
            }
            tab.currentPath = path;
            
            // Save tabs state
            saveTabsState();

            // Update sidebar active state based on path (check both root and user-specific paths)
            const loggedInUser = localStorage.getItem('loggedInUser');
            let currentUsername = null;
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    currentUsername = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }
            
            const pathToLocation = {
                '/': 'disk-c',
                '/Desktop': 'desktop',
                '/Downloads': 'downloads',
                '/Documents': 'documents',
                '/Pictures': 'pictures',
                '/Music': 'music',
                '/Videos': 'videos'
            };
            
            // Also check user-specific paths
            if (currentUsername) {
                pathToLocation[`/Users/${currentUsername}/Desktop`] = 'desktop';
                pathToLocation[`/Users/${currentUsername}/Downloads`] = 'downloads';
                pathToLocation[`/Users/${currentUsername}/Documents`] = 'documents';
                pathToLocation[`/Users/${currentUsername}/Pictures`] = 'pictures';
                pathToLocation[`/Users/${currentUsername}/Music`] = 'music';
                pathToLocation[`/Users/${currentUsername}/Videos`] = 'videos';
                pathToLocation[`/Users/${currentUsername}/Trash`] = 'trash';
            }
            
            const location = pathToLocation[path];
            if (location) {
                // Remove active class from all items
                sidebarItems.forEach(item => item.classList.remove('active'));
                // Add active class to selected item
                const selectedItem = window.querySelector(`[data-location="${location}"]`);
                if (selectedItem) {
                    selectedItem.classList.add('active');
                }
                tab.currentLocation = location;
            } else {
                // For custom paths, remove active state from all sidebar items
                sidebarItems.forEach(item => item.classList.remove('active'));
                tab.currentLocation = null;
            }

            updateTabLabel(tab.id, path, tab.currentLocation);
            
            // Update sidebar empty trash button visibility
            if (window.updateSidebarEmptyTrashButton) {
                window.updateSidebarEmptyTrashButton();
            }
            
            const fs = await initFileSystem();
            const directory = await fs.listDirectory(path);
            
            // Update toolbar - add Empty Trash button if in Trash
            const navButtons = window.querySelector('.file-explorer-nav-buttons');
            if (navButtons) {
                // Remove existing empty trash button
                const existingEmptyBtn = navButtons.querySelector('.empty-trash-btn');
                if (existingEmptyBtn) {
                    existingEmptyBtn.remove();
                }
                
                // Add Empty Trash button if in Trash
                const trashPath = getUserTrashPath();
                if (path === trashPath) {
                    const emptyBtn = document.createElement('button');
                    emptyBtn.className = 'nav-button empty-trash-btn';
                    emptyBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                    `;
                    // Setup custom tooltip for Empty Trash button
                    setupNavButtonTooltip(emptyBtn, 'Empty Trash');
                    emptyBtn.addEventListener('click', async () => {
                        const confirmed = await showConfirmationDialog('Are you sure you want to empty the trash? This will permanently delete all items.', 'Empty Trash');
                if (confirmed) {
                            try {
                                const fs = await initFileSystem();
                                const directory = await fs.listDirectory(trashPath);
                                
                                // Check if README.txt is in trash before deleting
                                const hasReadme = directory.files.some(file => file.name === 'README.txt');
                                
                                // Delete all files
                                for (const file of directory.files) {
                                    await fs.deleteFile(file.path);
                                }
                                
                                // Track if README.txt was permanently deleted
                                if (hasReadme) {
                                    localStorage.setItem('readme_txt_permanently_deleted', 'true');
                                }
                                
                                // Delete all folders recursively
                                for (const folder of directory.folders) {
                                    await fs.deleteFolder(folder.path);
                                }
                                
                                await navigateToPath(trashPath);
                            } catch (error) {
                                alert('Error emptying trash: ' + error.message);
                            }
                        }
                    });
                    navButtons.appendChild(emptyBtn);
                }
            }
            
            // Update address bar
            updateAddressBar(path);
            
            // Re-query itemsContainer to ensure we have the current DOM element
            const currentItemsContainer = window.querySelector('.file-explorer-items');
            if (currentItemsContainer) {
                currentItemsContainer.innerHTML = '';
                // Clear any selections when navigating
                // Hide size display when navigating
                if (sizeDisplay) {
                    sizeDisplay.style.display = 'none';
                    if (sizeText) sizeText.textContent = '';
                    if (fileCountText) fileCountText.textContent = '';
                }

                // Fast path: render via batched DOM + deferred previews, then exit (legacy renderer below is kept for reference)
                await renderDirectoryListingInto(currentItemsContainer, directory);
                return;
                
                // Add folders
                directory.folders.forEach(folder => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.dataset.path = folder.path;
                    fileItem.dataset.type = 'folder';
                    fileItem.draggable = true;
                    fileItem.innerHTML = `
                        <div class="file-icon">
                            ${getFileIcon(folder.name, true)}
                        </div>
                        <div class="file-name">${formatFileName(folder.name)}</div>
                    `;
                    // Single click to select (for folders)
                    fileItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        selectItem(fileItem);
                    });
                    // Double click to navigate (for folders) - but not on the name
                    fileItem.addEventListener('dblclick', (e) => {
                        if (e.target.classList.contains('file-name')) {
                            e.stopPropagation();
                            return;
                        }
                        navigateToPath(folder.path);
                    });
                    fileItem.addEventListener('contextmenu', (e) => showFileContextMenu(e, folder.path, 'folder', folder.name));
                    
                    // Drag and drop handlers
                    fileItem.addEventListener('dragstart', (e) => {
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', folder.path);
                        e.dataTransfer.setData('item-type', 'folder');
                        fileItem.classList.add('dragging');
                        // Set global flag for desktop drag and drop
                        globalThis.isDraggingFromFilesApp = true;
                    });
                    fileItem.addEventListener('dragend', () => {
                        fileItem.classList.remove('dragging');
                        // Remove all drag-over classes
                        const container = window.querySelector('.file-explorer-items');
                        if (container) {
                            container.querySelectorAll('.file-item').forEach(item => {
                                item.classList.remove('drag-over');
                            });
                        }
                        // Clean up desktop drag state
                        globalThis.isDraggingFromFilesApp = false;
                        const desktopIconsContainer = document.querySelector('.desktop-icons');
                        if (desktopIconsContainer) {
                            desktopIconsContainer.style.pointerEvents = 'none';
                            desktopIconsContainer.style.zIndex = '900';
                            desktopIconsContainer.classList.remove('drag-over-desktop');
                        }
                    });
                    fileItem.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'move';
                        // Only highlight if it's a folder (we'll check the path in drop event)
                        if (fileItem.dataset.type === 'folder') {
                            fileItem.classList.add('drag-over');
                        }
                    });
                    fileItem.addEventListener('dragleave', () => {
                        fileItem.classList.remove('drag-over');
                    });
                    fileItem.addEventListener('drop', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        fileItem.classList.remove('drag-over');
                        
                        const sourcePath = e.dataTransfer.getData('text/plain');
                        const sourceType = e.dataTransfer.getData('item-type');
                        
                        if (sourcePath && sourcePath !== folder.path && fileItem.dataset.type === 'folder') {
                            // Prevent moving a folder into itself
                            if (sourceType === 'folder' && sourcePath === fileItem.dataset.path) {
                                alert('Cannot move a folder into itself');
                                globalThis.isDraggingFromDesktop = false;
                                globalThis.isDraggingFromFilesApp = false;
                                return;
                            }
                            
                            // Prevent moving a folder into its children
                            if (sourceType === 'folder' && fileItem.dataset.path.startsWith(sourcePath + '/')) {
                                alert('Cannot move a folder into itself or its children');
                                globalThis.isDraggingFromDesktop = false;
                                globalThis.isDraggingFromFilesApp = false;
                                return;
                            }
                            
                            try {
                                const fs = await initFileSystem();
                                await fs.move(sourcePath, fileItem.dataset.path);
                                await refreshCurrentView();
                                
                                // Refresh desktop icons if item was moved from desktop
                                if (globalThis.isDraggingFromDesktop) {
                                    if (window.refreshDesktopIcons) {
                                        await window.refreshDesktopIcons();
                                    }
                                    globalThis.isDraggingFromDesktop = false;
                                }
                            } catch (error) {
                                alert('Error moving item: ' + error.message);
                                if (globalThis.isDraggingFromDesktop) {
                                    globalThis.isDraggingFromDesktop = false;
                                }
                            }
                        }
                    });
                    
                    currentItemsContainer.appendChild(fileItem);
                    
                    // Apply icon size to the newly created item
                    let iconSize = localStorage.getItem('fileExplorerIconSize');
                    if (!iconSize) {
                        iconSize = 'small';
                        localStorage.setItem('fileExplorerIconSize', 'small');
                    }
                    const iconSizes = {
                        small: { icon: 32, grid: 100, label: 11 },
                        medium: { icon: 48, grid: 120, label: 12 },
                        large: { icon: 64, grid: 140, label: 13 }
                    };
                    const sizeConfig = iconSizes[iconSize];
                    const fileIcon = fileItem.querySelector('.file-icon');
                    const fileName = fileItem.querySelector('.file-name');
                    if (fileIcon && currentView === 'grid') {
                        fileIcon.style.width = sizeConfig.icon + 'px';
                        fileIcon.style.height = sizeConfig.icon + 'px';
                    }
                    if (fileName && currentView === 'grid') {
                        fileName.style.fontSize = sizeConfig.label + 'px';
                    }
                });
                
                // Add files
                directory.files.forEach(file => {
                    const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.dataset.path = file.path;
                        fileItem.dataset.type = 'file';
                        fileItem.draggable = true;
                        
                        // Check if this is an image file and load preview
                        if (isImageFile(file.name)) {
                            // Start with placeholder icon, then load image preview
                        fileItem.innerHTML = `
                            <div class="file-icon">
                                ${getFileIcon(file.name)}
                            </div>
                            <div class="file-name">${formatFileName(file.name)}</div>
                        `;
                            // Load image preview asynchronously
                            createImagePreview(file.path, file.name).then(previewHtml => {
                                if (previewHtml) {
                                    const iconDiv = fileItem.querySelector('.file-icon');
                                    if (iconDiv) {
                                        iconDiv.innerHTML = previewHtml;
                                    }
                                }
                            });
                        } else {
                            fileItem.innerHTML = `
                                <div class="file-icon">
                                    ${getFileIcon(file.name)}
                                </div>
                                <div class="file-name">${formatFileName(file.name)}</div>
                            `;
                        }
                        // Single click to select (for files) - supports Shift+click for range selection
                        fileItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            selectItem(fileItem, e.shiftKey);
                        });
                        // Double click to open (for files)
                        fileItem.addEventListener('dblclick', () => openFile(file.path, file.name));
                        fileItem.addEventListener('contextmenu', (e) => showFileContextMenu(e, file.path, 'file', file.name));
                        
                        // Drag and drop handlers
                        fileItem.addEventListener('dragstart', (e) => {
                            e.dataTransfer.effectAllowed = 'move';
                            e.dataTransfer.setData('text/plain', file.path);
                            e.dataTransfer.setData('item-type', 'file');
                            fileItem.classList.add('dragging');
                            // Set global flag for desktop drag and drop
                            globalThis.isDraggingFromFilesApp = true;
                        });
                        fileItem.addEventListener('dragend', () => {
                            fileItem.classList.remove('dragging');
                            // Remove all drag-over classes
                            const container = window.querySelector('.file-explorer-items');
                            if (container) {
                                container.querySelectorAll('.file-item').forEach(item => {
                                item.classList.remove('drag-over');
                            });
                            }
                            // Clean up desktop drag state
                            globalThis.isDraggingFromFilesApp = false;
                            const desktopIconsContainer = document.querySelector('.desktop-icons');
                            if (desktopIconsContainer) {
                                desktopIconsContainer.style.pointerEvents = 'none';
                                desktopIconsContainer.style.zIndex = '900';
                                desktopIconsContainer.classList.remove('drag-over-desktop');
                            }
                        });
                        fileItem.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = 'move';
                            // Only highlight if it's a folder (we'll check the path in drop event)
                            if (fileItem.dataset.type === 'folder') {
                                fileItem.classList.add('drag-over');
                            }
                        });
                        fileItem.addEventListener('dragleave', () => {
                            fileItem.classList.remove('drag-over');
                        });
                        fileItem.addEventListener('drop', async (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            fileItem.classList.remove('drag-over');
                            
                            const sourcePath = e.dataTransfer.getData('text/plain');
                            const sourceType = e.dataTransfer.getData('item-type');
                            
                            if (sourcePath && sourcePath !== file.path && fileItem.dataset.type === 'folder') {
                                // Prevent moving a folder into itself
                                if (sourceType === 'folder' && sourcePath === fileItem.dataset.path) {
                                    alert('Cannot move a folder into itself');
                                globalThis.isDraggingFromDesktop = false;
                                globalThis.isDraggingFromFilesApp = false;
                                    return;
                                }
                                
                                // Prevent moving a folder into its children
                                if (sourceType === 'folder' && fileItem.dataset.path.startsWith(sourcePath + '/')) {
                                    alert('Cannot move a folder into itself or its children');
                                globalThis.isDraggingFromDesktop = false;
                                globalThis.isDraggingFromFilesApp = false;
                                    return;
                                }
                                
                                try {
                                    const fs = await initFileSystem();
                                    await fs.move(sourcePath, fileItem.dataset.path);
                                    await refreshCurrentView();
                                    
                                    // Refresh desktop icons if item was moved from desktop
                                if (globalThis.isDraggingFromDesktop) {
                                        if (window.refreshDesktopIcons) {
                                            await window.refreshDesktopIcons();
                                        }
                                    globalThis.isDraggingFromDesktop = false;
                                    }
                                } catch (error) {
                                    alert('Error moving item: ' + error.message);
                                if (globalThis.isDraggingFromDesktop) {
                                    globalThis.isDraggingFromDesktop = false;
                                    }
                                }
                            }
                        });
                        
                        currentItemsContainer.appendChild(fileItem);
                        
                        // Apply icon size to the newly created item
                        let iconSize = localStorage.getItem('fileExplorerIconSize');
                        if (!iconSize) {
                            iconSize = 'small';
                            localStorage.setItem('fileExplorerIconSize', 'small');
                        }
                        const iconSizes = {
                            small: { icon: 32, grid: 100, label: 11 },
                            medium: { icon: 48, grid: 120, label: 12 },
                            large: { icon: 64, grid: 140, label: 13 }
                        };
                        const sizeConfig = iconSizes[iconSize];
                        const fileIcon = fileItem.querySelector('.file-icon');
                        const fileName = fileItem.querySelector('.file-name');
                        if (fileIcon && currentView === 'grid') {
                            fileIcon.style.width = sizeConfig.icon + 'px';
                            fileIcon.style.height = sizeConfig.icon + 'px';
                        }
                        if (fileName && currentView === 'grid') {
                            fileName.style.fontSize = sizeConfig.label + 'px';
                        }
                });
                
                // Update grid template columns based on icon size
                if (currentView === 'grid') {
                    let iconSize = localStorage.getItem('fileExplorerIconSize');
                    if (!iconSize) {
                        iconSize = 'small';
                        localStorage.setItem('fileExplorerIconSize', 'small');
                    }
                    const iconSizes = {
                        small: { icon: 32, grid: 100 },
                        medium: { icon: 48, grid: 120 },
                        large: { icon: 64, grid: 140 }
                    };
                    const sizeConfig = iconSizes[iconSize];
                    currentItemsContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${sizeConfig.grid}px, 1fr))`;
                }
            }
        }
        
        // Store navigateToPath on window element for access from desktop icons
        window.navigateToPath = navigateToPath;
        
        async function openFile(path, name) {
            const fs = await initFileSystem();
            const file = await fs.getFile(path);
            if (!file) return;
            
            // Check if this is an app shortcut (.lnk file)
            const ext = name.split('.').pop().toLowerCase();
            // Images: open in Viewer
            if (isImageFile(name)) {
                const openViewer = initViewer();
                if (openViewer) {
                    openViewer(path);
                }
                return;
            }
            // Audio/Video: open in Player
            const audioExts = ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'opus', 'flac'];
            const videoExts = ['mp4', 'webm', 'ogv', 'mkv', 'mov'];
            if (audioExts.includes(ext) || videoExts.includes(ext)) {
                const openPlayer = initPlayer();
                if (openPlayer) {
                    openPlayer(path);
                }
                return;
            }
            if (ext === 'lnk') {
                try {
                    const content = await fs.getFileContent(path);
                    if (!content) {
                        console.error('Shortcut file content is empty:', path);
                        return;
                    }
                    
                    // getFileContent already returns a string for text files, no need to decode
                    const shortcutData = JSON.parse(content);
                    
                    // Launch the app based on shortcut data
                    if (shortcutData.appName) {
                        if (shortcutData.appName === 'Files') {
                            // Set flag to navigate to root when opening
                            navigateToRootOnOpen = true;
                            const openFileExplorer = initFileExplorer();
                            if (openFileExplorer) {
                                openFileExplorer('/'); // Pass root path as parameter
                            } else {
                                console.error('Failed to get File Explorer function');
                            }
                        } else if (shortcutData.appName === 'Settings') {
                            const openSettings = initSettingsWindow();
                            if (openSettings) {
                                openSettings();
                            } else {
                                console.error('Failed to get Settings function');
                            }
                        } else if (shortcutData.appName === 'Editor') {
                            openTextEditor();
                        } else if (shortcutData.appName === 'Viewer') {
                            const openViewer = initViewer();
                            if (openViewer) {
                                openViewer();
                            }
                        } else if (shortcutData.appName === 'Player') {
                            const openPlayer = initPlayer();
                            if (openPlayer) {
                                openPlayer();
                            }
                        } else {
                            console.error('Unknown app name:', shortcutData.appName);
                        }
                    } else {
                        console.error('Shortcut data missing appName:', shortcutData);
                    }
                    return;
                } catch (e) {
                    console.error('Error reading shortcut file:', e, path);
                    // Fall through to normal file handling
                }
            }
            
            // For text files, open in editor
            const textExts = ['txt', 'md', 'js', 'css', 'html', 'json', 'xml', 'csv', 'log'];
            
            if (textExts.includes(ext) || !file.isBinary) {
                openFileEditor(path, name);
            } else {
                // Download binary files
                downloadFile(path, name);
            }
        }
        
        function showFileContextMenu(e, path, type, name) {
            e.preventDefault();
            e.stopPropagation();
            
            // Remove existing context menu
            const existing = document.querySelector('.file-context-menu');
            if (existing) existing.remove();
            
            // Get all selected items (if any)
            const selectedItems = itemsContainer ? Array.from(itemsContainer.querySelectorAll('.file-item.selected')) : [];
            const hasMultipleSelection = selectedItems.length > 1;
            
            // Determine which items to operate on
            // If multiple items are selected and the right-clicked item is one of them, use all selected items
            // Otherwise, use just the right-clicked item
            let itemsToOperate = [];
            const clickedItem = selectedItems.find(item => item.dataset.path === path);
            
            if (hasMultipleSelection && clickedItem) {
                // Multiple items selected and right-clicked on one of them - operate on all selected
                itemsToOperate = selectedItems.map(item => ({
                    path: item.dataset.path,
                    type: item.dataset.type,
                    name: item.querySelector('.file-name')?.textContent || item.dataset.path.split('/').pop()
                }));
            } else {
                // Single selection or right-clicked on non-selected item - operate on just this item
                itemsToOperate = [{ path, type, name }];
                // Also select this item if it wasn't selected
                const itemElement = itemsContainer?.querySelector(`[data-path="${path}"]`);
                if (itemElement && !itemElement.classList.contains('selected')) {
                    selectItem(itemElement, false);
                }
            }
            
            const menu = document.createElement('div');
            menu.className = 'context-menu file-context-menu show';
            
            // Position menu, ensuring it stays within viewport
            let left = e.pageX;
            let top = e.pageY;
            const menuWidth = 220;
            const menuHeight = 300; // approximate
            
            if (left + menuWidth > window.innerWidth) {
                left = window.innerWidth - menuWidth - 10;
            }
            if (top + menuHeight > window.innerHeight) {
                top = window.innerHeight - menuHeight - 10;
            }
            
            menu.style.left = left + 'px';
            menu.style.top = top + 'px';
            menu.style.display = 'flex'; // Ensure it's visible
            menu.style.zIndex = '10000'; // Ensure it's on top
            
            // Check if we're in Trash folder
            const trashPath = getUserTrashPath();
            const isInTrash = getCurrentPath() === trashPath || path.startsWith(trashPath + '/');
            
            // Check if any of the items to operate on are protected sidebar folders
            const hasProtectedFolder = itemsToOperate.some(item => 
                item.type === 'folder' && isProtectedSidebarFolder(item.path)
            );
            
            // Build menu HTML with icons
            let menuHTML = '';
            
            // Special menu for items in Trash
            if (isInTrash) {
                menuHTML = `
                    <div class="context-menu-item" data-action="restore">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                                <polyline points="9 22 9 12 15 12 15 22"></polyline>
                            </svg>
                        </div>
                        <span>Restore</span>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="delete-permanent">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </div>
                        <span>Delete Permanently</span>
                    </div>
                `;
            } else if (type === 'folder') {
                menuHTML = `
                    <div class="context-menu-item" data-action="open">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                        </div>
                        <span>Open</span>
                    </div>
                    <div class="context-menu-item" data-action="open-new-tab">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                        </div>
                        <span>Open in New Tab</span>
                    </div>
                    <div class="context-menu-item" data-action="open-new-window">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="9" y1="3" x2="9" y2="21"></line>
                            </svg>
                        </div>
                        <span>Open in New Window</span>
                    </div>
                    ${hasProtectedFolder ? '' : `
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="cut">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="6" cy="6" r="3"></circle>
                                <circle cx="6" cy="18" r="3"></circle>
                                <line x1="6" y1="9" x2="6" y2="15"></line>
                                <path d="M20 4l-7 7m0 0l7 7m-7-7v12"></path>
                            </svg>
                        </div>
                        <span>Cut</span>
                        <span class="context-menu-shortcut">Ctrl+X</span>
                    </div>
                    <div class="context-menu-item" data-action="copy">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </div>
                        <span>Copy</span>
                        <span class="context-menu-shortcut">Ctrl+C</span>
                    </div>
                    <div class="context-menu-item" data-action="duplicate">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </div>
                        <span>Duplicate</span>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="rename">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </div>
                        <span>Rename</span>
                        <span class="context-menu-shortcut">F2</span>
                    </div>
                    `}
                    <div class="context-menu-item" data-action="properties">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="12" y1="16" x2="12" y2="12"></line>
                                <line x1="12" y1="8" x2="12.01" y2="8"></line>
                            </svg>
                        </div>
                        <span>Properties</span>
                    </div>
                    ${hasProtectedFolder ? '' : `
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="delete">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </div>
                        <span>Delete</span>
                        <span class="context-menu-shortcut">Del</span>
                    </div>
                    `}
                `;
            } else {
                menuHTML = `
                    <div class="context-menu-item" data-action="open">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                        </div>
                        <span>Open</span>
                        <span class="context-menu-shortcut">Enter</span>
                    </div>
                    <div class="context-menu-item" data-action="open-with">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                        </div>
                        <span>Open With...</span>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="cut">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="6" cy="6" r="3"></circle>
                                <circle cx="6" cy="18" r="3"></circle>
                                <line x1="6" y1="9" x2="6" y2="15"></line>
                                <path d="M20 4l-7 7m0 0l7 7m-7-7v12"></path>
                            </svg>
                        </div>
                        <span>Cut</span>
                        <span class="context-menu-shortcut">Ctrl+X</span>
                    </div>
                    <div class="context-menu-item" data-action="copy">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </div>
                        <span>Copy</span>
                        <span class="context-menu-shortcut">Ctrl+C</span>
                    </div>
                    <div class="context-menu-item" data-action="duplicate">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </div>
                        <span>Duplicate</span>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="rename">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </div>
                        <span>Rename</span>
                        <span class="context-menu-shortcut">F2</span>
                    </div>
                    <div class="context-menu-item" data-action="download">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </div>
                        <span>Download</span>
                    </div>
                    <div class="context-menu-item" data-action="properties">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="12" y1="16" x2="12" y2="12"></line>
                                <line x1="12" y1="8" x2="12.01" y2="8"></line>
                            </svg>
                        </div>
                        <span>Properties</span>
                    </div>
                    ${type === 'file' && isImageFile(name) ? `
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="set-background">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                        </div>
                        <span>Set As Background</span>
                    </div>
                    ` : ''}
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="delete">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </div>
                        <span>Delete</span>
                        <span class="context-menu-shortcut">Del</span>
                    </div>
                `;
            }
            
            menu.innerHTML = menuHTML;
            document.body.appendChild(menu);
            
            // Handle menu item clicks
            menu.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    menu.remove();
                    
                    // Single-item actions (operate on just the right-clicked item)
                    if (action === 'open') {
                        const firstItem = itemsToOperate[0];
                        if (firstItem.type === 'folder') {
                            navigateToPath(firstItem.path);
                        } else {
                            openFile(firstItem.path, firstItem.name);
                        }
                    } else if (action === 'open-new-tab') {
                        // Open folder in new tab
                        const firstItem = itemsToOperate[0];
                        if (firstItem.type === 'folder') {
                            // Get the Files window that contains this context menu
                            const filesWindow = window.closest('[data-file-explorer-window]') || window;
                            
                            // Check if createTab function is available on the window
                            if (filesWindow.createTab && typeof filesWindow.createTab === 'function') {
                                // Determine location from path
                                const loggedInUser = localStorage.getItem('loggedInUser');
                                let currentUsername = null;
                                if (loggedInUser) {
                                    try {
                                        const user = JSON.parse(loggedInUser);
                                        currentUsername = user.name;
                                    } catch (e) {
                                        console.warn('Could not parse logged-in user:', e);
                                    }
                                }
                                
                                const pathToLocation = {
                                    '/': 'disk-c',
                                    '/Desktop': 'desktop',
                                    '/Downloads': 'downloads',
                                    '/Documents': 'documents',
                                    '/Pictures': 'pictures',
                                    '/Music': 'music',
                                    '/Videos': 'videos'
                                };
                                
                                if (currentUsername) {
                                    pathToLocation[`/Users/${currentUsername}/Desktop`] = 'desktop';
                                    pathToLocation[`/Users/${currentUsername}/Downloads`] = 'downloads';
                                    pathToLocation[`/Users/${currentUsername}/Documents`] = 'documents';
                                    pathToLocation[`/Users/${currentUsername}/Pictures`] = 'pictures';
                                    pathToLocation[`/Users/${currentUsername}/Music`] = 'music';
                                    pathToLocation[`/Users/${currentUsername}/Videos`] = 'videos';
                                    pathToLocation[`/Users/${currentUsername}/Trash`] = 'trash';
                                }
                                
                                const location = pathToLocation[firstItem.path] || null;
                                
                                // Create new tab - it will automatically navigate to the path when set as active
                                filesWindow.createTab(firstItem.path, location);
                            } else {
                                // Fallback: if createTab is not available, just navigate in current tab
                                if (window.navigateToPath && typeof window.navigateToPath === 'function') {
                                    window.navigateToPath(firstItem.path);
                                } else {
                                    navigateToPath(firstItem.path);
                                }
                            }
                        }
                    } else if (action === 'open-new-window') {
                        // Open folder in new Files app window
                        const firstItem = itemsToOperate[0];
                        if (firstItem.type === 'folder') {
                            const openFileExplorer = initFileExplorer();
                            if (openFileExplorer) {
                                openFileExplorer(firstItem.path);
                            }
                        }
                    } else if (action === 'open-with') {
                        // For now, just open normally
                        const firstItem = itemsToOperate[0];
                        openFile(firstItem.path, firstItem.name);
                    } else if (action === 'cut') {
                        // For cut/copy, only support single item (can be extended later)
                        const firstItem = itemsToOperate[0];
                        const fs = await initFileSystem();
                        const itemObj = firstItem.type === 'folder' ? await fs.getFolder(firstItem.path) : await fs.getFile(firstItem.path);
                        clipboard = { type: 'cut', item: itemObj, path: firstItem.path, name: firstItem.name, itemType: firstItem.type };
                    } else if (action === 'copy') {
                        // For cut/copy, only support single item (can be extended later)
                        const firstItem = itemsToOperate[0];
                        const fs = await initFileSystem();
                        const itemObj = firstItem.type === 'folder' ? await fs.getFolder(firstItem.path) : await fs.getFile(firstItem.path);
                        clipboard = { type: 'copy', item: itemObj, path: firstItem.path, name: firstItem.name, itemType: firstItem.type };
                    } else if (action === 'duplicate') {
                        // Duplicate operates on all selected items
                        try {
                            const fs = await initFileSystem();
                            for (const itemData of itemsToOperate) {
                                const parentPath = fs.getParentPath(itemData.path);
                                let newName = itemData.name;
                                let counter = 1;
                                
                                // Find unique name
                                while (true) {
                                    const testPath = parentPath === '/' ? `/${newName}` : `${parentPath}/${newName}`;
                                    const exists = itemData.type === 'folder' ? await fs.getFolder(testPath) : await fs.getFile(testPath);
                                    if (!exists) break;
                                    
                                    const ext = itemData.name.includes('.') ? itemData.name.substring(itemData.name.lastIndexOf('.')) : '';
                                    const base = itemData.name.includes('.') ? itemData.name.substring(0, itemData.name.lastIndexOf('.')) : itemData.name;
                                    newName = `${base} (${counter})${ext}`;
                                    counter++;
                                }
                                
                                if (itemData.type === 'folder') {
                                    await fs.createFolder(parentPath, newName);
                                    // Copy folder contents recursively
                                    const sourceDir = await fs.listDirectory(itemData.path);
                                    const newPath = parentPath === '/' ? `/${newName}` : `${parentPath}/${newName}`;
                                    
                                    // Copy files
                                    for (const file of sourceDir.files) {
                                        const content = await fs.getFileContent(file.path);
                                        const relativePath = file.path.replace(itemData.path, '');
                                        await fs.createFile(newPath + relativePath, file.name, content);
                                    }
                                    
                                    // Copy subfolders recursively
                                    for (const folder of sourceDir.folders) {
                                        await duplicateFolderRecursive(fs, folder.path, newPath);
                                    }
                                } else {
                                    const content = await fs.getFileContent(itemData.path);
                                    await fs.createFile(parentPath, newName, content);
                                }
                            }
                            
                                // Refresh both Files windows and desktop icons
                                await refreshFileSystemViews(parentPath);
                            } catch (error) {
                                alert('Error duplicating: ' + error.message);
                            }
                    } else if (action === 'rename') {
                        // Rename operates on just the right-clicked item
                        const firstItem = itemsToOperate[0];
                        // Show custom rename dialog centered in Files window
                        const currentName = firstItem.name;
                        const newName = await showRenameDialog(currentName, 'Rename', window);
                        if (newName && newName !== currentName) {
                            if (/[<>:"/\\|?*]/.test(newName)) {
                                showNotification('File name cannot contain: < > : " / \\ | ? *', 'error');
                                return;
                            }
                            try {
                                const fs = await initFileSystem();
                                const parentPath = firstItem.path.substring(0, firstItem.path.lastIndexOf('/')) || '/';
                                await fs.rename(firstItem.path, newName);
                                // Refresh both Files windows and desktop icons
                                await refreshFileSystemViews(parentPath);
                            } catch (error) {
                                showNotification('Error renaming: ' + error.message, 'error');
                            }
                        }
                    } else if (action === 'download') {
                        // Download operates on all selected items
                        for (const itemData of itemsToOperate) {
                            downloadFile(itemData.path, itemData.name);
                        }
                    } else if (action === 'properties') {
                        // Properties operates on just the right-clicked item
                        const firstItem = itemsToOperate[0];
                        // NOTE: In this scope `window` is the Files window DOM element (not the global Window),
                        // so use `globalThis` for global functions.
                        if (typeof globalThis.showProperties === 'function') {
                            globalThis.showProperties(firstItem.path, firstItem.type, firstItem.name);
                        }
                    } else if (action === 'set-background') {
                        // Set As Background - only for image files
                        const firstItem = itemsToOperate[0];
                        if (firstItem.type === 'file' && isImageFile(firstItem.name)) {
                            try {
                                await setCustomBackground(firstItem.path);
                            } catch (error) {
                                alert('Error setting background: ' + error.message);
                            }
                        }
                    } else if (action === 'restore') {
                        // Restore operates on all selected items
                        try {
                            const fs = await initFileSystem();
                            const restoredPaths = []; // Track where files were restored to
                            
                            for (const itemData of itemsToOperate) {
                                // Get the file/folder to find its original path before restoring
                                const item = itemData.type === 'folder' 
                                    ? await fs.getFolder(itemData.path)
                                    : await fs.getFile(itemData.path);
                                
                                if (item && item.originalPath) {
                                    // Store the original path (where it will be restored to)
                                    const originalParent = item.originalParent || '/';
                                    restoredPaths.push(originalParent);
                                    
                                    // Restore the item
                                    if (itemData.type === 'folder') {
                                        await fs.restoreFolder(itemData.path);
                                    } else {
                                        await fs.restoreFile(itemData.path);
                                    }
                                }
                            }
                            
                            // Refresh the current view (Trash view) to remove restored items
                            if (window.refreshCurrentView && typeof window.refreshCurrentView === 'function') {
                                await window.refreshCurrentView();
                            } else {
                                await refreshCurrentView();
                            }
                            
                            // Refresh all Files windows and desktop icons for each restored location
                            const uniquePaths = [...new Set(restoredPaths)];
                            for (const path of uniquePaths) {
                                await refreshFileSystemViews(path);
                            }
                            
                            // Also refresh Trash view in case we're viewing it
                            const loggedInUser = localStorage.getItem('loggedInUser');
                            if (loggedInUser) {
                                try {
                                    const user = JSON.parse(loggedInUser);
                                    const trashPath = `/Users/${user.name}/Trash`;
                                    await refreshFileSystemViews(trashPath);
                                } catch (e) {
                                    // Ignore errors
                                }
                            }
                        } catch (error) {
                            alert('Error restoring: ' + error.message);
                        }
                    } else if (action === 'delete-permanent') {
                        // Delete permanent operates on all selected items
                        const count = itemsToOperate.length;
                        const message = count > 1 
                            ? `Are you sure you want to permanently delete ${count} items? This cannot be undone.`
                            : `Are you sure you want to permanently delete "${itemsToOperate[0].name}"? This cannot be undone.`;
                        
                        const confirmed = await showConfirmationDialog(message, 'Delete', window);
                        if (confirmed) {
                            try {
                                const fs = await initFileSystem();
                                for (const itemData of itemsToOperate) {
                                    if (itemData.type === 'folder') {
                                        await fs.deleteFolder(itemData.path);
                                    } else {
                                        await fs.deleteFile(itemData.path);
                                        // Track if README.txt was permanently deleted to prevent recreation on refresh
                                        const trashPath = getUserTrashPath();
                                        if (itemData.path === `${trashPath}/README.txt` || itemData.path === '/Documents/README.txt' || itemData.name === 'README.txt') {
                                            localStorage.setItem('readme_txt_permanently_deleted', 'true');
                                        }
                                    }
                                }
                                await refreshCurrentView();
                            } catch (error) {
                                alert('Error deleting: ' + error.message);
                            }
                        }
                    } else if (action === 'delete') {
                        // Delete operates on all selected items
                        const count = itemsToOperate.length;
                        const message = count > 1
                            ? `Are you sure you want to delete ${count} items?`
                            : `Are you sure you want to delete "${itemsToOperate[0].name}"?`;
                        
                        const confirmed = await showConfirmationDialog(message, 'Delete', window);
                        if (confirmed) {
                            try {
                                const fs = await initFileSystem();
                                // Ensure Trash folder exists
                                const trashPath = getUserTrashPath();
                                let trashFolder = await fs.getFolder(trashPath);
                                if (!trashFolder) {
                                    const pathParts = trashPath.split('/').filter(p => p);
                                    const folderName = pathParts.pop();
                                    const parentPath = '/' + pathParts.join('/');
                                    await fs.createFolder(parentPath, folderName);
                                }
                                
                                for (const itemData of itemsToOperate) {
                                    if (itemData.type === 'folder') {
                                        await fs.moveFolderToTrash(itemData.path);
                                    } else {
                                        await fs.moveToTrash(itemData.path);
                                    }
                                }
                                
                                // Refresh the current Files window immediately
                                if (window.refreshCurrentView && typeof window.refreshCurrentView === 'function') {
                                    await window.refreshCurrentView();
                                }
                                
                                // Refresh both Files windows and desktop icons for the source location
                                const parentPath = itemsToOperate[0]?.path ? itemsToOperate[0].path.substring(0, itemsToOperate[0].path.lastIndexOf('/')) || '/' : null;
                                await refreshFileSystemViews(parentPath);
                                
                                // Also refresh Trash view so deleted items appear immediately
                                await refreshFileSystemViews(trashPath);
                            } catch (error) {
                                alert('Error deleting: ' + error.message);
                            }
                        }
                    }
                });
            });
            
            // Close menu when clicking outside or pressing Escape
            const closeMenu = () => {
                menu.remove();
                document.removeEventListener('click', closeMenu);
                document.removeEventListener('keydown', escapeHandler);
            };
            
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeMenu();
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu, { once: true });
                document.addEventListener('keydown', escapeHandler, { once: true });
            }, 0);
        }
        
        async function duplicateFolderRecursive(fs, sourcePath, destParentPath) {
            const folder = await fs.getFolder(sourcePath);
            const folderName = folder.name;
            await fs.createFolder(destParentPath, folderName);
            const newPath = destParentPath === '/' ? `/${folderName}` : `${destParentPath}/${folderName}`;
            
            const dir = await fs.listDirectory(sourcePath);
            
            // Copy files
            for (const file of dir.files) {
                const content = await fs.getFileContent(file.path);
                await fs.createFile(newPath, file.name, content);
            }
            
            // Copy subfolders
            for (const subFolder of dir.folders) {
                await duplicateFolderRecursive(fs, subFolder.path, newPath);
            }
        }
        
        // Save all Properties windows state
        function savePropertiesWindowsState() {
            const propertiesWindows = Array.from(document.querySelectorAll('[data-properties-window]'));
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const minLeft = 0;
            
            const windowsState = propertiesWindows.map(window => {
                const isMinimized = window.style.display === 'none';
                
                // Get current position and dimensions
                let left = parseInt(window.style.left) || window.offsetLeft || 400;
                let top = parseInt(window.style.top) || window.offsetTop || 150;
                let width = parseInt(window.style.width) || window.offsetWidth || 550;
                let height = parseInt(window.style.height) || window.offsetHeight || 400;
                
                // Sanitize values before saving
                const maxLeft = viewportWidth - width;
                if (left > maxLeft || left + width > viewportWidth) {
                    left = Math.max(minLeft, maxLeft);
                }
                if (left < minLeft) {
                    left = minLeft;
                }
                
                // Ensure width isn't too large
                if (width > viewportWidth - minLeft) {
                    width = Math.max(550, viewportWidth - minLeft - 20);
                }
                
                return {
                    windowId: window.id,
                    path: window.dataset.propertiesPath || '',
                    type: window.dataset.propertiesType || '',
                    name: window.dataset.propertiesName || '',
                    left: left + 'px',
                    top: top + 'px',
                    width: width + 'px',
                    height: height + 'px',
                    minimized: isMinimized
                };
            });
            localStorage.setItem('propertiesWindowsState', JSON.stringify(windowsState));
        }
        
        // Make savePropertiesWindowsState accessible globally
        window.savePropertiesWindowsState = savePropertiesWindowsState;
        
        // Get saved Properties windows state
        function getSavedPropertiesWindowsState() {
            const saved = localStorage.getItem('propertiesWindowsState');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    return [];
                }
            }
            return [];
        }
        
        async function showProperties(path, type, name, restoreState = null) {
            try {
                const fs = await initFileSystem();
                let item, size = 0, created, modified;
                
                if (type === 'folder') {
                    item = await fs.getFolder(path);
                    created = new Date(item.created);
                    modified = new Date(item.modified);
                    
                    // Calculate folder size (count files recursively)
                    const countSize = async (folderPath) => {
                        const dir = await fs.listDirectory(folderPath);
                        let totalSize = 0;
                        for (const file of dir.files) {
                            totalSize += file.size || 0;
                        }
                        for (const folder of dir.folders) {
                            totalSize += await countSize(folder.path);
                        }
                        return totalSize;
                    };
                    size = await countSize(path);
                } else {
                    item = await fs.getFile(path);
                    size = item.size || 0;
                    created = new Date(item.created);
                    modified = new Date(item.modified);
                }
                
                const formatSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
                };
                
                const formatDate = (date) => {
                    return date.toLocaleString();
                };
                
                const propsHTML = `
                    <div style="padding: 20px; max-width: 500px;">
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <div>
                                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Name</div>
                                <div style="color: rgba(255,255,255,0.9);">${name}</div>
                            </div>
                            <div>
                                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Type</div>
                                <div style="color: rgba(255,255,255,0.9);">${type === 'folder' ? 'Folder' : 'File'}</div>
                            </div>
                            <div>
                                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Size</div>
                                <div style="color: rgba(255,255,255,0.9);">${formatSize(size)}</div>
                            </div>
                            <div>
                                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Created</div>
                                <div style="color: rgba(255,255,255,0.9);">${formatDate(created)}</div>
                            </div>
                            <div>
                                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Modified</div>
                                <div style="color: rgba(255,255,255,0.9);">${formatDate(modified)}</div>
                            </div>
                            <div>
                                <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 4px;">Location</div>
                                <div style="color: rgba(255,255,255,0.9); font-size: 12px;">${path}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create properties window
                const windowsContainer = document.getElementById('windows-container');
                const propsWindow = document.createElement('div');
                propsWindow.className = 'window';
                propsWindow.id = restoreState ? restoreState.windowId : `properties-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                propsWindow.setAttribute('data-properties-window', 'true');
                propsWindow.dataset.propertiesPath = path;
                propsWindow.dataset.propertiesType = type;
                propsWindow.dataset.propertiesName = name;
                
                // Use restore state if provided, otherwise use defaults
                if (restoreState) {
                    const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
                    const minLeft = 0;
                    
                    let savedLeft = parseInt(restoreState.left) || 400;
                    let savedTop = parseInt(restoreState.top) || 150;
                    let savedWidth = parseInt(restoreState.width) || 550;
                    let savedHeight = parseInt(restoreState.height) || 400;
                    
                    // Validate saved width/height
                    if (savedWidth > viewportWidth - minLeft) {
                        savedWidth = Math.max(550, viewportWidth - minLeft - 20);
                    }
                    
                    // Validate saved position
                    const maxLeft = viewportWidth - savedWidth;
                    if (savedLeft > maxLeft || savedLeft + savedWidth > viewportWidth) {
                        savedLeft = Math.max(minLeft, maxLeft);
                    }
                    if (savedLeft < minLeft) {
                        savedLeft = minLeft;
                    }
                    
                    propsWindow.style.left = savedLeft + 'px';
                    propsWindow.style.top = savedTop + 'px';
                    propsWindow.style.width = savedWidth + 'px';
                    propsWindow.style.height = savedHeight + 'px';
                } else {
                    propsWindow.style.left = '400px';
                    propsWindow.style.top = '150px';
                    propsWindow.style.width = '550px';
                    propsWindow.style.height = 'auto';
                }
                propsWindow.style.minHeight = '400px';
                
                // Properties window icon SVG (info circle icon)
                const propertiesIconSvg = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="16" x2="12" y2="12"></line>
                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                </svg>`;
                
                propsWindow.innerHTML = `
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="12" y1="16" x2="12" y2="12"></line>
                                <line x1="12" y1="8" x2="12.01" y2="8"></line>
                            </svg>
                            Properties
                        </div>
                        <div class="window-controls">
                            <div class="window-control minimize">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </div>
                            <div class="window-control maximize">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                                </svg>
                            </div>
                            <div class="window-control close">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="window-content">${propsHTML}</div>
                `;
                
                windowsContainer.appendChild(propsWindow);
                
                // Setup window controls with app bar integration
                const minimizeBtn = propsWindow.querySelector('.window-control.minimize');
                const maximizeBtn = propsWindow.querySelector('.window-control.maximize');
                const closeBtn = propsWindow.querySelector('.window-control.close');
                
                if (minimizeBtn) {
                    minimizeBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const isMinimized = propsWindow.style.display === 'none';
                        if (isMinimized) {
                            propsWindow.style.display = 'flex';
                            focusWindow(propsWindow);
                        } else {
                            propsWindow.style.display = 'none';
                        }
                        updateWindowAppBarState(propsWindow, !isMinimized, isMinimized);
                        savePropertiesWindowsState();
                    });
                }
                
                if (maximizeBtn) {
                    let previousSize = null;
                    let isMaximized = false;
                    
                    maximizeBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        if (isMaximized) {
                            // Restore to previous size
                            if (previousSize) {
                                propsWindow.style.width = previousSize.width;
                                propsWindow.style.height = previousSize.height;
                                propsWindow.style.left = previousSize.left;
                                propsWindow.style.top = previousSize.top;
                            } else {
                                // Fallback to defaults
                                propsWindow.style.width = '550px';
                                propsWindow.style.height = 'auto';
                                propsWindow.style.minHeight = '400px';
                                propsWindow.style.left = '400px';
                                propsWindow.style.top = '150px';
                            }
                            isMaximized = false;
                        } else {
                            // Save current position before maximizing
                            previousSize = {
                                width: propsWindow.style.width || propsWindow.offsetWidth + 'px',
                                height: propsWindow.style.height || propsWindow.offsetHeight + 'px',
                                left: propsWindow.style.left || propsWindow.offsetLeft + 'px',
                                top: propsWindow.style.top || propsWindow.offsetTop + 'px'
                            };
                            maximizeWindowToBounds(propsWindow);
                            isMaximized = true;
                        }
                        savePropertiesWindowsState();
                    });
                }
                
                if (closeBtn) {
                    closeBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const windowId = propsWindow.id;
                        propsWindow.remove();
                        if (windowId) {
                            removeWindowFromAppBar(windowId);
                        }
                        savePropertiesWindowsState();
                    });
                }
                
                // Add to app bar
                addWindowToAppBar(propsWindow, {
                    iconSvg: propertiesIconSvg,
                    onIconClick: function() {
                        const isMinimized = propsWindow.style.display === 'none';
                        if (isMinimized) {
                            propsWindow.style.display = 'flex';
                            focusWindow(propsWindow);
                        } else {
                            propsWindow.style.display = 'none';
                        }
                        updateWindowAppBarState(propsWindow, !isMinimized, isMinimized);
                        savePropertiesWindowsState();
                    }
                });
                
                makeWindowDraggable(propsWindow, { onDragEnd: savePropertiesWindowsState });
                makeWindowResizable(propsWindow, { onResize: savePropertiesWindowsState });
                
                // Restore minimized state if provided
                if (restoreState && restoreState.minimized) {
                    propsWindow.style.display = 'none';
                    updateWindowAppBarState(propsWindow, false, true);
                }
                
                focusWindow(propsWindow);
                savePropertiesWindowsState();
            } catch (error) {
                alert('Error loading properties: ' + error.message);
            }
        }

        // Properties window opener is global (`window.showProperties`) and defined outside Files,
        // so Desktop + Files always use the same implementation.
        
        // Restore all Properties windows on page load
        async function restorePropertiesWindows() {
            try {
                const savedWindowsState = getSavedPropertiesWindowsState();
                if (savedWindowsState && savedWindowsState.length > 0) {
                    // Wait for file system to be ready
                    const fs = await initFileSystem();
                    if (!fs || !fs.db) {
                        // Retry after a delay if file system isn't ready
                        setTimeout(restorePropertiesWindows, 100);
                        return;
                    }
                    
                    // Restore all saved properties windows
                    for (const state of savedWindowsState) {
                        if (state.path && state.type && state.name) {
                            try {
                                // Verify the file/folder still exists before restoring
                                if (state.type === 'folder') {
                                    await fs.getFolder(state.path);
                                } else {
                                    await fs.getFile(state.path);
                                }
                                // File/folder exists, restore the properties window
                                if (typeof globalThis.showProperties === 'function') {
                                    await globalThis.showProperties(state.path, state.type, state.name, state);
                                }
                            } catch (error) {
                                // File/folder doesn't exist, skip restoring this window
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error restoring properties windows:', error);
            }
        }
        
        // Make restorePropertiesWindows accessible globally
        window.restorePropertiesWindows = restorePropertiesWindows;
        
        async function downloadFile(path, name) {
            try {
                const fs = await initFileSystem();
                const content = await fs.getFileContent(path);
                
                if (content instanceof Blob) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = name;
                    a.click();
                    URL.revokeObjectURL(url);
                } else {
                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = name;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            } catch (error) {
                alert('Error downloading file: ' + error.message);
            }
        }
        
        async function openFileEditor(path, name) {
            // Use the unified openEditorWindow function
            await openEditorWindow(path, name);
        }
        
        // Helper function to get path for a location
        function getPathForLocation(location) {
            // Get currently logged-in user to determine user-specific folder paths
            let currentUsername = null;
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    currentUsername = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }
            
            // Fallback: if localStorage parsing fails, try reading the username from the sidebar label
            // (it is set earlier in this function).
            if (!currentUsername) {
                const nameEl = window.querySelector('#user-home-sidebar-name');
                const label = nameEl ? String(nameEl.textContent || '').trim() : '';
                if (label && label.toLowerCase() !== 'user') {
                    currentUsername = label;
                }
            }
            
            // Map location to path - user-specific folders point to /Users/[username]/[folder]
            const locationToPath = {
                'home': '/',
                // If we can't resolve the user, treat as invalid (better than silently dropping into '/')
                'user-home': currentUsername ? `/Users/${currentUsername}` : null,
                'desktop': currentUsername ? `/Users/${currentUsername}/Desktop` : null,
                'downloads': currentUsername ? `/Users/${currentUsername}/Downloads` : null,
                'documents': currentUsername ? `/Users/${currentUsername}/Documents` : null,
                'pictures': currentUsername ? `/Users/${currentUsername}/Pictures` : null,
                'music': currentUsername ? `/Users/${currentUsername}/Music` : null,
                'videos': currentUsername ? `/Users/${currentUsername}/Videos` : null,
                'trash': currentUsername ? `/Users/${currentUsername}/Trash` : null,
                'disk-c': '/'
            };
            
            return locationToPath[location] || null;
        }
        
        // Add click handlers and drag-and-drop handlers to all sidebar items
        sidebarItems.forEach(item => {
            // Click handler
            item.addEventListener('click', function() {
                const location = this.dataset.location;
                if (location) {
                    updateContent(location);
                }
            });
            
            // Drag and drop handlers
            const location = item.dataset.location;
            if (location && location !== 'trash') { // Don't allow dropping into trash via sidebar
                // Dragover - show visual feedback
                item.addEventListener('dragover', (e) => {
                    // Don't handle if dragging over the empty trash button
                    if (e.target.closest('.sidebar-empty-trash-btn')) {
                        return;
                    }
                    
                    // Only handle if dragging from Files app or Desktop (use global flags; `window` param is the window element)
                    if (globalThis.isDraggingFromFilesApp || globalThis.isDraggingFromDesktop) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'move';
                        // Add visual feedback
                        item.classList.add('drag-over-sidebar');
                    }
                });
                
                // Dragleave - remove visual feedback
                item.addEventListener('dragleave', (e) => {
                    // Only remove highlight if leaving the item itself
                    if (e.target === item || !item.contains(e.relatedTarget)) {
                        item.classList.remove('drag-over-sidebar');
                    }
                });
                
                // Drop - move file/folder to this location
                item.addEventListener('drop', async (e) => {
                    if (!globalThis.isDraggingFromFilesApp && !globalThis.isDraggingFromDesktop) return;
                    
                    // Don't handle if dropping on the empty trash button
                    if (e.target.closest('.sidebar-empty-trash-btn')) {
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    item.classList.remove('drag-over-sidebar');
                    
                    const sourcePath = e.dataTransfer.getData('text/plain');
                    const sourceType = e.dataTransfer.getData('item-type');
                    
                    if (sourcePath) {
                        try {
                            const fs = await initFileSystem();
                            const targetPath = getPathForLocation(location);
                            
                            if (!targetPath) {
                                alert('Invalid location');
                                return;
                            }

                            // If the dragged item is a protected sidebar folder, silently ignore the drop.
                            // This must happen BEFORE the "move into itself" checks to avoid showing prompts
                            // when dragging e.g. Documents into the Documents sidebar item.
                            // (User requested: no dialog when attempting to move protected folders via sidebar.)
                            if (sourceType === 'folder' && isProtectedSidebarFolder(sourcePath)) {
                                globalThis.isDraggingFromFilesApp = false;
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            
                            // Don't move if already in target folder
                            const sourceParent = fs.getParentPath(sourcePath);
                            if (sourceParent === targetPath) {
                                return;
                            }
                            
                            // Prevent moving a folder into itself or its children
                            // Check if source and target are the same (e.g., dragging Documents into Documents sidebar)
                            if (sourceType === 'folder' && sourcePath === targetPath) {
                                alert('Cannot move a folder into itself');
                                globalThis.isDraggingFromFilesApp = false;
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            
                            // Prevent moving a folder into its children
                            if (sourceType === 'folder' && targetPath.startsWith(sourcePath + '/')) {
                                alert('Cannot move a folder into itself or its children');
                                globalThis.isDraggingFromFilesApp = false;
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            
                            // Ensure target folder exists
                            if (targetPath !== '/') {
                                let targetFolder = await fs.getFolder(targetPath);
                                if (!targetFolder) {
                                    const pathParts = targetPath.split('/').filter(p => p);
                                    const folderName = pathParts.pop();
                                    const parentPath = '/' + pathParts.join('/');
                                    await fs.createFolder(parentPath, folderName);
                                }
                            }
                            
                            // Move item to target location
                            try {
                                await fs.move(sourcePath, targetPath);
                            } catch (err) {
                                // For Desktop -> Files drags, "keep both" by auto-renaming on conflict
                                if (globalThis.isDraggingFromDesktop && err && err.message && err.message.includes('already exists')) {
                                    const desiredName = sourcePath.split('/').pop();
                                    const newName = await getNonConflictingName(fs, targetPath, desiredName, sourceType);
                                    await fs.move(sourcePath, targetPath, newName);
                                } else {
                                    throw err;
                                }
                            }
                            
                            // Immediately hide the dragged icon if it was from desktop
                            if (globalThis.isDraggingFromDesktop) {
                                const draggedIcon = document.querySelector(`.desktop-icon[data-file-path="${sourcePath}"]`);
                                if (draggedIcon) {
                                    draggedIcon.style.display = 'none';
                                    draggedIcon.classList.remove('dragging');
                                }
                                globalThis.isDraggingFromDesktop = false;
                            }
                            
                            // Refresh current view
                            await refreshCurrentView();
                            
                            // Refresh desktop icons if item was moved from desktop
                            if (window.refreshDesktopIcons) {
                                await window.refreshDesktopIcons();
                            }
                            
                            // Reset drag flags
                            globalThis.isDraggingFromFilesApp = false;
                            globalThis.isDraggingFromDesktop = false;
                        } catch (error) {
                            // Don't show a dialog for protected sidebar folders; just ignore the drop.
                            const msg = (error && error.message) ? error.message : String(error || '');
                            if (msg.includes('Sidebar folders cannot be moved') || msg.includes('Cannot move this folder')) {
                                globalThis.isDraggingFromFilesApp = false;
                                globalThis.isDraggingFromDesktop = false;
                                return;
                            }
                            alert('Error moving item: ' + msg);
                            globalThis.isDraggingFromFilesApp = false;
                            globalThis.isDraggingFromDesktop = false;
                        }
                    }
                });
            }
        });
        
        // Deselect items when clicking on empty space
        itemsContainer.addEventListener('click', (e) => {
            // Only deselect if clicking directly on the container (not on a file-item or its children)
            if (e.target === itemsContainer || !e.target.closest('.file-item')) {
                const allItems = itemsContainer.querySelectorAll('.file-item');
                allItems.forEach(item => item.classList.remove('selected'));
                // Hide size display when nothing is selected
                if (sizeDisplay) {
                    sizeDisplay.style.display = 'none';
                    if (sizeText) sizeText.textContent = '';
                    if (fileCountText) fileCountText.textContent = '';
                }
            }
        });
        
        // Allow dropping files/folders into the current directory (itemsContainer)
        // Ensure itemsContainer exists before attaching handlers
        if (itemsContainer) {
            // Remove any existing handlers first (in case setupFileExplorerSidebar is called multiple times)
            if (itemsContainer._dragOverHandler) {
                itemsContainer.removeEventListener('dragover', itemsContainer._dragOverHandler);
                itemsContainer.removeEventListener('dragleave', itemsContainer._dragLeaveHandler);
                itemsContainer.removeEventListener('drop', itemsContainer._dropHandler);
            }
        
        const containerDragOverHandler = (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'move';
            // Only highlight container if not over a file-item
            if (!e.target.closest('.file-item')) {
                itemsContainer.classList.add('drag-over-container');
            }
        };
        const containerDragLeaveHandler = (e) => {
            // Only remove highlight if leaving the container itself
            if (e.target === itemsContainer) {
                itemsContainer.classList.remove('drag-over-container');
            }
        };
        const containerDropHandler = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            itemsContainer.classList.remove('drag-over-container');
            
            // Only handle if dropping directly on container (not on a file-item)
            if (e.target === itemsContainer || !e.target.closest('.file-item')) {
                const sourcePath = e.dataTransfer.getData('text/plain');
                
                if (sourcePath) {
                    // Get the parent path of the source to check if it's already in currentPath
                    try {
                        const fs = await initFileSystem();
                        const sourceParent = fs.getParentPath(sourcePath);
                        const destPath = getCurrentPath();
                        
                        // Don't move if already in the same location
                        if (sourceParent === destPath) {
                            return;
                        }
                        
                        // Prevent moving a folder into itself or its children
                        if (destPath.startsWith(sourcePath + '/')) {
                            alert('Cannot move a folder into itself or its children');
                            return;
                        }
                        
                        await fs.move(sourcePath, destPath);
                        await refreshCurrentView();
                    } catch (error) {
                        alert('Error moving item: ' + error.message);
                    }
                }
            }
        };
        
            // Store handlers on the container for potential removal
            itemsContainer._dragOverHandler = containerDragOverHandler;
            itemsContainer._dragLeaveHandler = containerDragLeaveHandler;
            itemsContainer._dropHandler = containerDropHandler;
            
            // Attach the handlers
            itemsContainer.addEventListener('dragover', containerDragOverHandler);
            itemsContainer.addEventListener('dragleave', containerDragLeaveHandler);
            itemsContainer.addEventListener('drop', containerDropHandler);
        }
        
        // Handle Delete key to delete selected files/folders
        const deleteKeyHandler = async (e) => {
            // Only handle Delete key when Files window is focused and visible, and not typing in input fields
            if (e.key === 'Delete' && 
                window.style.display !== 'none' && 
                document.body.contains(window) &&
                !e.target.matches('input, textarea, [contenteditable="true"]')) {
                
                const selectedItems = itemsContainer ? Array.from(itemsContainer.querySelectorAll('.file-item.selected')) : [];
                if (selectedItems.length > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const tab = getActiveTab();
                    const currentPath = tab ? tab.currentPath : '/';
                    const trashPath = getUserTrashPath();
                    const isInTrash = currentPath === trashPath;
                    
                    // Build array of items to delete
                    const itemsToDelete = selectedItems.map(item => ({
                        path: item.dataset.path,
                        type: item.dataset.type,
                        name: item.querySelector('.file-name')?.textContent || item.dataset.path.split('/').pop()
                    }));
                    
                    // Check if any of the selected items are protected folders
                    // If so, silently ignore the Delete key press (no dialogs, no action)
                    const hasProtectedFolder = itemsToDelete.some(item => 
                        item.type === 'folder' && isProtectedSidebarFolder(item.path)
                    );
                    
                    if (hasProtectedFolder) {
                        // Silently ignore Delete key for protected folders - do nothing
                        return;
                    }
                    
                    if (isInTrash) {
                        // Permanent delete
                        const count = itemsToDelete.length;
                        const message = count > 1 
                            ? `Are you sure you want to permanently delete ${count} items? This cannot be undone.`
                            : `Are you sure you want to permanently delete "${itemsToDelete[0].name}"? This cannot be undone.`;
                        
                        const confirmed = await showConfirmationDialog(message, 'Delete Permanently');
                        if (confirmed) {
                            try {
                                const fs = await initFileSystem();
                                for (const itemData of itemsToDelete) {
                                    if (itemData.type === 'folder') {
                                        await fs.deleteFolder(itemData.path);
                                    } else {
                                        await fs.deleteFile(itemData.path);
                                        // Track if README.txt was permanently deleted to prevent recreation on refresh
                                        const trashPath = getUserTrashPath();
                                        if (itemData.path === `${trashPath}/README.txt` || itemData.name === 'README.txt') {
                                            localStorage.setItem('readme_txt_permanently_deleted', 'true');
                                        }
                                    }
                                }
                                await refreshCurrentView();
                            } catch (error) {
                                alert('Error deleting: ' + error.message);
                            }
                        }
                    } else {
                        // Move to trash
                        const count = itemsToDelete.length;
                        const message = count > 1
                            ? `Are you sure you want to delete ${count} items?`
                            : `Are you sure you want to delete "${itemsToDelete[0].name}"?`;
                        
                        const confirmed = await showConfirmationDialog(message, 'Delete');
                        if (confirmed) {
                            try {
                                const fs = await initFileSystem();
                                // Ensure Trash folder exists
                                const trashPath = getUserTrashPath();
                                let trashFolder = await fs.getFolder(trashPath);
                                if (!trashFolder) {
                                    const pathParts = trashPath.split('/').filter(p => p);
                                    const folderName = pathParts.pop();
                                    const parentPath = '/' + pathParts.join('/');
                                    await fs.createFolder(parentPath, folderName);
                                }
                                
                                for (const itemData of itemsToDelete) {
                                    if (itemData.type === 'folder') {
                                        await fs.moveFolderToTrash(itemData.path);
                                    } else {
                                        await fs.moveToTrash(itemData.path);
                                    }
                                }
                                
                                // Refresh the current Files window immediately
                                if (window.refreshCurrentView && typeof window.refreshCurrentView === 'function') {
                                    await window.refreshCurrentView();
                                } else {
                                    await refreshCurrentView();
                                }
                                
                                // Refresh both Files windows and desktop icons for the source location
                                const parentPath = itemsToDelete[0]?.path ? itemsToDelete[0].path.substring(0, itemsToDelete[0].path.lastIndexOf('/')) || '/' : null;
                                if (parentPath) {
                                    await refreshFileSystemViews(parentPath);
                                }
                                
                                // Also refresh Trash view so deleted items appear immediately
                                await refreshFileSystemViews(trashPath);
                            } catch (error) {
                                alert('Error deleting: ' + error.message);
                            }
                        }
                    }
                }
            }
        };
        
        document.addEventListener('keydown', deleteKeyHandler);
        
        // Add context menu to items container for "New" options
        itemsContainer.addEventListener('contextmenu', (e) => {
            if (e.target.closest('.file-item')) return;
            e.preventDefault();
            
            const existing = document.querySelector('.file-context-menu');
            if (existing) existing.remove();
            
            const menu = document.createElement('div');
            menu.className = 'context-menu file-context-menu show';
            
            // Position menu
            let left = e.pageX;
            let top = e.pageY;
            const menuWidth = 220;
            const menuHeight = 200;
            
            if (left + menuWidth > window.innerWidth) {
                left = window.innerWidth - menuWidth - 10;
            }
            if (top + menuHeight > window.innerHeight) {
                top = window.innerHeight - menuHeight - 10;
            }
            
            menu.style.left = left + 'px';
            menu.style.top = top + 'px';
            menu.style.display = 'flex'; // Ensure it's visible
            menu.style.zIndex = '10000'; // Ensure it's on top
            
            const pasteDisabled = !clipboard.item ? 'disabled' : '';
            const pasteClass = pasteDisabled ? 'disabled' : '';
            const tab = getActiveTab();
            const trashPath = getUserTrashPath();
            const isInTrash = tab && tab.currentPath === trashPath;
            
            // Build menu HTML - hide "New" options in Trash
            let menuHTML = '';
            
            if (!isInTrash) {
                menuHTML = `
                    <div class="context-menu-item ${pasteClass}" data-action="paste" ${pasteDisabled}>
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                            </svg>
                        </div>
                        <span>Paste</span>
                        <span class="context-menu-shortcut">Ctrl+V</span>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-item" data-action="new-folder">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                            </svg>
                        </div>
                        <span>New Folder</span>
                    </div>
                    <div class="context-menu-item" data-action="new-file">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <path d="M14 2v6h6"></path>
                                <path d="M16 13H8"></path>
                                <path d="M16 17H8"></path>
                                <path d="M10 9H8"></path>
                            </svg>
                        </div>
                        <span>New File</span>
                    </div>
                    <div class="context-menu-item" data-action="upload">
                        <div class="context-menu-icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                        </div>
                        <span>Upload File</span>
                    </div>
                `;
            } else {
                // In Trash - only show paste if clipboard has items
                if (clipboard.item) {
                    menuHTML = `
                        <div class="context-menu-item" data-action="paste">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                                </svg>
                            </div>
                            <span>Paste</span>
                            <span class="context-menu-shortcut">Ctrl+V</span>
                        </div>
                    `;
                } else {
                    menuHTML = '<div style="padding: 20px; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px;">No options available</div>';
                }
            }
            
            menu.innerHTML = menuHTML;
            
            document.body.appendChild(menu);
            
            menu.querySelectorAll('.context-menu-item').forEach(item => {
                if (item.classList.contains('disabled')) return;
                
                item.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const action = item.dataset.action;
                    menu.remove();
                    
                    if (action === 'paste') {
                        if (!clipboard.item) return;
                        
                        try {
                            const fs = await initFileSystem();
                            const destPath = getCurrentPath();
                            let newName = clipboard.name;
                            let counter = 1;
                            
                            // Find unique name
                            while (true) {
                                const testPath = destPath === '/' ? `/${newName}` : `${destPath}/${newName}`;
                                const exists = clipboard.itemType === 'folder' ? await fs.getFolder(testPath) : await fs.getFile(testPath);
                                if (!exists) break;
                                
                                const ext = newName.includes('.') ? newName.substring(newName.lastIndexOf('.')) : '';
                                const base = newName.includes('.') ? newName.substring(0, newName.lastIndexOf('.')) : newName;
                                newName = `${base} (${counter})${ext}`;
                                counter++;
                            }
                            
                            if (clipboard.itemType === 'folder') {
                                await pasteFolderRecursive(fs, clipboard.path, destPath, newName);
                            } else {
                                const content = await fs.getFileContent(clipboard.path);
                                await fs.createFile(destPath, newName, content);
                            }
                            
                            // If cut, delete original
                            if (clipboard.type === 'cut') {
                                if (clipboard.itemType === 'folder') {
                                    await fs.deleteFolder(clipboard.path);
                                } else {
                                    await fs.deleteFile(clipboard.path);
                                }
                                clipboard = { type: null, item: null, path: null };
                            }
                            
                            // Refresh both Files windows and desktop icons
                            await refreshFileSystemViews(destPath);
                        } catch (error) {
                            alert('Error pasting: ' + error.message);
                        }
                    } else if (action === 'new-folder') {
                        try {
                            const fs = await initFileSystem();
                            const currentPath = getCurrentPath();
                            const suggestedName = await getUniqueChildName(fs, currentPath, 'New Folder', 'folder');
                            const name = await showRenameDialog(suggestedName, 'Create New Folder', window, { allowUnchanged: true });
                            if (!name) return;
                            
                            await fs.createFolder(currentPath, name);
                            // Refresh both Files windows and desktop icons
                            await refreshFileSystemViews(currentPath);
                        } catch (error) {
                            alert('Error creating folder: ' + error.message);
                        }
                    } else if (action === 'new-file') {
                        try {
                            const fs = await initFileSystem();
                            const destPath = getCurrentPath();
                            const suggestedName = await getUniqueChildName(fs, destPath, 'New File.txt', 'file');
                            const name = await showRenameDialog(suggestedName, 'Create New File', window, { allowUnchanged: true, selectBaseName: true });
                            if (!name) return;
                            
                            const newPath = destPath === '/' ? `/${name}` : `${destPath}/${name}`;
                            await fs.createFile(destPath, name, '');
                            openFileEditor(newPath, name);
                            // Refresh both Files windows and desktop icons
                            await refreshFileSystemViews(destPath);
                        } catch (error) {
                            alert('Error creating file: ' + error.message);
                        }
                    } else if (action === 'upload') {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.multiple = true;
                        input.addEventListener('change', async (e) => {
                            const files = Array.from(e.target.files);
                            for (const file of files) {
                                try {
                                    const fs = await initFileSystem();
                                    await fs.createFile(getCurrentPath(), file.name, file);
                                    await refreshCurrentView();
                                } catch (error) {
                                    alert('Error uploading file: ' + error.message);
                                }
                            }
                        });
                        input.click();
                    }
                });
            });
            
            const closeMenu = () => {
                menu.remove();
                document.removeEventListener('click', closeMenu);
                document.removeEventListener('keydown', escapeHandler);
            };
            
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeMenu();
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu, { once: true });
                document.addEventListener('keydown', escapeHandler, { once: true });
            }, 0);
        });
        
        async function pasteFolderRecursive(fs, sourcePath, destParentPath, newName) {
            await fs.createFolder(destParentPath, newName);
            const newPath = destParentPath === '/' ? `/${newName}` : `${destParentPath}/${newName}`;
            
            const dir = await fs.listDirectory(sourcePath);
            
            // Copy files
            for (const file of dir.files) {
                const content = await fs.getFileContent(file.path);
                await fs.createFile(newPath, file.name, content);
            }
            
            // Copy subfolders
            for (const folder of dir.folders) {
                await pasteFolderRecursive(fs, folder.path, newPath, folder.name);
            }
        }
        
        // Add keyboard shortcuts for file explorer
        const fileExplorerKeyHandler = async (e) => {
            // Only handle shortcuts when file explorer is focused
            if (!fileExplorerWindow || !document.body.contains(fileExplorerWindow)) return;
            if (fileExplorerWindow.style.display === 'none') return;
            
            const target = e.target;
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') return;
            
            if ((e.ctrlKey || e.metaKey) && (e.key === 'v' || e.key === 'V')) {
                e.preventDefault();
                if (clipboard.item) {
                    try {
                        const fs = await initFileSystem();
                        const destPath = getCurrentPath();
                        let newName = clipboard.name;
                        let counter = 1;
                        
                        while (true) {
                            const testPath = destPath === '/' ? `/${newName}` : `${destPath}/${newName}`;
                            const exists = clipboard.itemType === 'folder' ? await fs.getFolder(testPath) : await fs.getFile(testPath);
                            if (!exists) break;
                            
                            const ext = newName.includes('.') ? newName.substring(newName.lastIndexOf('.')) : '';
                            const base = newName.includes('.') ? newName.substring(0, newName.lastIndexOf('.')) : newName;
                            newName = `${base} (${counter})${ext}`;
                            counter++;
                        }
                        
                        if (clipboard.itemType === 'folder') {
                            await pasteFolderRecursive(fs, clipboard.path, destPath, newName);
                        } else {
                            const content = await fs.getFileContent(clipboard.path);
                            await fs.createFile(destPath, newName, content);
                        }
                        
                        if (clipboard.type === 'cut') {
                            if (clipboard.itemType === 'folder') {
                                await fs.deleteFolder(clipboard.path);
                            } else {
                                await fs.deleteFile(clipboard.path);
                            }
                            clipboard = { type: null, item: null, path: null };
                        }
                        
                        // Refresh both Files windows and desktop icons
                        await refreshFileSystemViews(destPath);
                    } catch (error) {
                        alert('Error pasting: ' + error.message);
                    }
                }
            }
        };
        
        document.addEventListener('keydown', fileExplorerKeyHandler);
        
        // Setup refresh button
        const refreshButton = window.querySelector('#refresh-button');
        if (refreshButton) {
            refreshButton.removeAttribute('title');
            refreshButton.addEventListener('click', async () => {
                // Clear search when refreshing
                if (searchInput) {
                    searchInput.value = '';
                    isSearching = false;
                }
                await refreshCurrentView();
            });
            
            // Setup custom tooltip for refresh button
            setupNavButtonTooltip(refreshButton, 'Refresh');
        }
        
        // Setup view toggle (list/grid)
        const viewToggleButton = window.querySelector('#view-toggle-button');
        const viewToggleIcon = window.querySelector('#view-toggle-icon');
        if (viewToggleButton) {
            viewToggleButton.removeAttribute('title');
            // Setup custom tooltip for view toggle button
            setupNavButtonTooltip(viewToggleButton, 'Toggle View');
        }
        let currentView = localStorage.getItem('fileExplorerView') || 'grid'; // 'grid' or 'list'
        
        // Setup icon size toggle (small, medium, large)
        const iconSizeToggleButton = window.querySelector('#icon-size-toggle-button');
        const iconSizeToggleIcon = window.querySelector('#icon-size-toggle-icon');
        if (iconSizeToggleButton) {
            iconSizeToggleButton.removeAttribute('title');
            // Setup custom tooltip for icon size toggle button
            setupNavButtonTooltip(iconSizeToggleButton, 'Toggle Icon Size');
        }
        // Default to 'small' if not set, and save it
        let currentIconSize = localStorage.getItem('fileExplorerIconSize');
        if (!currentIconSize) {
            currentIconSize = 'small';
            localStorage.setItem('fileExplorerIconSize', 'small');
        }
        
        // Icon size configurations
        const iconSizes = {
            small: { icon: 32, grid: 100, label: 11 },
            medium: { icon: 48, grid: 120, label: 12 },
            large: { icon: 64, grid: 140, label: 13 }
        };
        
        function updateIconSize(size) {
            currentIconSize = size;
            localStorage.setItem('fileExplorerIconSize', size);
            
            // Update button icon to show current size
            if (iconSizeToggleIcon) {
                const sizeConfig = iconSizes[size];
                // Show different icon based on size (small = 1 line, medium = 2 lines, large = 3 lines)
                if (size === 'small') {
                    iconSizeToggleIcon.innerHTML = `
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="12" x2="15" y2="12"></line>
                    `;
                } else if (size === 'medium') {
                    iconSizeToggleIcon.innerHTML = `
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="9" x2="15" y2="9"></line>
                        <line x1="9" y1="15" x2="15" y2="15"></line>
                    `;
                } else { // large
                    iconSizeToggleIcon.innerHTML = `
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="9" y1="9" x2="15" y2="9"></line>
                        <line x1="9" y1="12" x2="15" y2="12"></line>
                        <line x1="9" y1="15" x2="15" y2="15"></line>
                    `;
                }
            }
            
            // Apply icon size to all file items (only in grid view)
            if (itemsContainer && currentView === 'grid') {
                const fileIcons = itemsContainer.querySelectorAll('.file-icon');
                const sizeConfig = iconSizes[size];
                fileIcons.forEach(icon => {
                    icon.style.width = sizeConfig.icon + 'px';
                    icon.style.height = sizeConfig.icon + 'px';
                });
                
                // Keep file name text sizing in sync with icon size (grid view)
                const fileNames = itemsContainer.querySelectorAll('.file-name');
                fileNames.forEach(nameEl => {
                    nameEl.style.fontSize = sizeConfig.label + 'px';
                });
                
                // Update grid template columns based on icon size
                itemsContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${sizeConfig.grid}px, 1fr))`;
            }
        }
        
        // Initialize icon size
        updateIconSize(currentIconSize);
        
        // Icon size toggle button click handler
        if (iconSizeToggleButton) {
            iconSizeToggleButton.addEventListener('click', () => {
                // Cycle through sizes: small -> medium -> large -> small
                const sizes = ['small', 'medium', 'large'];
                const currentIndex = sizes.indexOf(currentIconSize);
                const nextIndex = (currentIndex + 1) % sizes.length;
                updateIconSize(sizes[nextIndex]);
                
                // Refresh view to apply changes
                refreshCurrentView();
            });
        }
        
        function updateViewMode(view) {
            currentView = view;
            localStorage.setItem('fileExplorerView', view);
            
            if (itemsContainer) {
                if (view === 'list') {
                    itemsContainer.classList.add('list-view');
                    itemsContainer.classList.remove('grid-view');
                    // Update icon to show list view
                    if (viewToggleIcon) {
                        viewToggleIcon.innerHTML = `
                            <line x1="8" y1="6" x2="21" y2="6"></line>
                            <line x1="8" y1="12" x2="21" y2="12"></line>
                            <line x1="8" y1="18" x2="21" y2="18"></line>
                            <line x1="3" y1="6" x2="3.01" y2="6"></line>
                            <line x1="3" y1="12" x2="3.01" y2="12"></line>
                            <line x1="3" y1="18" x2="3.01" y2="18"></line>
                        `;
                    }
                } else {
                    itemsContainer.classList.add('grid-view');
                    itemsContainer.classList.remove('list-view');
                    // Update icon to show grid view
                    if (viewToggleIcon) {
                        viewToggleIcon.innerHTML = `
                            <rect x="3" y="3" width="7" height="7"></rect>
                            <rect x="14" y="3" width="7" height="7"></rect>
                            <rect x="14" y="14" width="7" height="7"></rect>
                            <rect x="3" y="14" width="7" height="7"></rect>
                        `;
                    }
                    
                    // Apply icon size when switching to grid view
                    let iconSize = localStorage.getItem('fileExplorerIconSize');
                    if (!iconSize) {
                        iconSize = 'small';
                        localStorage.setItem('fileExplorerIconSize', 'small');
                    }
                    const sizeConfig = iconSizes[iconSize];
                    const fileIcons = itemsContainer.querySelectorAll('.file-icon');
                    fileIcons.forEach(icon => {
                        icon.style.width = sizeConfig.icon + 'px';
                        icon.style.height = sizeConfig.icon + 'px';
                    });
                    itemsContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${sizeConfig.grid}px, 1fr))`;
                }
            }
        }
        
        // Initialize view mode
        updateViewMode(currentView);
        
        if (viewToggleButton) {
            viewToggleButton.addEventListener('click', () => {
                const newView = currentView === 'grid' ? 'list' : 'grid';
                updateViewMode(newView);
                // If searching, re-run search to apply new view; otherwise refresh
                if (isSearching && searchInput) {
                    performSearch(searchInput.value);
                } else {
                    refreshCurrentView();
                }
            });
        }
        
        // Setup search box toggle
        const searchContainer = window.querySelector('.file-explorer-search');
        const searchToggleBtn = window.querySelector('#search-toggle-button');
        const searchInput = window.querySelector('#file-explorer-search-input');
        let searchTimeout = null;
        let isSearching = false;
        
        // Setup custom tooltip for Search toggle button
        if (searchToggleBtn) {
            searchToggleBtn.removeAttribute('title');
            setupNavButtonTooltip(searchToggleBtn, 'Search');
        }
        
        // Toggle search box expansion
        if (searchToggleBtn && searchContainer && searchInput) {
            searchToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                searchContainer.classList.toggle('expanded');
                if (searchContainer.classList.contains('expanded')) {
                    // Focus input when expanded
                    setTimeout(() => searchInput.focus(), 100);
                } else {
                    // Clear search and collapse when clicking icon again
                    searchInput.value = '';
                    if (isSearching) {
                        isSearching = false;
                        refreshCurrentView();
                    }
                }
            });
            
            // Collapse when clicking outside
            document.addEventListener('click', (e) => {
                if (searchContainer.classList.contains('expanded') && 
                    !searchContainer.contains(e.target) && 
                    searchInput.value === '') {
                    searchContainer.classList.remove('expanded');
                }
            });
            
            // Keep expanded if there's text in the input
            searchInput.addEventListener('input', () => {
                if (searchInput.value && !searchContainer.classList.contains('expanded')) {
                    searchContainer.classList.add('expanded');
                }
            });
        }
        
        // Setup search functionality
        
        // Apps list for search
        const apps = [
            { name: 'Settings', icon: '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"></path></svg>' },
            { name: 'Files', icon: '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>' },
            { name: 'Viewer', icon: '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>' },
            { name: 'Paint', icon: '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>' },
            { name: 'Calculate', icon: '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="2" width="14" height="20" rx="2"></rect><path d="M8 6h8"></path><path d="M8 10h2"></path><path d="M12 10h2"></path><path d="M8 14h2"></path><path d="M12 14h2"></path><path d="M8 18h2"></path><path d="M12 18h2"></path></svg>' },
            { name: 'Player', icon: '<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 0 20a10 10 0 0 0 0-20z M10 8l6 4-6 4V8z"></path></svg>' }
        ];
        
        // Recursive function to search through all directories
        async function searchRecursive(fs, searchPath, query, results) {
            try {
                const directory = await fs.listDirectory(searchPath);
                
                // Search folders
                for (const folder of directory.folders) {
                    if (folder.name.toLowerCase().includes(query.toLowerCase())) {
                        results.folders.push(folder);
                    }
                    // Recursively search subfolders
                    await searchRecursive(fs, folder.path, query, results);
                }
                
                // Search files
                for (const file of directory.files) {
                    if (file.name.toLowerCase().includes(query.toLowerCase())) {
                        results.files.push(file);
                    }
                }
            } catch (error) {
                // Silently skip directories we can't access
                console.error('Error searching directory:', searchPath, error);
            }
        }
        
        // Perform search
        async function performSearch(query) {
            if (!query || query.trim() === '') {
                isSearching = false;
                await refreshCurrentView();
                return;
            }
            
            isSearching = true;
            const searchQuery = query.trim().toLowerCase();
            
            if (itemsContainer) {
                itemsContainer.innerHTML = '';
                
                try {
                    const fs = await initFileSystem();
                    const results = { folders: [], files: [] };
                    
                    // Search through all directories starting from root
                    await searchRecursive(fs, '/', searchQuery, results);
                    
                    // Search apps
                    const matchingApps = apps.filter(app => 
                        app.name.toLowerCase().includes(searchQuery)
                    );
                    
                    // Update address bar to show search status
                    if (addressBar) {
                        addressBar.textContent = `Search results for "${query}"`;
                    }
                    
                    // Display results
                    let hasResults = false;
                    
                    // Add matching apps first
                    matchingApps.forEach(app => {
                        hasResults = true;
                        const appItem = document.createElement('div');
                        appItem.className = 'file-item';
                        appItem.dataset.type = 'app';
                        appItem.dataset.appName = app.name;
                        appItem.innerHTML = `
                            <div class="file-icon">
                                ${app.icon}
                            </div>
                            <div class="file-name">${app.name}</div>
                            <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-left: 8px;">App</div>
                        `;
                        appItem.addEventListener('dblclick', () => {
                            if (app.name === 'Files') {
                                const openFileExplorer = initFileExplorer();
                                if (openFileExplorer) {
                                    openFileExplorer();
                                }
                            } else if (app.name === 'Settings') {
                                const openSettings = initSettingsWindow();
                                if (openSettings) {
                                    openSettings();
                                }
                            } else if (app.name === 'Viewer') {
                                const openViewer = initViewer();
                                if (openViewer) {
                                    openViewer();
                                }
                            } else if (app.name === 'Player') {
                                const openPlayer = initPlayer();
                                if (openPlayer) {
                                    openPlayer();
                                }
                            } else if (app.name === 'Paint') {
                                const openPaint = initPaint();
                                if (openPaint) {
                                    openPaint();
                                }
                            } else if (app.name === 'Calculate') {
                                const openCalculate = initCalculate();
                                if (openCalculate) {
                                    openCalculate();
                                }
                            }
                        });
                        itemsContainer.appendChild(appItem);
                    });
                    
                    // Add matching folders
                    results.folders.forEach(folder => {
                        hasResults = true;
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.dataset.path = folder.path;
                        fileItem.dataset.type = 'folder';
                        fileItem.innerHTML = `
                            <div class="file-icon">
                                ${getFileIcon(folder.name, true)}
                            </div>
                            <div class="file-name">${formatFileName(folder.name)}</div>
                            <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-left: 8px;">${folder.path}</div>
                        `;
                        // Single click to select (for folders)
                        fileItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            selectItem(fileItem);
                        });
                        // Double click to navigate (for folders)
                        fileItem.addEventListener('dblclick', () => navigateToPath(folder.path));
                        fileItem.addEventListener('contextmenu', (e) => showFileContextMenu(e, folder.path, 'folder', folder.name));
                        itemsContainer.appendChild(fileItem);
                    });
                    
                    // Add matching files
                    results.files.forEach(file => {
                        hasResults = true;
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.dataset.path = file.path;
                        fileItem.dataset.type = 'file';
                        fileItem.innerHTML = `
                            <div class="file-icon">
                                ${getFileIcon(file.name)}
                            </div>
                            <div class="file-name">${formatFileName(file.name)}</div>
                            <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-left: 8px;">${file.path}</div>
                        `;
                        // Single click to select (for files)
                        fileItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            // Use currentTarget to ensure we get the fileItem even if clicking on child elements
                            selectItem(e.currentTarget);
                        });
                        // Double click to open (for files)
                        fileItem.addEventListener('dblclick', () => openFile(file.path, file.name));
                        fileItem.addEventListener('contextmenu', (e) => showFileContextMenu(e, file.path, 'file', file.name));
                        itemsContainer.appendChild(fileItem);
                    });
                    
                    // Show no results message
                    if (!hasResults) {
                        const noResultsMsg = document.createElement('div');
                        noResultsMsg.style.cssText = 'padding: 40px; text-align: center; color: rgba(255,255,255,0.5); grid-column: 1/-1;';
                        noResultsMsg.textContent = `No results found for "${query}"`;
                        itemsContainer.appendChild(noResultsMsg);
                    }
                } catch (error) {
                    itemsContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: rgba(255,0,0,0.6);">Error searching: ${error.message}</div>`;
                }
            }
        }
        
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value;
                
                // Clear existing timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                // Debounce search - wait 300ms after user stops typing
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 300);
            });
            
            // Clear search on Escape key
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    isSearching = false;
                    refreshCurrentView();
                }
            });
        }
        
        // Add copy/paste functionality to address bar
        if (addressBar) {
            // Make address bar selectable and editable-looking
            addressBar.setAttribute('contenteditable', 'false');
            addressBar.style.cursor = 'text';
            
            // Handle copy - copy actual path with slashes
            addressBar.addEventListener('copy', (e) => {
                e.preventDefault();
                // Use stored actual path, or convert display text back to actual path
                let actualPath = addressBar.dataset.actualPath;
                if (!actualPath) {
                    // Convert display format back to actual path (handle both HTML and text)
                    const textContent = addressBar.textContent || addressBar.innerText;
                    actualPath = textContent
                        .replace(/Local Disk \(C:\)/g, 'C:')
                        .replace(/ > /g, '/');
                }
                e.clipboardData.setData('text/plain', actualPath);
            });
            
            // Handle paste - navigate to pasted path
            addressBar.addEventListener('paste', async (e) => {
                e.preventDefault();
                const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                
                // Convert pasted path to internal format
                let path = pastedText.trim();
                
                // Remove "Local Disk (C:)" prefix if present
                if (path.startsWith('Local Disk (C:)')) {
                    path = path.substring('Local Disk (C:)'.length);
                }
                // Remove C: prefix if present
                else if (path.startsWith('C:')) {
                    path = path.substring(2);
                }
                
                // Ensure it starts with /
                if (!path.startsWith('/')) {
                    path = '/' + path;
                }
                
                // Normalize the path
                path = path.replace(/\\/g, '/'); // Convert backslashes to forward slashes
                path = path.replace(/\/+/g, '/'); // Remove duplicate slashes
                
                // Navigate to the path
                try {
                    await navigateToPath(path);
                } catch (error) {
                    console.error('Error navigating to pasted path:', error);
                }
            });
            
            // Handle Ctrl+C when address bar text is selected
            addressBar.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                    const selection = window.getSelection().toString();
                    if (selection) {
                        // If text is selected, copy the actual path
                        let actualPath = addressBar.dataset.actualPath;
                        if (!actualPath) {
                            // Convert display format back to actual path
                            actualPath = addressBar.textContent
                                .replace(/Local Disk \(C:\)/g, 'C:')
                                .replace(/  /g, '/');
                        }
                        navigator.clipboard.writeText(actualPath).catch(() => {
                            // Fallback if clipboard API fails
                            const textArea = document.createElement('textarea');
                            textArea.value = actualPath;
                            textArea.style.position = 'fixed';
                            textArea.style.opacity = '0';
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                        });
                        e.preventDefault();
                    }
                }
            });
        }
        
        // Reset navigateToRootOnOpen flag if it was set
        if (navigateToRootOnOpen) {
            navigateToRootOnOpen = false;
        }
        
        const savedTabsState = getSavedTabsState();
        
        // Path to location mapping (check both root and user-specific paths)
        const loggedInUser = localStorage.getItem('loggedInUser');
        let currentUsername = null;
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                currentUsername = user.name;
            } catch (e) {
                console.warn('Could not parse logged-in user:', e);
            }
        }
        
        const pathToLocation = {
            '/': 'disk-c',
            '/Desktop': 'desktop',
            '/Downloads': 'downloads',
            '/Documents': 'documents',
            '/Pictures': 'pictures',
            '/Music': 'music',
            '/Videos': 'videos'
        };
        
        // Also check user-specific paths
        if (currentUsername) {
            pathToLocation[`/Users/${currentUsername}`] = 'user-home';
            pathToLocation[`/Users/${currentUsername}/Desktop`] = 'desktop';
            pathToLocation[`/Users/${currentUsername}/Downloads`] = 'downloads';
            pathToLocation[`/Users/${currentUsername}/Documents`] = 'documents';
            pathToLocation[`/Users/${currentUsername}/Pictures`] = 'pictures';
            pathToLocation[`/Users/${currentUsername}/Music`] = 'music';
            pathToLocation[`/Users/${currentUsername}/Videos`] = 'videos';
            pathToLocation[`/Users/${currentUsername}/Trash`] = 'trash';
        }
        
        // Only restore saved tabs if this is a window restoration (restoreState exists)
        // For new windows, always default to user directory
        const isWindowRestoration = restoreState !== null;
        if (savedTabsState && savedTabsState.tabs && savedTabsState.tabs.length > 0 && !initialPath && isWindowRestoration) {
            // Window is being restored, restore all saved tabs in their original order
            isRestoringTabs = true;
            const savedTabs = savedTabsState.tabs;
            // Get the index of the active tab (use saved index or default to 0)
            const activeTabIndex = (savedTabsState.activeTabIndex !== undefined && savedTabsState.activeTabIndex >= 0) 
                ? savedTabsState.activeTabIndex 
                : 0;
            
            // Immediately clear all active sidebar items to prevent flash
            sidebarItems.forEach(item => item.classList.remove('active'));
            
            // Immediately clear address bar to prevent showing Desktop
            if (addressBar) {
                addressBar.innerHTML = 'Local Disk (C:)';
                addressBar.dataset.actualPath = 'C:';
            }
            
            const createdTabIds = [];
            
            // Create all saved tabs in order (skip setting active during creation to preserve order)
            for (let i = 0; i < savedTabs.length; i++) {
                const savedTab = savedTabs[i];
                const location = savedTab.location || pathToLocation[savedTab.path] || 'disk-c';
                
                // Create tab with saved data (skip setting active to preserve tab order)
                const tabId = createTab(savedTab.path, location, savedTab, true);
                createdTabIds.push(tabId);
            }
            
            // Do NOT delay initial rendering: show the active tab immediately.
            // Also avoid pre-loading every restored tab (expensive and unnecessary); tabs can load when activated.
            const activeTabIdToSet = (activeTabIndex >= 0 && activeTabIndex < createdTabIds.length)
                ? createdTabIds[activeTabIndex]
                : (createdTabIds[0] || null);

            if (activeTabIdToSet) {
                setActiveTab(activeTabIdToSet); // triggers refreshActiveTab() -> navigateToPath()
                updateNavButtons();
            }

            // Restoration complete, allow saving again
            isRestoringTabs = false;
            // Resize window to fit all restored tabs
            resizeWindowForTabs();
            // Save tabs state after restoration is complete
            saveTabsState();
            // Update filesystem size after restoration is complete (non-blocking)
            scheduleIdleWork(() => updateFsSize());
        } else {
            // Create initial tab (new window or explicit initialPath)
            let startingPath = '/';
            let initialLocation = 'disk-c';
            
            // Get logged-in user for path mapping
            let currentUsername = null;
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    currentUsername = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }
            
            // Create pathToLocation mapping
            const pathToLocation = {
                '/': 'disk-c',
                '/Desktop': 'desktop',
                '/Downloads': 'downloads',
                '/Documents': 'documents',
                '/Pictures': 'pictures',
                '/Music': 'music',
                '/Videos': 'videos'
            };
            
            // Add user-specific paths
            if (currentUsername) {
                pathToLocation[`/Users/${currentUsername}/Desktop`] = 'desktop';
                pathToLocation[`/Users/${currentUsername}/Downloads`] = 'downloads';
                pathToLocation[`/Users/${currentUsername}/Documents`] = 'documents';
                pathToLocation[`/Users/${currentUsername}/Pictures`] = 'pictures';
                pathToLocation[`/Users/${currentUsername}/Music`] = 'music';
                pathToLocation[`/Users/${currentUsername}/Videos`] = 'videos';
                pathToLocation[`/Users/${currentUsername}/Trash`] = 'trash';
            }
            
            if (initialPath) {
                startingPath = initialPath;
                initialLocation = pathToLocation[initialPath] || 'disk-c';
            } else {
                // Default to logged-in user's directory
                if (currentUsername) {
                    const userPath = `/Users/${currentUsername}`;
                    startingPath = userPath;
                    // User directory path doesn't map to a location, so we'll use navigateToPath
                    initialLocation = 'disk-c'; // Fallback, but won't be used
                }
            }
            
            createTab(startingPath, initialLocation);
            
            // Navigate to initial path/location
            const tab = getActiveTab();
            if (tab) {
                tab.isNavigatingHistory = true;
                // Check if startingPath is a predefined location
                if (pathToLocation[startingPath]) {
                    // It's a predefined location, use updateContent
                    updateContent(initialLocation);
                    tab.isNavigatingHistory = false;
                    updateNavButtons();
                } else {
                    // It's a custom path, use navigateToPath
                    // Ensure the folder exists before navigating
                    (async () => {
                        try {
                            const fs = await initFileSystem();
                            const folder = await fs.getFolder(startingPath);
                            if (!folder) {
                                // Create the folder if it doesn't exist
                                const pathParts = startingPath.split('/').filter(p => p);
                                const folderName = pathParts.pop();
                                const parentPath = pathParts.length > 0 ? '/' + pathParts.join('/') : '/';
                                await fs.createFolder(parentPath, folderName);
                            }
                            await navigateToPath(startingPath);
                            tab.isNavigatingHistory = false;
                            updateNavButtons();
                        } catch (err) {
                            console.error('Error navigating to custom path:', err);
                            // Fallback to root directory
                            updateContent('disk-c');
                            tab.isNavigatingHistory = false;
                            updateNavButtons();
                        }
                    })();
                }
            }
        }

        // Attach functions to window so they can be called from context menu handlers
        window.refreshCurrentView = refreshCurrentView;
        window.getActiveTab = getActiveTab;
        window.createTab = createTab;
        window.navigateToPath = navigateToPath;
        
        // Update filesystem size (will be called again after tab restoration if restoring)
        // Use a small delay to ensure DOM is ready, especially when restoring
        setTimeout(() => {
            updateFsSize();
        }, 100);
    }
    
    function setupWindowControls(window) {
        const minimizeBtn = window.querySelector('.window-control.minimize');
        const maximizeBtn = window.querySelector('.window-control.maximize');
        const closeBtn = window.querySelector('.window-control.close');
        
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const wasMinimized = window.style.display === 'none';
                if (wasMinimized) {
                    window.style.display = 'flex';
                    focusWindow(window);
                } else {
                    window.style.display = 'none';
                    window.classList.remove('window-focused');
                }
                saveFileExplorerWindowsState();
                const nowMinimized = window.style.display === 'none';
                const isFocused = window.classList.contains('window-focused') && !nowMinimized;
                updateWindowAppBarState(window, isFocused, nowMinimized);
            });
        }
        
        if (maximizeBtn) {
            let previousSize = null;
            let isMaximized = false;
            
            maximizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (isMaximized) {
                    // Restore to previous size
                    if (previousSize) {
                        window.style.width = previousSize.width;
                        window.style.height = previousSize.height;
                        window.style.left = previousSize.left;
                        window.style.top = previousSize.top;
                    } else {
                        // Fallback to defaults
                        window.style.width = '800px';
                        window.style.height = '600px';
                        window.style.left = '250px';
                        window.style.top = '100px';
                    }
                    isMaximized = false;
                } else {
                    // Save current position before maximizing
                    previousSize = {
                        width: window.style.width || window.offsetWidth + 'px',
                        height: window.style.height || window.offsetHeight + 'px',
                        left: window.style.left || window.offsetLeft + 'px',
                        top: window.style.top || window.offsetTop + 'px'
                    };
                    maximizeWindowToBounds(window);
                    isMaximized = true;
                }
                saveFileExplorerWindowsState();
            });
        }
        
        if (closeBtn) {
            closeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                // Get window ID before removing from DOM
                const windowId = window.id;
                window.remove();
                saveFileExplorerWindowsState();
                if (windowId) {
                    removeWindowFromAppBar(windowId);
                }
            });
        }
    }
    
    function addToAppBar(window) {
        return addWindowToAppBar(window, {
            appId: 'file-explorer',
            iconSvg: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <path d="M14 2v6h6"></path>
                <path d="M16 13H8"></path>
                <path d="M16 17H8"></path>
                <path d="M10 9H8"></path>
            </svg>`,
            onIconClick: (function(w) {
                return function() {
                    toggleWindowFromDock(w, saveFileExplorerWindowsState);
                };
            })(window)
        });
    }
    
    // Restore all windows on page load if they were open before (only once)
    if (!fileExplorerInitialized) {
        fileExplorerInitialized = true;
        const savedWindowsState = getSavedFileExplorerWindowsState();
        if (savedWindowsState && savedWindowsState.length > 0) {
            // Restore all saved windows
            savedWindowsState.forEach(state => {
                createFileExplorerWindow(null, state);
            });
            
            // Fix any windows that are positioned off-screen after restoration
            // Run multiple times to ensure windows are fully rendered and validated
            setTimeout(() => {
                const allFileExplorerWindows = document.querySelectorAll('[data-file-explorer-window]');
                allFileExplorerWindows.forEach(win => {
                    validateAndFixWindowPosition(win);
                });
            }, 100);
            
            // Run again after longer delay to catch any edge cases
            setTimeout(() => {
                const allFileExplorerWindows = document.querySelectorAll('[data-file-explorer-window]');
                allFileExplorerWindows.forEach(win => {
                    validateAndFixWindowPosition(win);
                });
            }, 500);
            
            // Final validation pass
            setTimeout(() => {
                const allFileExplorerWindows = document.querySelectorAll('[data-file-explorer-window]');
                allFileExplorerWindows.forEach(win => {
                    validateAndFixWindowPosition(win);
                });
            }, 1000);
        }
        
        // Restore properties windows after File Explorer is initialized and file system is ready
        // Use setTimeout to ensure file system is fully initialized
        setTimeout(async () => {
            if (window.restorePropertiesWindows) {
                await window.restorePropertiesWindows();
            }
        }, 200);
    }
    
    // Create window when function is called explicitly (from Start Menu)
    // This will be called when Files is clicked
    return function(initialPath = null) {
        createFileExplorerWindow(initialPath);
    };
}

// Image File Picker Dialog for selecting images from virtual filesystem
async function showImageFilePicker() {
    return new Promise((resolve) => {
        // Get currently logged-in user
        let currentUsername = null;
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                currentUsername = user.name;
            } catch (e) {
                console.warn('Could not parse logged-in user:', e);
            }
        }
        
        // Start at user's Pictures folder or root
        const startPath = currentUsername ? `/Users/${currentUsername}/Pictures` : '/';
        
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
        
        // Create dialog - styled like Files app window
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background: rgba(25, 25, 35, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; width: 700px; max-width: 90vw; height: 600px; max-height: 80vh; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; overflow: hidden;';
        
        let currentPath = startPath;
        let selectedPath = null;
        let pathHistory = [startPath];
        let historyIndex = 0;
        
        // Helper function to check if file is an image
        function isImageFile(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
            return imageExts.includes(ext);
        }
        
        // Helper function to get file icon
        function getFileIcon(fileName) {
            if (isImageFile(fileName)) {
                return '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>';
            }
            return '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path></svg>';
        }
        
        // Helper function to get folder icon
        function getFolderIcon() {
            return '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
        }
        
        // Function to format path for display
        function formatPath(path) {
            if (path === '/') return 'Local Disk (C:)';
            const parts = path.split('/').filter(p => p);
            if (parts.length === 0) return 'Local Disk (C:)';
            return parts.join(' > ');
        }
        
        // Function to load directory contents
        const loadDirectory = async (path) => {
            try {
                const fs = await initFileSystem();
                const directory = await fs.listDirectory(path);
                
                const itemsContainer = dialog.querySelector('#image-picker-items');
                const pathDisplay = dialog.querySelector('#image-picker-path');
                
                itemsContainer.innerHTML = '';
                
                // Update path display
                pathDisplay.innerHTML = formatPath(path).split(' > ').map((part, index, arr) => {
                    if (index === arr.length - 1) {
                        return `<span>${part}</span>`;
                    }
                    const pathToPart = '/' + arr.slice(0, index + 1).join('/');
                    return `<span style="cursor: pointer; color: rgba(93, 173, 226, 0.8);" data-path="${pathToPart}">${part}</span>`;
                }).join(' <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: inline-block; vertical-align: middle; margin: 0 4px;"><polyline points="9 18 15 12 9 6"></polyline></svg> ');
                
                // Add click handlers to path segments
                pathDisplay.querySelectorAll('[data-path]').forEach(span => {
                    span.addEventListener('click', () => {
                        currentPath = span.dataset.path;
                        pathHistory = pathHistory.slice(0, historyIndex + 1);
                        pathHistory.push(currentPath);
                        historyIndex = pathHistory.length - 1;
                        loadDirectory(currentPath);
                    });
                });
                
                // Combine folders and image files
                const folders = directory.folders || [];
                const files = directory.files || [];
                const imageFiles = files.filter(file => isImageFile(file.name));
                const allItems = [...folders.map(f => ({...f, type: 'folder'})), ...imageFiles.map(f => ({...f, type: 'file'}))];
                
                if (allItems.length === 0) {
                    itemsContainer.innerHTML = '<div style="color: rgba(255, 255, 255, 0.5); padding: 40px; text-align: center; grid-column: 1 / -1;">No items in this directory</div>';
                } else {
                    allItems.forEach(item => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'file-item';
                        fileItem.dataset.path = item.path;
                        fileItem.dataset.type = item.type;
                        fileItem.dataset.name = item.name;
                        
                        if (item.type === 'folder') {
                            fileItem.innerHTML = `
                                <div class="file-icon">
                                    ${getFolderIcon()}
                                </div>
                                <div class="file-name">${item.name}</div>
                            `;
                            fileItem.addEventListener('click', function() {
                                currentPath = item.path;
                                pathHistory = pathHistory.slice(0, historyIndex + 1);
                                pathHistory.push(currentPath);
                                historyIndex = pathHistory.length - 1;
                                loadDirectory(currentPath);
                            });
                        } else {
                            fileItem.innerHTML = `
                                <div class="file-icon">
                                    ${getFileIcon(item.name)}
                                </div>
                                <div class="file-name">${item.name}</div>
                            `;
                            fileItem.addEventListener('click', function() {
                                // Remove previous selection
                                itemsContainer.querySelectorAll('.file-item.selected').forEach(item => {
                                    item.classList.remove('selected');
                                });
                                // Highlight selected
                                this.classList.add('selected');
                                selectedPath = this.dataset.path;
                            });
                        }
                        
                        itemsContainer.appendChild(fileItem);
                    });
                }
                
                // Update navigation buttons
                const backBtn = dialog.querySelector('#image-picker-back');
                const forwardBtn = dialog.querySelector('#image-picker-forward');
                
                if (backBtn) {
                    backBtn.disabled = historyIndex <= 0;
                    backBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
                    backBtn.style.cursor = historyIndex <= 0 ? 'not-allowed' : 'pointer';
                }
                
                if (forwardBtn) {
                    forwardBtn.disabled = historyIndex >= pathHistory.length - 1;
                    forwardBtn.style.opacity = historyIndex >= pathHistory.length - 1 ? '0.5' : '1';
                    forwardBtn.style.cursor = historyIndex >= pathHistory.length - 1 ? 'not-allowed' : 'pointer';
                }
            } catch (error) {
                const itemsContainer = dialog.querySelector('#image-picker-items');
                itemsContainer.innerHTML = '<div style="color: rgba(255, 0, 0, 0.7); padding: 40px; text-align: center; grid-column: 1 / -1;">Error loading directory: ' + error.message + '</div>';
                console.error('Error loading directory:', error);
            }
        };
        
        dialog.innerHTML = `
            <div class="window-header" style="padding: 10px 15px; background: rgba(25, 25, 35, 0.85); border-bottom: 1px solid rgba(255, 255, 255, 0.1); display: flex; align-items: center; justify-content: space-between;">
                <div class="window-title" style="font-size: 14px; font-weight: 600; color: #5dade2; display: flex; align-items: center; gap: 8px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                    Select Image File
                </div>
                <div class="window-controls" style="display: flex; gap: 8px;">
                    <div class="window-control close" id="image-picker-close" style="width: 18px; height: 18px; border-radius: 50%; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="file-explorer-toolbar" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(25, 25, 35, 0.85); border-bottom: 1px solid rgba(255, 255, 255, 0.1); min-height: 44px;">
                <div class="file-explorer-nav-buttons" style="display: flex; gap: 4px;">
                    <button class="nav-button" id="image-picker-back" title="Back" style="width: 32px; height: 32px; border: none; background: transparent; color: rgba(255, 255, 255, 0.7); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5M12 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <button class="nav-button" id="image-picker-forward" title="Forward" style="width: 32px; height: 32px; border: none; background: transparent; color: rgba(255, 255, 255, 0.7); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12h14M12 5l7 7-7 7"></path>
                        </svg>
                    </button>
                </div>
                <div class="file-explorer-address-bar" id="image-picker-path" style="flex: 1; padding: 6px 12px; background: rgba(40, 40, 50, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: flex; align-items: center; gap: 4px;">
                    ${formatPath(startPath)}
                </div>
            </div>
            <div class="file-explorer-main" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(25, 25, 35, 0.85); position: relative;">
                <div class="file-explorer-items grid-view" id="image-picker-items" style="flex: 1; padding: 16px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 16px; align-content: start;">
                </div>
            </div>
            <div style="padding: 12px 16px; background: rgba(25, 25, 35, 0.85); border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 8px; justify-content: flex-end;">
                <button id="image-picker-cancel" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: rgba(255, 255, 255, 0.9); cursor: pointer; font-size: 13px; transition: background 0.2s;">Cancel</button>
                <button id="image-picker-select" style="padding: 8px 16px; background: #5dade2; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 13px; font-weight: 600; transition: background 0.2s;">Select</button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Navigation button handlers
        const backBtn = dialog.querySelector('#image-picker-back');
        const forwardBtn = dialog.querySelector('#image-picker-forward');
        const closeBtn = dialog.querySelector('#image-picker-close');
        
        if (backBtn) {
            backBtn.addEventListener('click', () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    currentPath = pathHistory[historyIndex];
                    loadDirectory(currentPath);
                }
            });
            backBtn.addEventListener('mouseenter', function() {
                if (!this.disabled) {
                    this.style.background = 'rgba(255, 255, 255, 0.1)';
                    this.style.color = 'rgba(255, 255, 255, 0.9)';
                }
            });
            backBtn.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
                this.style.color = 'rgba(255, 255, 255, 0.7)';
            });
        }
        
        if (forwardBtn) {
            forwardBtn.addEventListener('click', () => {
                if (historyIndex < pathHistory.length - 1) {
                    historyIndex++;
                    currentPath = pathHistory[historyIndex];
                    loadDirectory(currentPath);
                }
            });
            forwardBtn.addEventListener('mouseenter', function() {
                if (!this.disabled) {
                    this.style.background = 'rgba(255, 255, 255, 0.1)';
                    this.style.color = 'rgba(255, 255, 255, 0.9)';
                }
            });
            forwardBtn.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
                this.style.color = 'rgba(255, 255, 255, 0.7)';
            });
        }
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                resolve(null);
            });
            closeBtn.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(255, 255, 255, 0.1)';
            });
            closeBtn.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
            });
        }
        
        // Cancel button
        const cancelBtn = dialog.querySelector('#image-picker-cancel');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                document.body.removeChild(overlay);
                resolve(null);
            });
            cancelBtn.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(255, 255, 255, 0.15)';
            });
            cancelBtn.addEventListener('mouseleave', function() {
                this.style.background = 'rgba(255, 255, 255, 0.1)';
            });
        }
        
        // Select button
        const selectBtn = dialog.querySelector('#image-picker-select');
        if (selectBtn) {
            selectBtn.addEventListener('click', () => {
                if (selectedPath) {
                    document.body.removeChild(overlay);
                    resolve(selectedPath);
                } else {
                    alert('Please select an image file.');
                }
            });
            selectBtn.addEventListener('mouseenter', function() {
                this.style.background = '#6bb8e8';
            });
            selectBtn.addEventListener('mouseleave', function() {
                this.style.background = '#5dade2';
            });
        }
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
                resolve(null);
            }
        });
        
        // Load initial directory
        loadDirectory(currentPath);
    });
}

// Player App (Audio/Video)
let playerInitialized = false;
let globalSavePlayerWindowsState = null;

function initPlayer() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');

    if (!windowsContainer || !dockApps) {
        setTimeout(() => initPlayer(), 100);
        return;
    }

    // Match the Player icon used in the Start Menu.
    const PLAYER_ICON_PATH = 'M12 2a10 10 0 1 0 0 20a10 10 0 0 0 0-20z M10 8l6 4-6 4V8z';

    const PLAYER_ICON_24 = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="${PLAYER_ICON_PATH}"></path>
        </svg>
    `;

    const PLAYER_ICON_16 = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="${PLAYER_ICON_PATH}"></path>
        </svg>
    `;

    function getMediaExt(nameOrPath) {
        return String(nameOrPath || '').split('.').pop().toLowerCase();
    }

    function getMediaKindByExt(ext) {
        const audioExts = ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'opus', 'flac'];
        const videoExts = ['mp4', 'webm', 'ogv', 'mkv', 'mov'];
        if (videoExts.includes(ext)) return 'video';
        if (audioExts.includes(ext)) return 'audio';
        return null;
    }

    function getMediaMimeTypeByExt(ext) {
        const map = {
            mp3: 'audio/mpeg',
            wav: 'audio/wav',
            ogg: 'audio/ogg',
            opus: 'audio/opus',
            m4a: 'audio/mp4',
            aac: 'audio/aac',
            flac: 'audio/flac',

            mp4: 'video/mp4',
            webm: 'video/webm',
            ogv: 'video/ogg',
            mkv: 'video/x-matroska',
            mov: 'video/quicktime',
        };
        return map[ext] || '';
    }

    function formatTime(seconds) {
        const s = Number.isFinite(seconds) ? Math.max(0, seconds) : 0;
        const m = Math.floor(s / 60);
        const r = Math.floor(s % 60);
        return `${m}:${String(r).padStart(2, '0')}`;
    }

    function escapeHtml(str) {
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    async function pickMediaFilesFromFilesystem({ multiple = true } = {}) {
        return new Promise(async (resolve) => {
            // Get currently logged-in user
            let currentUsername = null;
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                try {
                    const user = JSON.parse(loggedInUser);
                    currentUsername = user.name;
                } catch (e) {
                    console.warn('Could not parse logged-in user:', e);
                }
            }

            // Start at user's Music folder or root
            const startPath = currentUsername ? `/Users/${currentUsername}/Music` : '/';

            const audioExts = ['mp3', 'wav', 'ogg', 'm4a', 'aac', 'opus', 'flac'];
            const videoExts = ['mp4', 'webm', 'ogv', 'mkv', 'mov'];
            function isMediaFile(fileName) {
                const ext = String(fileName || '').split('.').pop().toLowerCase();
                return audioExts.includes(ext) || videoExts.includes(ext);
            }

            function getFileIcon(fileName) {
                const ext = String(fileName || '').split('.').pop().toLowerCase();
                if (videoExts.includes(ext)) {
                    return '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>';
                }
                return '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>';
            }

            function getFolderIcon() {
                return '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
            }

            function formatPath(path) {
                if (path === '/') return 'Local Disk (C:)';
                const parts = path.split('/').filter(p => p);
                if (parts.length === 0) return 'Local Disk (C:)';
                return parts.join(' > ');
            }

            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';

            // Create dialog - styled like Files app window
            const dialog = document.createElement('div');
            dialog.style.cssText = 'background: rgba(25, 25, 35, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; width: 820px; max-width: 92vw; height: 640px; max-height: 84vh; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); display: flex; flex-direction: column; overflow: hidden;';

            let currentPath = startPath;
            let pathHistory = [startPath];
            let historyIndex = 0;
            const selectedPaths = new Set();

            const close = (result) => {
                try { document.body.removeChild(overlay); } catch (e) {}
                resolve(result);
            };

            const loadDirectory = async (path) => {
                try {
                    const fs = await initFileSystem();
                    const directory = await fs.listDirectory(path);

                    const itemsContainer = dialog.querySelector('#media-picker-items');
                    const pathDisplay = dialog.querySelector('#media-picker-path');

                    itemsContainer.innerHTML = '';

                    // Update path display
                    pathDisplay.innerHTML = formatPath(path).split(' > ').map((part, index, arr) => {
                        if (index === arr.length - 1) return `<span>${part}</span>`;
                        const pathToPart = '/' + arr.slice(0, index + 1).join('/');
                        return `<span style="cursor: pointer; color: rgba(93, 173, 226, 0.8);" data-path="${pathToPart}">${part}</span>`;
                    }).join(' <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: inline-block; vertical-align: middle; margin: 0 4px;"><polyline points="9 18 15 12 9 6"></polyline></svg> ');

                    pathDisplay.querySelectorAll('[data-path]').forEach(span => {
                        span.addEventListener('click', () => {
                            currentPath = span.dataset.path;
                            pathHistory = pathHistory.slice(0, historyIndex + 1);
                            pathHistory.push(currentPath);
                            historyIndex = pathHistory.length - 1;
                            loadDirectory(currentPath);
                        });
                    });

                    const folders = directory.folders || [];
                    const files = directory.files || [];
                    const mediaFiles = files.filter(f => isMediaFile(f.name));
                    const allItems = [...folders.map(f => ({ ...f, type: 'folder' })), ...mediaFiles.map(f => ({ ...f, type: 'file' }))];

                    if (allItems.length === 0) {
                        itemsContainer.innerHTML = '<div style="color: rgba(255, 255, 255, 0.5); padding: 40px; text-align: center; grid-column: 1 / -1;">No media files in this directory</div>';
                    } else {
                        allItems.forEach(item => {
                            const el = document.createElement('div');
                            el.className = 'file-item';
                            el.dataset.path = item.path;
                            el.dataset.type = item.type;
                            el.dataset.name = item.name;

                            if (item.type === 'folder') {
                                el.innerHTML = `
                                    <div class="file-icon">${getFolderIcon()}</div>
                                    <div class="file-name">${item.name}</div>
                                `;
                                el.addEventListener('dblclick', () => {
                                    currentPath = item.path;
                                    pathHistory = pathHistory.slice(0, historyIndex + 1);
                                    pathHistory.push(currentPath);
                                    historyIndex = pathHistory.length - 1;
                                    loadDirectory(currentPath);
                                });
                                el.addEventListener('click', () => {
                                    currentPath = item.path;
                                    pathHistory = pathHistory.slice(0, historyIndex + 1);
                                    pathHistory.push(currentPath);
                                    historyIndex = pathHistory.length - 1;
                                    loadDirectory(currentPath);
                                });
                            } else {
                                el.innerHTML = `
                                    <div class="file-icon">${getFileIcon(item.name)}</div>
                                    <div class="file-name">${item.name}</div>
                                `;

                                const syncSelected = () => {
                                    el.classList.toggle('selected', selectedPaths.has(item.path));
                                };
                                syncSelected();

                                el.addEventListener('click', () => {
                                    if (!multiple) selectedPaths.clear();
                                    if (selectedPaths.has(item.path)) selectedPaths.delete(item.path);
                                    else selectedPaths.add(item.path);
                                    itemsContainer.querySelectorAll('.file-item').forEach((node) => {
                                        if (node.dataset.type === 'file') {
                                            node.classList.toggle('selected', selectedPaths.has(node.dataset.path));
                                        }
                                    });
                                });
                            }

                            itemsContainer.appendChild(el);
                        });
                    }

                    // Update navigation buttons
                    const backBtn = dialog.querySelector('#media-picker-back');
                    const forwardBtn = dialog.querySelector('#media-picker-forward');

                    if (backBtn) {
                        backBtn.disabled = historyIndex <= 0;
                        backBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
                        backBtn.style.cursor = historyIndex <= 0 ? 'not-allowed' : 'pointer';
                    }
                    if (forwardBtn) {
                        forwardBtn.disabled = historyIndex >= pathHistory.length - 1;
                        forwardBtn.style.opacity = historyIndex >= pathHistory.length - 1 ? '0.5' : '1';
                        forwardBtn.style.cursor = historyIndex >= pathHistory.length - 1 ? 'not-allowed' : 'pointer';
                    }
                } catch (error) {
                    const itemsContainer = dialog.querySelector('#media-picker-items');
                    itemsContainer.innerHTML = '<div style="color: rgba(255, 0, 0, 0.7); padding: 40px; text-align: center; grid-column: 1 / -1;">Error loading directory: ' + error.message + '</div>';
                    console.error('Error loading directory:', error);
                }
            };

            dialog.innerHTML = `
                <div class="window-header" style="padding: 10px 15px; background: rgba(25, 25, 35, 0.85); border-bottom: 1px solid rgba(255, 255, 255, 0.1); display: flex; align-items: center; justify-content: space-between;">
                    <div class="window-title" style="font-size: 14px; font-weight: 600; color: #5dade2; display: flex; align-items: center; gap: 8px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 18V5l12-2v13"></path>
                            <circle cx="6" cy="18" r="3"></circle>
                            <circle cx="18" cy="16" r="3"></circle>
                        </svg>
                        Select Media Files
                    </div>
                    <div class="window-controls" style="display: flex; gap: 8px;">
                        <div class="window-control close" id="media-picker-close" style="width: 18px; height: 18px; border-radius: 50%; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </div>
                    </div>
                </div>
                <div class="file-explorer-toolbar" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(25, 25, 35, 0.85); border-bottom: 1px solid rgba(255, 255, 255, 0.1); min-height: 44px;">
                    <div class="file-explorer-nav-buttons" style="display: flex; gap: 4px;">
                        <button class="nav-button" id="media-picker-back" title="Back" style="width: 32px; height: 32px; border: none; background: transparent; color: rgba(255, 255, 255, 0.7); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 12H5M12 19l-7-7 7-7"></path>
                            </svg>
                        </button>
                        <button class="nav-button" id="media-picker-forward" title="Forward" style="width: 32px; height: 32px; border: none; background: transparent; color: rgba(255, 255, 255, 0.7); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M5 12h14M12 5l7 7-7 7"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="file-explorer-address-bar" id="media-picker-path" style="flex: 1; padding: 6px 12px; background: rgba(40, 40, 50, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: flex; align-items: center; gap: 4px;">
                        ${formatPath(startPath)}
                    </div>
                </div>
                <div class="file-explorer-main" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(25, 25, 35, 0.85); position: relative;">
                    <div class="file-explorer-items grid-view" id="media-picker-items" style="flex: 1; padding: 16px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 16px; align-content: start;">
                    </div>
                </div>
                <div style="padding: 12px 16px; background: rgba(25, 25, 35, 0.85); border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="media-picker-cancel" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: rgba(255, 255, 255, 0.9); cursor: pointer; font-size: 13px; transition: background 0.2s;">Cancel</button>
                    <button id="media-picker-select" style="padding: 8px 16px; background: #5dade2; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 13px; font-weight: 600; transition: background 0.2s;">Select</button>
                </div>
            `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // Navigation button handlers
            const backBtn = dialog.querySelector('#media-picker-back');
            const forwardBtn = dialog.querySelector('#media-picker-forward');
            const closeBtn = dialog.querySelector('#media-picker-close');
            const cancelBtn = dialog.querySelector('#media-picker-cancel');
            const selectBtn = dialog.querySelector('#media-picker-select');

            if (backBtn) {
                backBtn.addEventListener('click', () => {
                    if (historyIndex > 0) {
                        historyIndex--;
                        currentPath = pathHistory[historyIndex];
                        loadDirectory(currentPath);
                    }
                });
            }
            if (forwardBtn) {
                forwardBtn.addEventListener('click', () => {
                    if (historyIndex < pathHistory.length - 1) {
                        historyIndex++;
                        currentPath = pathHistory[historyIndex];
                        loadDirectory(currentPath);
                    }
                });
            }
            if (closeBtn) closeBtn.addEventListener('click', () => close(null));
            if (cancelBtn) cancelBtn.addEventListener('click', () => close(null));
            if (selectBtn) {
                selectBtn.addEventListener('click', () => {
                    const arr = Array.from(selectedPaths);
                    if (arr.length === 0) {
                        alert('Please select a media file.');
                        return;
                    }
                    close(arr);
                });
            }

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) close(null);
            });

            // Load initial directory
            loadDirectory(currentPath);
        });
    }

    async function mediaItemFromFsPath(fsPath) {
        const fs = await initFileSystem();
        const file = await fs.getFile(fsPath);
        if (!file) return null;

        const name = file.name || String(fsPath).split('/').pop() || fsPath;
        const ext = getMediaExt(name);
        const kind = getMediaKindByExt(ext);
        if (!kind) return null;

        let blob = null;
        const content = await fs.getFileContent(fsPath);
        if (content instanceof Blob) {
            blob = content.type ? content : new Blob([await content.arrayBuffer()], { type: getMediaMimeTypeByExt(ext) });
        } else if (file.content instanceof ArrayBuffer) {
            blob = new Blob([file.content], { type: getMediaMimeTypeByExt(ext) });
        } else {
            return null;
        }

        const url = URL.createObjectURL(blob);
        return {
            id: `fs:${fsPath}`,
            sourceType: 'fs',
            name,
            kind,
            fsPath,
            url,
            _revokeUrl: true,
        };
    }

    // NOTE: We intentionally do not support host PC file selection in Player.

    const PLAYER_WINDOWS_STATE_KEY = 'playerWindowsState';

    function savePlayerWindowsState() {
        const playerWindows = Array.from(document.querySelectorAll('[data-player-window]'));
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
        const minLeft = 0;

        const windowsState = playerWindows.map(win => {
            const isMinimized = win.style.display === 'none';

            let left = parseInt(win.style.left) || win.offsetLeft || 200;
            let top = parseInt(win.style.top) || win.offsetTop || 100;
            let width = parseInt(win.style.width) || win.offsetWidth || 980;
            let height = parseInt(win.style.height) || win.offsetHeight || 640;

            if (width > viewportWidth - minLeft) width = Math.max(700, viewportWidth - minLeft - 20);
            if (height > viewportHeight) height = Math.max(420, viewportHeight - 20);

            const maxLeft = viewportWidth - width;
            const maxTop = viewportHeight - height;
            if (left < minLeft) left = minLeft;
            if (left > maxLeft) left = Math.max(minLeft, maxLeft);
            if (top < 0) top = 0;
            if (top > maxTop) top = Math.max(0, maxTop);

            const st = win._playerState || {};
            const fsOnly = Array.isArray(st.playlist) ? st.playlist.filter(it => it && it.sourceType === 'fs' && it.fsPath).map(it => it.fsPath) : [];
            const currentItem = (Number.isFinite(st.currentIndex) && st.currentIndex >= 0 && st.playlist && st.playlist[st.currentIndex]) ? st.playlist[st.currentIndex] : null;
            const currentFsPath = currentItem && currentItem.sourceType === 'fs' ? currentItem.fsPath : null;

            return {
                windowId: win.id,
                left: left + 'px',
                top: top + 'px',
                width: width + 'px',
                height: height + 'px',
                minimized: isMinimized,
                playlistFsPaths: fsOnly,
                currentFsPath,
                loop: !!st.loop,
                shuffle: !!st.shuffle
            };
        });

        try {
            localStorage.setItem(PLAYER_WINDOWS_STATE_KEY, JSON.stringify(windowsState));
        } catch (e) {}
    }

    globalSavePlayerWindowsState = savePlayerWindowsState;

    function getSavedPlayerWindowsState() {
        const saved = localStorage.getItem(PLAYER_WINDOWS_STATE_KEY);
        if (!saved) return [];
        try {
            const parsed = JSON.parse(saved);
            return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
            return [];
        }
    }

    function createPlayerWindow(initialItem = null, restoreState = null) {
        if (typeof initPlayer._count !== 'number') initPlayer._count = 0;
        const windowId = restoreState && restoreState.windowId ? restoreState.windowId : `player-window-${initPlayer._count++}`;

        const win = document.createElement('div');
        win.className = 'window';
        win.id = windowId;
        win.setAttribute('data-player-window', 'true');
        win.tabIndex = 0;

        // Restore minimized state early (before inserting into DOM) to avoid flicker on refresh.
        const isMinimized = !!(restoreState && restoreState.minimized);
        win.style.display = isMinimized ? 'none' : 'flex';

        if (restoreState) {
            win.style.left = restoreState.left || '220px';
            win.style.top = restoreState.top || '120px';
            win.style.width = restoreState.width || '980px';
            win.style.height = restoreState.height || '640px';
        } else {
            const staggeredPos = calculateStaggeredPosition('player', 220, 120);
            win.style.left = staggeredPos.left + 'px';
            win.style.top = staggeredPos.top + 'px';
            win.style.width = '980px';
            win.style.height = '630px';
        }

        win.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    ${PLAYER_ICON_16}
                    <span>Player</span>
                </div>
                <div class="window-controls">
                    <div class="window-control minimize" title="Minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize" title="Maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close" title="Close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content player-content">
                <div class="app-toolbar player-toolbar" role="toolbar" aria-label="Player toolbar">
                    <div class="player-toolbar-group">
                        <button class="nav-button" data-action="add-local" type="button" title="Add audio/video files">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                    </div>

                    <div class="player-toolbar-group">
                        <button class="nav-button" data-action="prev" type="button" title="Previous (P)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                                <line x1="5" y1="19" x2="5" y2="5"></line>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="toggle" type="button" title="Play/Pause (Space)">
                            <svg class="player-icon-play" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            <svg class="player-icon-pause" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                                <rect x="6" y="4" width="4" height="16"></rect>
                                <rect x="14" y="4" width="4" height="16"></rect>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="next" type="button" title="Next (N)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                                <line x1="19" y1="5" x2="19" y2="19"></line>
                            </svg>
                        </button>
                    </div>

                    <div class="player-toolbar-group player-toolbar-grow">
                        <input class="player-seek" type="range" min="0" max="100" value="0" step="0.1" aria-label="Seek" />
                        <div class="player-time" aria-label="Time">0:00 / 0:00</div>
                    </div>

                    <div class="player-toolbar-group">
                        <button class="nav-button" data-action="loop" type="button" title="Loop (L)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="17 1 21 5 17 9"></polyline>
                                <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
                                <polyline points="7 23 3 19 7 15"></polyline>
                                <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="shuffle" type="button" title="Shuffle (S)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="16 3 21 3 21 8"></polyline>
                                <line x1="4" y1="20" x2="21" y2="3"></line>
                                <polyline points="21 16 21 21 16 21"></polyline>
                                <line x1="15" y1="15" x2="21" y2="21"></line>
                                <line x1="4" y1="4" x2="9" y2="9"></line>
                            </svg>
                        </button>
                        <button class="nav-button nav-button-danger" data-action="clear" type="button" title="Clear queue">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
                                <path d="M10 11v6"></path>
                                <path d="M14 11v6"></path>
                                <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="player-body">
                    <div class="player-playlist-pane">
                        <div class="player-pane-title">Queue</div>
                        <div class="player-playlist" role="listbox" aria-label="Queue"></div>
                    </div>
                    <div class="player-stage empty" tabindex="0">
                        <video class="player-video" playsinline></video>
                        <audio class="player-audio"></audio>
                        <div class="player-drop-hint">
                            Drop audio/video here or click the download button to add files.
                            <div class="player-drop-hint-sub">Tip: In Files, you can also drag media files onto Player.</div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        windowsContainer.appendChild(win);
        makeWindowDraggable(win, { onDragEnd: savePlayerWindowsState });
        makeWindowResizable(win, { minWidth: 700, minHeight: 420, onResize: savePlayerWindowsState });

        addWindowToAppBar(win, {
            iconSvg: PLAYER_ICON_24,
            label: 'Player',
            onIconClick: () => toggleWindowFromDock(win, savePlayerWindowsState)
        });

        const state = {
            playlist: [],
            currentIndex: -1,
            loop: false,
            shuffle: false,
            order: [],
            orderCursor: -1,
        };
        // Store on the window so we can persist/restore on refresh.
        win._playerState = state;

        const playlistEl = win.querySelector('.player-playlist');
        const stageEl = win.querySelector('.player-stage');
        const videoEl = win.querySelector('.player-video');
        const audioEl = win.querySelector('.player-audio');
        const seekEl = win.querySelector('.player-seek');
        const timeEl = win.querySelector('.player-time');
        const playIcon = win.querySelector('.player-icon-play');
        const pauseIcon = win.querySelector('.player-icon-pause');

        let activeMediaEl = null;
        let isSeeking = false;

        // Match Files app tooltip styling by using the shared custom tooltip helper.
        const playerTooltips = {
            'add-local': 'Add Files',
            'prev': 'Previous (P)',
            'toggle': 'Play/Pause (Space)',
            'next': 'Next (N)',
            'loop': 'Loop (L)',
            'shuffle': 'Shuffle (S)',
            'clear': 'Clear queue'
        };
        win.querySelectorAll('.player-toolbar .nav-button').forEach((btn) => {
            const action = btn.getAttribute('data-action');
            const text = playerTooltips[action] || btn.getAttribute('title') || 'Action';
            setupNavButtonTooltip(btn, text);
        });

        function setPlayUi(isPlaying) {
            if (!playIcon || !pauseIcon) return;
            playIcon.style.display = isPlaying ? 'none' : 'block';
            pauseIcon.style.display = isPlaying ? 'block' : 'none';
        }

        function stopAllMedia() {
            [videoEl, audioEl].forEach(el => {
                if (!el) return;
                try {
                    el.pause();
                    el.removeAttribute('src');
                    el.load();
                } catch {}
            });
            activeMediaEl = null;
            setPlayUi(false);
        }

        function revokeAllUrls() {
            state.playlist.forEach(item => {
                if (item && item.url && item._revokeUrl) {
                    try { URL.revokeObjectURL(item.url); } catch {}
                }
            });
        }

        function rebuildOrder() {
            const n = state.playlist.length;
            const base = Array.from({ length: n }, (_, i) => i);
            if (!state.shuffle) {
                state.order = base;
                state.orderCursor = state.currentIndex >= 0 ? state.order.indexOf(state.currentIndex) : -1;
                return;
            }
            for (let i = base.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [base[i], base[j]] = [base[j], base[i]];
            }
            state.order = base;
            state.orderCursor = state.currentIndex >= 0 ? state.order.indexOf(state.currentIndex) : -1;
        }

        function renderPlaylist() {
            if (!playlistEl) return;
            playlistEl.innerHTML = '';
            state.playlist.forEach((item, idx) => {
                const row = document.createElement('div');
                row.className = 'player-track' + (idx === state.currentIndex ? ' active' : '');
                row.dataset.index = String(idx);
                row.innerHTML = `
                    <div class="player-track-icon">${item.kind === 'video' ? '' : ''}</div>
                    <div class="player-track-main">
                        <div class="player-track-name">${escapeHtml(String(item.name || 'Untitled'))}</div>
                        <div class="player-track-meta">${escapeHtml(item.sourceType === 'fs' ? String(item.fsPath || '') : 'Local file')}</div>
                    </div>
                    <button class="player-track-remove" type="button" aria-label="Remove"></button>
                `;

                row.addEventListener('click', (e) => {
                    const removeBtn = e.target && e.target.closest ? e.target.closest('.player-track-remove') : null;
                    if (removeBtn) return;
                    playIndex(idx);
                });

                const removeBtn = row.querySelector('.player-track-remove');
                if (removeBtn) {
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeIndex(idx);
                    });
                }

                playlistEl.appendChild(row);
            });
            stageEl.classList.toggle('empty', state.playlist.length === 0);
        }

        function removeIndex(idx) {
            if (idx < 0 || idx >= state.playlist.length) return;
            const [removed] = state.playlist.splice(idx, 1);
            if (removed && removed.url && removed._revokeUrl) {
                try { URL.revokeObjectURL(removed.url); } catch {}
            }
            if (state.currentIndex === idx) {
                stopAllMedia();
                state.currentIndex = -1;
            } else if (state.currentIndex > idx) {
                state.currentIndex -= 1;
            }
            rebuildOrder();
            renderPlaylist();
            savePlayerWindowsState();
        }

        function updateTimeUi() {
            if (!timeEl || !activeMediaEl) {
                if (timeEl) timeEl.textContent = '0:00 / 0:00';
                return;
            }
            const cur = activeMediaEl.currentTime || 0;
            const dur = Number.isFinite(activeMediaEl.duration) ? activeMediaEl.duration : 0;
            timeEl.textContent = `${formatTime(cur)} / ${formatTime(dur)}`;
        }

        function attachMediaEvents(mediaEl) {
            if (!mediaEl) return;
            mediaEl.addEventListener('loadedmetadata', () => {
                const dur = mediaEl.duration;
                if (seekEl && Number.isFinite(dur) && dur > 0) {
                    seekEl.max = String(dur);
                }
                if (seekEl && Number.isFinite(dur) && dur > 0) {
                    const pct = ((mediaEl.currentTime || 0) / dur) * 100;
                    seekEl.style.setProperty('--seek-percent', `${Math.max(0, Math.min(100, pct))}%`);
                }
                updateTimeUi();
            });
            mediaEl.addEventListener('timeupdate', () => {
                if (isSeeking) return;
                if (seekEl) {
                    seekEl.value = String(mediaEl.currentTime || 0);
                    const dur = Number.isFinite(mediaEl.duration) && mediaEl.duration > 0 ? mediaEl.duration : 0;
                    if (dur > 0) {
                        const pct = ((mediaEl.currentTime || 0) / dur) * 100;
                        seekEl.style.setProperty('--seek-percent', `${Math.max(0, Math.min(100, pct))}%`);
                    } else {
                        seekEl.style.setProperty('--seek-percent', `0%`);
                    }
                }
                updateTimeUi();
            });
            mediaEl.addEventListener('play', () => setPlayUi(true));
            mediaEl.addEventListener('pause', () => setPlayUi(false));
            mediaEl.addEventListener('ended', () => {
                if (state.loop && state.currentIndex >= 0) {
                    playIndex(state.currentIndex);
                } else {
                    playNext();
                }
            });
        }

        attachMediaEvents(videoEl);
        attachMediaEvents(audioEl);

        async function playIndex(idx, options = {}) {
            if (idx < 0 || idx >= state.playlist.length) return;
            const item = state.playlist[idx];
            state.currentIndex = idx;
            rebuildOrder();
            renderPlaylist();

            stopAllMedia();

            const isVideo = item.kind === 'video';
            if (videoEl) videoEl.style.display = isVideo ? 'block' : 'none';
            if (audioEl) audioEl.style.display = isVideo ? 'none' : 'block';
            activeMediaEl = isVideo ? videoEl : audioEl;

            if (!activeMediaEl) return;
            activeMediaEl.src = item.url;
            activeMediaEl.preload = 'metadata';

            try {
                if (options.autoplay === false) {
                    setPlayUi(false);
                } else {
                    await activeMediaEl.play();
                }
            } catch {
                setPlayUi(false);
            }
            updateTimeUi();
            savePlayerWindowsState();
        }

        function playPrev() {
            if (!state.playlist.length) return;
            if (!state.order.length) rebuildOrder();
            const cursor = state.orderCursor >= 0 ? state.orderCursor : state.order.indexOf(state.currentIndex);
            const nextCursor = cursor > 0 ? cursor - 1 : state.order.length - 1;
            state.orderCursor = nextCursor;
            playIndex(state.order[nextCursor]);
        }

        function playNext() {
            if (!state.playlist.length) return;
            if (!state.order.length) rebuildOrder();
            const cursor = state.orderCursor >= 0 ? state.orderCursor : state.order.indexOf(state.currentIndex);
            const nextCursor = cursor >= 0 ? (cursor + 1) % state.order.length : 0;
            state.orderCursor = nextCursor;
            playIndex(state.order[nextCursor]);
        }

        function togglePlayPause() {
            if (!activeMediaEl) {
                if (state.playlist.length) playIndex(state.currentIndex >= 0 ? state.currentIndex : 0);
                return;
            }
            if (activeMediaEl.paused) {
                activeMediaEl.play().catch(() => {});
            } else {
                activeMediaEl.pause();
            }
        }

        async function addFsPaths(paths, options = {}) {
            const unique = Array.from(new Set(paths.filter(Boolean)));
            const added = [];
            for (const p of unique) {
                const item = await mediaItemFromFsPath(p);
                if (item) added.push(item);
            }
            if (!added.length) {
                showNotification('No playable media files found.', 'warning', 3000);
                return;
            }
            state.playlist.push(...added);
            rebuildOrder();
            renderPlaylist();
            if (state.currentIndex < 0) {
                if (options.autoplay === false) {
                    state.currentIndex = 0;
                    rebuildOrder();
                    renderPlaylist();
                    savePlayerWindowsState();
                } else {
                    playIndex(0);
                }
            } else {
                savePlayerWindowsState();
            }
        }

        // Toolbar actions
        win.querySelector('[data-action="add-local"]')?.addEventListener('click', async (e) => {
            e.stopPropagation();
            const paths = await pickMediaFilesFromFilesystem({ multiple: true });
            if (paths && paths.length) {
                await addFsPaths(paths);
            }
        });
        win.querySelector('[data-action="prev"]')?.addEventListener('click', (e) => { e.stopPropagation(); playPrev(); });
        win.querySelector('[data-action="next"]')?.addEventListener('click', (e) => { e.stopPropagation(); playNext(); });
        win.querySelector('[data-action="toggle"]')?.addEventListener('click', (e) => { e.stopPropagation(); togglePlayPause(); });
        win.querySelector('[data-action="clear"]')?.addEventListener('click', (e) => {
            e.stopPropagation();
            stopAllMedia();
            revokeAllUrls();
            state.playlist = [];
            state.currentIndex = -1;
            rebuildOrder();
            renderPlaylist();
            savePlayerWindowsState();
        });
        win.querySelector('[data-action="loop"]')?.addEventListener('click', (e) => {
            e.stopPropagation();
            state.loop = !state.loop;
            win.querySelector('[data-action="loop"]')?.classList.toggle('active', state.loop);
            savePlayerWindowsState();
        });
        win.querySelector('[data-action="shuffle"]')?.addEventListener('click', (e) => {
            e.stopPropagation();
            state.shuffle = !state.shuffle;
            win.querySelector('[data-action="shuffle"]')?.classList.toggle('active', state.shuffle);
            rebuildOrder();
            savePlayerWindowsState();
        });

        // Seek control
        seekEl?.addEventListener('input', () => {
            if (!activeMediaEl) return;
            isSeeking = true;
            activeMediaEl.currentTime = Number(seekEl.value) || 0;
            const dur = Number.isFinite(activeMediaEl.duration) && activeMediaEl.duration > 0 ? activeMediaEl.duration : 0;
            if (dur > 0) {
                const pct = ((activeMediaEl.currentTime || 0) / dur) * 100;
                seekEl.style.setProperty('--seek-percent', `${Math.max(0, Math.min(100, pct))}%`);
            }
            updateTimeUi();
        });
        seekEl?.addEventListener('change', () => {
            isSeeking = false;
        });

        // Drop support
        stageEl?.addEventListener('dragover', (e) => {
            e.preventDefault();
            stageEl.classList.add('drag-over');
        });
        stageEl?.addEventListener('dragleave', (e) => {
            if (e.target === stageEl || !stageEl.contains(e.relatedTarget)) {
                stageEl.classList.remove('drag-over');
            }
        });
        stageEl?.addEventListener('drop', async (e) => {
            e.preventDefault();
            stageEl.classList.remove('drag-over');

            const dt = e.dataTransfer;
            const files = dt && dt.files ? Array.from(dt.files) : [];
            if (files.length) {
                showNotification('Host file drop is disabled. Import files into PilkOS Files first, then drag them into Player.', 'warning', 4500);
                return;
            }

            const p = dt && dt.getData ? dt.getData('text/plain') : '';
            if (p && String(p).startsWith('/')) {
                await addFsPaths([p]);
            }
        });

        // Keyboard shortcuts
        win.addEventListener('keydown', (e) => {
            const t = e.target;
            if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;

            const key = (e.key || '').toLowerCase();
            if (key === ' ') {
                e.preventDefault();
                togglePlayPause();
            } else if (key === 'n') {
                e.preventDefault();
                playNext();
            } else if (key === 'p') {
                e.preventDefault();
                playPrev();
            } else if (key === 'l') {
                e.preventDefault();
                state.loop = !state.loop;
                win.querySelector('[data-action="loop"]')?.classList.toggle('active', state.loop);
            } else if (key === 's') {
                e.preventDefault();
                state.shuffle = !state.shuffle;
                win.querySelector('[data-action="shuffle"]')?.classList.toggle('active', state.shuffle);
                rebuildOrder();
            } else if (e.key === 'ArrowRight') {
                if (!activeMediaEl) return;
                e.preventDefault();
                activeMediaEl.currentTime = Math.min(activeMediaEl.currentTime + 5, Number.isFinite(activeMediaEl.duration) ? activeMediaEl.duration : activeMediaEl.currentTime + 5);
            } else if (e.key === 'ArrowLeft') {
                if (!activeMediaEl) return;
                e.preventDefault();
                activeMediaEl.currentTime = Math.max(0, activeMediaEl.currentTime - 5);
            }
        });

        // Window controls
        const closeBtn = win.querySelector('.window-control.close');
        const minimizeBtn = win.querySelector('.window-control.minimize');
        const maximizeBtn = win.querySelector('.window-control.maximize');
        let isMaximized = false;
        let originalPos = null;

        if (closeBtn) {
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                stopAllMedia();
                revokeAllUrls();
                const id = win.id;
                win.remove();
                savePlayerWindowsState();
                if (id) removeWindowFromAppBar(id);
            });
        }

        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const minimized = win.style.display === 'none';
                if (minimized) {
                    win.style.display = 'flex';
                    focusWindow(win);
                    updateWindowAppBarState(win, true, false);
                } else {
                    win.style.display = 'none';
                    win.classList.remove('window-focused');
                    updateWindowAppBarState(win, false, true);
                }
                savePlayerWindowsState();
            });
        }

        if (maximizeBtn) {
            maximizeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isMaximized) {
                    if (originalPos) {
                        win.style.left = originalPos.left;
                        win.style.top = originalPos.top;
                        win.style.width = originalPos.width;
                        win.style.height = originalPos.height;
                    }
                    isMaximized = false;
                } else {
                    originalPos = {
                        left: win.style.left,
                        top: win.style.top,
                        width: win.style.width,
                        height: win.style.height,
                    };
                    maximizeWindowToBounds(win);
                    isMaximized = true;
                }
                validateAndFixWindowPosition(win);
            });
        }

        win.addEventListener('mousedown', () => {
            if (win.style.display !== 'none') focusWindow(win);
        });

        // Kickstart
        renderPlaylist();
        if (restoreState) {
            state.loop = !!restoreState.loop;
            state.shuffle = !!restoreState.shuffle;
            win.querySelector('[data-action="loop"]')?.classList.toggle('active', state.loop);
            win.querySelector('[data-action="shuffle"]')?.classList.toggle('active', state.shuffle);

            const fsPaths = Array.isArray(restoreState.playlistFsPaths) ? restoreState.playlistFsPaths : [];
            if (fsPaths.length) {
                addFsPaths(fsPaths, { autoplay: false }).then(() => {
                    const wanted = restoreState.currentFsPath;
                    if (wanted) {
                        const idx = state.playlist.findIndex(it => it && it.sourceType === 'fs' && it.fsPath === wanted);
                        if (idx >= 0) {
                            playIndex(idx, { autoplay: false });
                        }
                    }
                });
            }
        } else if (initialItem) {
            if (typeof initialItem === 'string') {
                addFsPaths([initialItem]);
            } else {
                // Ignore host files/objects; Player only supports PilkOS filesystem paths.
                showNotification('Player only supports media from PilkOS Files.', 'warning', 3500);
            }
        }

        if (!isMinimized) {
            focusWindow(win);
            updateWindowAppBarState(win, true, false);
        } else {
            updateWindowAppBarState(win, false, true);
        }
        savePlayerWindowsState();
        return win;
    }

    if (!playerInitialized) {
        playerInitialized = true;
        const saved = getSavedPlayerWindowsState();
        if (saved.length) {
            // Ensure new windows don't collide with restored IDs.
            const maxIndex = saved
                .map(s => String(s.windowId || '').match(/^player-window-(\d+)$/))
                .map(m => (m ? parseInt(m[1], 10) : -1))
                .reduce((a, b) => Math.max(a, b), -1);
            if (Number.isFinite(maxIndex) && maxIndex >= 0) {
                initPlayer._count = Math.max(typeof initPlayer._count === 'number' ? initPlayer._count : 0, maxIndex + 1);
            }
            saved.forEach(st => createPlayerWindow(null, st));
        }
    }

    return function openPlayer(initial = null) {
        return createPlayerWindow(initial);
    };
}

// Viewer App (Image Viewer)
let viewerWindowCount = 0;
let viewerInitialized = false;

function isViewerImageFileName(fileName) {
    const ext = String(fileName || '').split('.').pop().toLowerCase();
    const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
    return imageExts.includes(ext);
}

function initViewer() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');

    if (!windowsContainer || !dockApps) {
        // If DOM isn't ready yet, try again after a short delay
        setTimeout(() => {
            initViewer();
        }, 100);
        return;
    }

    function saveViewerWindowsState() {
        const viewerWindows = Array.from(document.querySelectorAll('[data-viewer-window]'));
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
        const minLeft = 0;

        const windowsState = viewerWindows.map(win => {
            const isMinimized = win.style.display === 'none';

            // Get current position and dimensions
            let left = parseInt(win.style.left) || win.offsetLeft || 200;
            let top = parseInt(win.style.top) || win.offsetTop || 100;
            let width = parseInt(win.style.width) || win.offsetWidth || 900;
            let height = parseInt(win.style.height) || win.offsetHeight || 650;

            // Sanitize saved width/height aren't too large
            if (width > viewportWidth - minLeft) {
                width = Math.max(520, viewportWidth - minLeft - 20);
            }
            if (height > viewportHeight) {
                height = Math.max(360, viewportHeight - 20);
            }

            // Sanitize saved position - keep fully on-screen
            const maxLeft = viewportWidth - width;
            if (left > maxLeft || left + width > viewportWidth) {
                left = Math.max(minLeft, maxLeft);
            }
            if (left < minLeft) left = minLeft;
            if (top < 0) top = 0;
            const maxTop = viewportHeight - height;
            if (top > maxTop) top = Math.max(0, maxTop);

            const state = (win._viewerState || {});
            return {
                windowId: win.id,
                left: left + 'px',
                top: top + 'px',
                width: width + 'px',
                height: height + 'px',
                minimized: isMinimized,
                currentPath: state.currentPath || null,
                rotation: Number.isFinite(state.rotation) ? state.rotation : 0,
                zoom: Number.isFinite(state.zoom) ? state.zoom : 1,
                fitMode: state.fitMode || 'fit'
            };
        });

        localStorage.setItem('viewerWindowsState', JSON.stringify(windowsState));
    }

    function getSavedViewerWindowsState() {
        const saved = localStorage.getItem('viewerWindowsState');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                return [];
            }
        }
        return [];
    }

    function createViewerWindow(initialImagePath = null, restoreState = null) {
        const windowId = restoreState ? restoreState.windowId : `viewer-window-${viewerWindowCount++}`;
        const win = document.createElement('div');
        win.className = 'window';
        win.id = windowId;
        win.setAttribute('id', windowId);
        win.setAttribute('data-viewer-window', 'true');
        win.tabIndex = 0;

        // Restore minimized state early (before inserting into DOM) to avoid flicker on refresh.
        const isMinimized = !!(restoreState && restoreState.minimized);
        win.style.display = isMinimized ? 'none' : 'flex';

        // Use restore state if provided, otherwise use defaults
        if (restoreState) {
            // Sanitize saved position values before applying them
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
            const minLeft = 0;

            let savedLeft = parseInt(restoreState.left) || 200;
            let savedTop = parseInt(restoreState.top) || 100;
            let savedWidth = parseInt(restoreState.width) || 900;
            let savedHeight = parseInt(restoreState.height) || 650;

            if (savedWidth > viewportWidth - minLeft) {
                savedWidth = Math.max(520, viewportWidth - minLeft - 20);
            }
            if (savedHeight > viewportHeight) {
                savedHeight = Math.max(360, viewportHeight - 20);
            }

            const maxLeft = viewportWidth - savedWidth;
            if (savedLeft > maxLeft || savedLeft + savedWidth > viewportWidth) {
                savedLeft = Math.max(minLeft, maxLeft);
            }
            if (savedLeft < minLeft) savedLeft = minLeft;

            const maxTop = viewportHeight - savedHeight;
            if (savedTop > maxTop) savedTop = Math.max(0, maxTop);
            if (savedTop < 0) savedTop = 0;

            win.style.left = savedLeft + 'px';
            win.style.top = savedTop + 'px';
            win.style.width = savedWidth + 'px';
            win.style.height = savedHeight + 'px';
        } else {
            const staggeredPos = calculateStaggeredPosition('viewer', 200, 100);
            win.style.left = staggeredPos.left + 'px';
            win.style.top = staggeredPos.top + 'px';
            win.style.width = '900px';
            win.style.height = '650px';
        }

        setTimeout(() => {
            validateAndFixWindowPosition(win);
        }, 0);

        win.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                    <span class="viewer-title-text">Viewer</span>
                </div>
                <div class="window-controls">
                    <div class="window-control minimize" title="Minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize" title="Maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close" title="Close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content viewer-content">
                <div class="viewer-toolbar" role="toolbar" aria-label="Viewer toolbar">
                    <div class="viewer-toolbar-group">
                        <button class="nav-button" data-action="open" type="button" title="Open (O)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 7h5l2 3h11v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"></path>
                                <path d="M3 7V5a2 2 0 0 1 2-2h4l2 3h9a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="viewer-toolbar-group">
                        <button class="nav-button" data-action="prev" type="button" title="Previous ()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M15 18l-6-6 6-6"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="next" type="button" title="Next ()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 18l6-6-6-6"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="viewer-toolbar-group">
                        <button class="nav-button" data-action="zoomOut" type="button" title="Zoom out (-)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                <line x1="8" y1="11" x2="14" y2="11"></line>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="zoomIn" type="button" title="Zoom in (+)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="11" cy="11" r="8"></circle>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                <line x1="11" y1="8" x2="11" y2="14"></line>
                                <line x1="8" y1="11" x2="14" y2="11"></line>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="fit" type="button" title="Fit width (0)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8 3H5a2 2 0 0 0-2 2v3"></path>
                                <path d="M16 3h3a2 2 0 0 1 2 2v3"></path>
                                <path d="M8 21H5a2 2 0 0 1-2-2v-3"></path>
                                <path d="M16 21h3a2 2 0 0 0 2-2v-3"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="actual" type="button" title="Actual size (1)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="4" y="4" width="16" height="16" rx="2"></rect>
                                <path d="M8 8h8v8H8z"></path>
                            </svg>
                        </button>
                        <div class="viewer-zoom" aria-label="Zoom level"><span data-role="zoomText">100%</span></div>
                    </div>
                    <div class="viewer-toolbar-group">
                        <button class="nav-button" data-action="rotateLeft" type="button" title="Rotate right (Shift+R)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 2v6h-6"></path>
                                <path d="M3 12a9 9 0 0 1 15-6.7L21 8"></path>
                                <path d="M3 12a9 9 0 0 0 9 9"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="rotateRight" type="button" title="Rotate left (R)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 2v6h6"></path>
                                <path d="M21 12a9 9 0 0 0-15-6.7L3 8"></path>
                                <path d="M21 12a9 9 0 0 1-9 9"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="viewer-stage" tabindex="0" aria-label="Image viewer">
                    <div class="viewer-drop-hint">Drop an image here or click Open</div>
                    <img class="viewer-image" alt="" draggable="false" />
                </div>
            </div>
            <div class="window-resize-handle n"></div>
            <div class="window-resize-handle s"></div>
            <div class="window-resize-handle e"></div>
            <div class="window-resize-handle w"></div>
            <div class="window-resize-handle ne"></div>
            <div class="window-resize-handle nw"></div>
            <div class="window-resize-handle se"></div>
            <div class="window-resize-handle sw"></div>
        `;

        windowsContainer.appendChild(win);

        const state = {
            items: [],
            index: 0,
            currentPath: null,
            zoom: 1,
            rotation: 0,
            fitMode: 'fitWidth'
        };
        if (restoreState) {
            if (Number.isFinite(restoreState.zoom)) state.zoom = restoreState.zoom;
            if (Number.isFinite(restoreState.rotation)) state.rotation = restoreState.rotation;
            if (restoreState.fitMode) state.fitMode = restoreState.fitMode;
            if (restoreState.currentPath) state.currentPath = restoreState.currentPath;
        }
        win._viewerState = state;

        // Add icon to App bar
        addWindowToAppBar(win, {
            iconSvg: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>`,
            onIconClick: function() {
                toggleWindowFromDock(win, saveViewerWindowsState);
            }
        });
        updateWindowAppBarState(win, false, isMinimized);

        // Focus the window (unless minimized)
        if (!isMinimized) {
            focusWindow(win);
        }

        // Draggable / resizable
        makeWindowDraggable(win, { onDragEnd: saveViewerWindowsState });
        makeWindowResizable(win, { onResize: saveViewerWindowsState });

        // Focus window when clicked
        win.addEventListener('mousedown', function() {
            if (win.style.display !== 'none') {
                focusWindow(win);
                try { win.focus(); } catch (e) {}
            }
        });

        const titleTextEl = win.querySelector('.viewer-title-text');
        const stage = win.querySelector('.viewer-stage');
        const img = win.querySelector('.viewer-image');
        const zoomText = win.querySelector('[data-role="zoomText"]');

        function clampZoom(z) {
            return Math.max(0.05, Math.min(20, z));
        }

        function applyTransform() {
            if (!img) return;
            img.style.transform = `translate3d(0,0,0) scale(${state.zoom}) rotate(${state.rotation}deg)`;
            if (zoomText) {
                zoomText.textContent = `${Math.round(state.zoom * 100)}%`;
            }
        }

        function getCurrentItem() {
            return state.items && state.items.length ? state.items[state.index] : null;
        }

        function updateNavButtons() {
            const prevBtn = win.querySelector('[data-action="prev"]');
            const nextBtn = win.querySelector('[data-action="next"]');
            const hasItems = state.items && state.items.length > 0;
            if (prevBtn) prevBtn.disabled = !hasItems || state.index <= 0;
            if (nextBtn) nextBtn.disabled = !hasItems || state.index >= state.items.length - 1;
        }

        function setTitleForItem(item) {
            if (!titleTextEl) return;
            if (!item) {
                titleTextEl.textContent = 'Viewer';
                return;
            }
            const name = item.name || (item.path ? item.path.split('/').pop() : '');
            titleTextEl.textContent = name ? `Viewer  ${name}` : 'Viewer';
        }

        function computeFitWidthZoom() {
            if (!stage || !img) return 1;
            const iw = img.naturalWidth || 0;
            const ih = img.naturalHeight || 0;
            if (!iw || !ih) return 1;

            const rect = stage.getBoundingClientRect();
            const pad = 24;
            const usableW = Math.max(10, rect.width - pad);

            const rot = ((state.rotation % 360) + 360) % 360;
            const swap = rot === 90 || rot === 270;
            const rw = swap ? ih : iw;
            const fitWidth = usableW / rw;
            return clampZoom(fitWidth);
        }

        function fitToWidth() {
            state.zoom = computeFitWidthZoom();
            applyTransform();
        }

        async function buildFolderImageList(targetPath) {
            const fs = await initFileSystem();
            const parentPath = fs.getParentPath(targetPath);
            let directory = null;
            try {
                directory = await fs.listDirectory(parentPath);
            } catch (e) {
                directory = { files: [] };
            }

            const files = (directory && directory.files) ? directory.files : [];
            const images = files
                .filter(f => f && isViewerImageFileName(f.name))
                .slice()
                .sort((a, b) => (a.name || '').localeCompare(b.name || '', undefined, { numeric: true, sensitivity: 'base' }));

            state.items = images.map(f => ({ path: f.path, name: f.name }));
            const idx = state.items.findIndex(it => it.path === targetPath);
            state.index = idx >= 0 ? idx : 0;
            state.currentPath = targetPath;
        }

        async function openCurrent() {
            const item = getCurrentItem();
            if (!item) {
                if (img) img.removeAttribute('src');
                setTitleForItem(null);
                updateNavButtons();
                if (stage) stage.classList.add('empty');
                saveViewerWindowsState();
                return;
            }

            setTitleForItem(item);
            updateNavButtons();
            if (stage) stage.classList.remove('empty');

            const url = await getImageUrlFromFilesystem(item.path);
            if (!url) return;

            img.alt = item.name || '';
            img.src = url;

            // Default to fit for newly-opened images
            img.onload = () => {
                if (state.fitMode === 'fitWidth') {
                    fitToWidth();
                } else {
                    applyTransform();
                }
            };

            saveViewerWindowsState();
        }

        async function openImagePath(imagePath) {
            if (!imagePath) return;
            await buildFolderImageList(imagePath);
            state.fitMode = 'fitWidth';
            await openCurrent();
        }

        // Toolbar actions
        function onAction(action) {
            if (!action) return;
            if (action === 'open') {
                (async () => {
                    const selected = await showImageFilePicker();
                    if (selected) {
                        await openImagePath(selected);
                    }
                })();
                return;
            }
            if (action === 'prev') {
                if (state.items && state.index > 0) {
                    state.index--;
                    state.fitMode = 'fitWidth';
                    openCurrent();
                }
                return;
            }
            if (action === 'next') {
                if (state.items && state.index < state.items.length - 1) {
                    state.index++;
                    state.fitMode = 'fitWidth';
                    openCurrent();
                }
                return;
            }
            if (action === 'zoomIn') {
                state.fitMode = 'manual';
                state.zoom = clampZoom(state.zoom * 1.1);
                applyTransform();
                saveViewerWindowsState();
                return;
            }
            if (action === 'zoomOut') {
                state.fitMode = 'manual';
                state.zoom = clampZoom(state.zoom / 1.1);
                applyTransform();
                saveViewerWindowsState();
                return;
            }
            if (action === 'fit') {
                state.fitMode = 'fitWidth';
                fitToWidth();
                saveViewerWindowsState();
                return;
            }
            if (action === 'actual') {
                state.fitMode = 'manual';
                state.zoom = 1;
                applyTransform();
                saveViewerWindowsState();
                return;
            }
            if (action === 'rotateLeft') {
                state.rotation = (state.rotation - 90) % 360;
                if (state.fitMode === 'fitWidth') fitToWidth();
                else applyTransform();
                saveViewerWindowsState();
                return;
            }
            if (action === 'rotateRight') {
                state.rotation = (state.rotation + 90) % 360;
                if (state.fitMode === 'fitWidth') fitToWidth();
                else applyTransform();
                saveViewerWindowsState();
                return;
            }
            // Fullscreen button removed from toolbar.
        }

        // Hook toolbar + apply Files-style tooltips
        const viewerToolbarTooltips = {
            open: 'Open',
            prev: 'Previous',
            next: 'Next',
            zoomOut: 'Zoom Out',
            zoomIn: 'Zoom In',
            fit: 'Fit Width',
            actual: 'Actual Size',
            // Match the arrow directions on the rotate icons.
            rotateLeft: 'Rotate Right',
            rotateRight: 'Rotate Left'
        };

        win.querySelectorAll('.viewer-toolbar [data-action]').forEach(btn => {
            const action = btn.dataset.action;
            if (action && viewerToolbarTooltips[action]) {
                setupNavButtonTooltip(btn, viewerToolbarTooltips[action]);
            }
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                onAction(action);
            });
        });

        // Drag/drop (virtual FS paths)
        if (stage) {
            stage.classList.add('empty');
            stage.addEventListener('dragover', (e) => {
                const p = e.dataTransfer && e.dataTransfer.getData && e.dataTransfer.getData('text/plain');
                if (p && isViewerImageFileName(p)) {
                    e.preventDefault();
                    e.stopPropagation();
                    stage.classList.add('drag-over');
                }
            });
            stage.addEventListener('dragleave', () => {
                stage.classList.remove('drag-over');
            });
            stage.addEventListener('drop', (e) => {
                stage.classList.remove('drag-over');
                const p = e.dataTransfer && e.dataTransfer.getData && e.dataTransfer.getData('text/plain');
                if (p && isViewerImageFileName(p)) {
                    e.preventDefault();
                    e.stopPropagation();
                    openImagePath(p);
                }
            });
        }

        // Wheel zoom (Ctrl + wheel)
        if (stage) {
            stage.addEventListener('wheel', (e) => {
                if (!e.ctrlKey) return;
                e.preventDefault();
                state.fitMode = 'manual';
                const delta = e.deltaY || 0;
                const factor = delta > 0 ? (1 / 1.06) : 1.06;
                state.zoom = clampZoom(state.zoom * factor);
                applyTransform();
                saveViewerWindowsState();
            }, { passive: false });
        }

        // Keyboard shortcuts (when Viewer window focused)
        win.addEventListener('keydown', (e) => {
            if (e.defaultPrevented) return;
            const key = e.key;
            if (key === 'ArrowLeft') {
                e.preventDefault();
                onAction('prev');
            } else if (key === 'ArrowRight') {
                e.preventDefault();
                onAction('next');
            } else if (key === '+' || key === '=') {
                e.preventDefault();
                onAction('zoomIn');
            } else if (key === '-' || key === '_') {
                e.preventDefault();
                onAction('zoomOut');
            } else if (key === '0') {
                e.preventDefault();
                onAction('fit');
            } else if (key === '1') {
                e.preventDefault();
                onAction('actual');
            } else if (key.toLowerCase() === 'r') {
                e.preventDefault();
                onAction(e.shiftKey ? 'rotateLeft' : 'rotateRight');
            } else if (key.toLowerCase() === 'o') {
                e.preventDefault();
                onAction('open');
            }
        });

        // Window controls
        const closeBtn = win.querySelector('.window-control.close');
        const minimizeBtn = win.querySelector('.window-control.minimize');
        const maximizeBtn = win.querySelector('.window-control.maximize');
        let isMaximized = false;
        let originalPos = null;

        if (closeBtn) {
            closeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const id = win.id;
                win.remove();
                saveViewerWindowsState();
                if (id) removeWindowFromAppBar(id);
            });
        }

        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const minimized = win.style.display === 'none';
                if (minimized) {
                    win.style.display = 'flex';
                    focusWindow(win);
                    updateWindowAppBarState(win, true, false);
                } else {
                    win.style.display = 'none';
                    win.classList.remove('window-focused');
                    updateWindowAppBarState(win, false, true);
                }
                saveViewerWindowsState();
            });
        }

        if (maximizeBtn) {
            maximizeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (isMaximized) {
                    if (originalPos) {
                        win.style.left = originalPos.left;
                        win.style.top = originalPos.top;
                        win.style.width = originalPos.width;
                        win.style.height = originalPos.height;
                    }
                    isMaximized = false;
                } else {
                    originalPos = {
                        left: win.style.left,
                        top: win.style.top,
                        width: win.style.width,
                        height: win.style.height
                    };
                    maximizeWindowToBounds(win);
                    isMaximized = true;
                }

                setTimeout(() => {
                    if (state.fitMode === 'fitWidth') fitToWidth();
                }, 0);
                saveViewerWindowsState();
            });
        }

        // Initial UI state
        applyTransform();
        updateNavButtons();
        saveViewerWindowsState();

        // Open initial image (if any)
        const pathToOpen = (restoreState && restoreState.currentPath) ? restoreState.currentPath : initialImagePath;
        if (pathToOpen) {
            setTimeout(() => {
                openImagePath(pathToOpen);
            }, 0);
        }

        return win;
    }

    // Restore all windows on first init
    if (!viewerInitialized) {
        viewerInitialized = true;
        const saved = getSavedViewerWindowsState();
        if (saved && saved.length > 0) {
            saved.forEach(st => {
                createViewerWindow(null, st);
            });
        }
    }

    return function(imagePath = null) {
        createViewerWindow(imagePath);
    };
}

// Paint App
let paintWindowCount = 0;
let paintInitialized = false;

function initPaint() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');

    if (!windowsContainer || !dockApps) {
        setTimeout(() => initPaint(), 100);
        return;
    }

    const PAINT_STATE_KEY = 'paintWindowsStateV1';

    function getSavedPaintWindowsState() {
        const raw = localStorage.getItem(PAINT_STATE_KEY);
        if (!raw) return [];
        try {
            const parsed = JSON.parse(raw);
            return Array.isArray(parsed) ? parsed : [];
        } catch {
            return [];
        }
    }

    function savePaintWindowsState() {
        const paintWindows = Array.from(document.querySelectorAll('[data-paint-window]'));
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
        const minLeft = 0;

        const state = paintWindows.map(win => {
            const minimized = win.style.display === 'none';

            let left = parseInt(win.style.left) || win.offsetLeft || 200;
            let top = parseInt(win.style.top) || win.offsetTop || 100;
            let width = parseInt(win.style.width) || win.offsetWidth || 900;
            let height = parseInt(win.style.height) || win.offsetHeight || 650;

            if (width > viewportWidth - minLeft) width = Math.max(520, viewportWidth - minLeft - 20);
            if (height > viewportHeight) height = Math.max(360, viewportHeight - 20);

            const maxLeft = viewportWidth - width;
            if (left > maxLeft || left + width > viewportWidth) left = Math.max(minLeft, maxLeft);
            if (left < minLeft) left = minLeft;

            const maxTop = viewportHeight - height;
            if (top > maxTop) top = Math.max(0, maxTop);
            if (top < 0) top = 0;

            const ps = win._paintState || {};
            return {
                windowId: win.id,
                left: left + 'px',
                top: top + 'px',
                width: width + 'px',
                height: height + 'px',
                minimized,
                tool: ps.tool || 'brush',
                color: ps.color || '#5dade2',
                size: Number.isFinite(ps.size) ? ps.size : 8,
                bg: ps.bg || 'transparent'
            };
        });

        try {
            localStorage.setItem(PAINT_STATE_KEY, JSON.stringify(state));
        } catch (e) {}
    }

    function createPaintWindow(restoreState = null) {
        const windowId = restoreState ? restoreState.windowId : `paint-window-${paintWindowCount++}`;
        const win = document.createElement('div');
        win.className = 'window';
        win.id = windowId;
        win.setAttribute('id', windowId);
        win.setAttribute('data-paint-window', 'true');
        win.tabIndex = 0;

        const isMinimized = !!(restoreState && restoreState.minimized);
        win.style.display = isMinimized ? 'none' : 'flex';

        if (restoreState) {
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
            const minLeft = 0;

            let savedLeft = parseInt(restoreState.left) || 200;
            let savedTop = parseInt(restoreState.top) || 100;
            let savedWidth = parseInt(restoreState.width) || 900;
            let savedHeight = parseInt(restoreState.height) || 650;

            if (savedWidth > viewportWidth - minLeft) savedWidth = Math.max(520, viewportWidth - minLeft - 20);
            if (savedHeight > viewportHeight) savedHeight = Math.max(360, viewportHeight - 20);

            const maxLeft = viewportWidth - savedWidth;
            if (savedLeft > maxLeft || savedLeft + savedWidth > viewportWidth) savedLeft = Math.max(minLeft, maxLeft);
            if (savedLeft < minLeft) savedLeft = minLeft;

            const maxTop = viewportHeight - savedHeight;
            if (savedTop > maxTop) savedTop = Math.max(0, maxTop);
            if (savedTop < 0) savedTop = 0;

            win.style.left = savedLeft + 'px';
            win.style.top = savedTop + 'px';
            win.style.width = savedWidth + 'px';
            win.style.height = savedHeight + 'px';
        } else {
            const staggeredPos = calculateStaggeredPosition('paint', 200, 100);
            win.style.left = staggeredPos.left + 'px';
            win.style.top = staggeredPos.top + 'px';
            win.style.width = '980px';
            win.style.height = '720px';
        }

        setTimeout(() => validateAndFixWindowPosition(win), 0);

        win.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                    </svg>
                    <span class="paint-title-text">Paint</span>
                </div>
                <div class="window-controls">
                    <div class="window-control minimize" title="Minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize" title="Maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close" title="Close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content paint-content">
                <div class="paint-toolbar" role="toolbar" aria-label="Paint toolbar">
                    <div class="paint-toolbar-group">
                        <button class="nav-button paint-tool-btn" data-tool="brush" type="button" title="Brush (B)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                            </svg>
                        </button>
                        <button class="nav-button paint-tool-btn" data-tool="eraser" type="button" title="Eraser (E)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 20H8l-6-6 10-10a2.828 2.828 0 0 1 4 0l6 6-8 8"></path>
                                <path d="M6 18l6-6"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="paint-toolbar-group paint-toolbar-group-grow">
                        <label class="paint-field" title="Color">
                            <span class="paint-field-label">Color</span>
                            <input class="paint-color" type="color" value="#5dade2" />
                        </label>
                        <label class="paint-field paint-field-grow" title="Size">
                            <span class="paint-field-label">Size</span>
                            <input class="paint-size" type="range" min="1" max="64" value="8" />
                            <span class="paint-size-text" aria-label="Brush size">8</span>
                        </label>
                        <button class="nav-button paint-bg-btn" type="button" title="Toggle background (Transparent / White)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                                <path d="M3 9h18"></path>
                                <path d="M9 3v18"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="paint-toolbar-group">
                        <button class="nav-button" data-action="undo" type="button" title="Undo (Ctrl+Z)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 7v6h6"></path>
                                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="redo" type="button" title="Redo (Ctrl+Y)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 7v6h-6"></path>
                                <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="clear" type="button" title="Clear">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 6h18"></path>
                                <path d="M8 6V4h8v2"></path>
                                <path d="M10 11v6"></path>
                                <path d="M14 11v6"></path>
                                <path d="M6 6l1 16h10l1-16"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="paint-toolbar-group">
                        <button class="nav-button" data-action="open" type="button" title="Open image">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 7h5l2 3h11v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"></path>
                                <path d="M3 7V5a2 2 0 0 1 2-2h4l2 3h9a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                        <button class="nav-button" data-action="save" type="button" title="Save as PNG">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                        <input class="paint-file-input" type="file" accept="image/*" style="display:none;" />
                    </div>
                </div>
                <div class="paint-stage" tabindex="0" aria-label="Canvas">
                    <canvas class="paint-canvas"></canvas>
                </div>
            </div>
            <div class="window-resize-handle n"></div>
            <div class="window-resize-handle s"></div>
            <div class="window-resize-handle e"></div>
            <div class="window-resize-handle w"></div>
            <div class="window-resize-handle ne"></div>
            <div class="window-resize-handle nw"></div>
            <div class="window-resize-handle se"></div>
            <div class="window-resize-handle sw"></div>
        `;

        windowsContainer.appendChild(win);

        const ps = {
            tool: restoreState && restoreState.tool ? restoreState.tool : 'brush',
            color: restoreState && restoreState.color ? restoreState.color : '#5dade2',
            size: restoreState && Number.isFinite(restoreState.size) ? restoreState.size : 8,
            bg: restoreState && restoreState.bg ? restoreState.bg : 'transparent',
            undo: [],
            redo: [],
            restoring: false
        };
        win._paintState = ps;

        addWindowToAppBar(win, {
            iconSvg: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
            </svg>`,
            onIconClick: () => toggleWindowFromDock(win, savePaintWindowsState)
        });
        updateWindowAppBarState(win, false, isMinimized);

        if (!isMinimized) focusWindow(win);

        makeWindowDraggable(win, { onDragEnd: savePaintWindowsState });
        makeWindowResizable(win, { onResize: savePaintWindowsState });

        win.addEventListener('mousedown', () => {
            if (win.style.display !== 'none') {
                focusWindow(win);
                try { win.focus(); } catch (e) {}
            }
        });

        const stage = win.querySelector('.paint-stage');
        const canvas = win.querySelector('.paint-canvas');
        const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;
        const toolBtns = Array.from(win.querySelectorAll('.paint-tool-btn'));
        const colorInput = win.querySelector('.paint-color');
        const sizeInput = win.querySelector('.paint-size');
        const sizeText = win.querySelector('.paint-size-text');
        const bgBtn = win.querySelector('.paint-bg-btn');
        const fileInput = win.querySelector('.paint-file-input');

        const btnUndo = win.querySelector('[data-action="undo"]');
        const btnRedo = win.querySelector('[data-action="redo"]');
        const btnClear = win.querySelector('[data-action="clear"]');
        const btnOpen = win.querySelector('[data-action="open"]');
        const btnSave = win.querySelector('[data-action="save"]');

        function setBg(bg) {
            ps.bg = bg === 'white' ? 'white' : 'transparent';
            if (stage) stage.classList.toggle('paint-bg-white', ps.bg === 'white');
            savePaintWindowsState();
        }

        function setTool(tool) {
            ps.tool = tool === 'eraser' ? 'eraser' : 'brush';
            toolBtns.forEach(b => b.classList.toggle('active', b.dataset.tool === ps.tool));
            savePaintWindowsState();
        }

        function setColor(color) {
            ps.color = String(color || '#5dade2');
            savePaintWindowsState();
        }

        function setSize(size) {
            const v = Math.max(1, Math.min(64, Math.round(Number(size) || 8)));
            ps.size = v;
            if (sizeText) sizeText.textContent = String(v);
            savePaintWindowsState();
        }

        function updateUndoRedoButtons() {
            if (btnUndo) btnUndo.disabled = ps.undo.length === 0 || ps.restoring;
            if (btnRedo) btnRedo.disabled = ps.redo.length === 0 || ps.restoring;
        }

        function fillBackgroundIfNeeded() {
            if (!ctx || !canvas) return;
            if (ps.bg === 'white') {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }
        }

        function resizeCanvasToStage(preserve = true) {
            if (!canvas || !ctx || !stage) return;
            const rect = stage.getBoundingClientRect();
            const w = Math.max(1, Math.floor(rect.width));
            const h = Math.max(1, Math.floor(rect.height));
            const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

            const nextW = Math.max(1, Math.floor(w * dpr));
            const nextH = Math.max(1, Math.floor(h * dpr));

            if (canvas.width === nextW && canvas.height === nextH) {
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                return;
            }

            let snapshotUrl = null;
            if (preserve) {
                try { snapshotUrl = canvas.toDataURL('image/png'); } catch (e) { snapshotUrl = null; }
            }

            canvas.width = nextW;
            canvas.height = nextH;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (snapshotUrl) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    fillBackgroundIfNeeded();
                };
                img.src = snapshotUrl;
            } else {
                fillBackgroundIfNeeded();
            }

            ps.undo = [];
            ps.redo = [];
            updateUndoRedoButtons();
        }

        function pushUndoSnapshot() {
            if (!canvas || ps.restoring) return;
            try {
                const url = canvas.toDataURL('image/png');
                ps.undo.push(url);
                if (ps.undo.length > 40) ps.undo.shift();
                ps.redo = [];
            } catch (e) {}
            updateUndoRedoButtons();
        }

        function restoreFromDataUrl(url) {
            if (!ctx || !canvas || !url) return;
            ps.restoring = true;
            updateUndoRedoButtons();
            const img = new Image();
            img.onload = () => {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                fillBackgroundIfNeeded();
                ps.restoring = false;
                updateUndoRedoButtons();
            };
            img.onerror = () => {
                ps.restoring = false;
                updateUndoRedoButtons();
            };
            img.src = url;
        }

        function doUndo() {
            if (ps.undo.length === 0 || !canvas) return;
            let current = null;
            try { current = canvas.toDataURL('image/png'); } catch (e) { current = null; }
            if (current) ps.redo.push(current);
            const prev = ps.undo.pop();
            restoreFromDataUrl(prev);
            updateUndoRedoButtons();
        }

        function doRedo() {
            if (ps.redo.length === 0 || !canvas) return;
            let current = null;
            try { current = canvas.toDataURL('image/png'); } catch (e) { current = null; }
            if (current) ps.undo.push(current);
            const next = ps.redo.pop();
            restoreFromDataUrl(next);
            updateUndoRedoButtons();
        }

        function clearCanvas() {
            if (!ctx || !canvas) return;
            pushUndoSnapshot();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            fillBackgroundIfNeeded();
            savePaintWindowsState();
        }

        async function saveAsPng() {
            if (!canvas) return;
            const fileName = `paint-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
            const doDownload = (blob) => {
                if (!blob) return;
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            };
            if (canvas.toBlob) {
                canvas.toBlob(doDownload, 'image/png');
            } else {
                try {
                    const dataUrl = canvas.toDataURL('image/png');
                    const res = await fetch(dataUrl);
                    doDownload(await res.blob());
                } catch (e) {}
            }
        }

        function openImageFile(file) {
            if (!file || !ctx || !canvas) return;
            const reader = new FileReader();
            reader.onload = () => {
                pushUndoSnapshot();
                const img = new Image();
                img.onload = () => {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const cw = canvas.width;
                    const ch = canvas.height;
                    const iw = img.naturalWidth || img.width;
                    const ih = img.naturalHeight || img.height;
                    const scale = Math.min(cw / iw, ch / ih);
                    const dw = Math.max(1, Math.floor(iw * scale));
                    const dh = Math.max(1, Math.floor(ih * scale));
                    const dx = Math.floor((cw - dw) / 2);
                    const dy = Math.floor((ch - dh) / 2);

                    ctx.drawImage(img, dx, dy, dw, dh);
                    fillBackgroundIfNeeded();
                    savePaintWindowsState();
                };
                img.src = String(reader.result || '');
            };
            reader.readAsDataURL(file);
        }

        if (colorInput) colorInput.value = ps.color;
        if (sizeInput) sizeInput.value = String(ps.size);
        setSize(ps.size);
        setTool(ps.tool);
        setBg(ps.bg);
        updateUndoRedoButtons();

        requestAnimationFrame(() => resizeCanvasToStage(false));

        let drawing = false;
        let lastX = 0;
        let lastY = 0;

        function getCanvasPoint(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            return { x, y };
        }

        function beginStroke(e) {
            if (!ctx || !canvas) return;
            drawing = true;
            try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
            pushUndoSnapshot();
            const p = getCanvasPoint(e);
            lastX = p.x;
            lastY = p.y;
        }

        function moveStroke(e) {
            if (!drawing || !ctx) return;
            const p = getCanvasPoint(e);
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = ps.size;
            if (ps.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = ps.color;
            }
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
            ctx.restore();
            lastX = p.x;
            lastY = p.y;
        }

        function endStroke() {
            if (!drawing) return;
            drawing = false;
            fillBackgroundIfNeeded();
            savePaintWindowsState();
        }

        if (canvas) {
            canvas.style.touchAction = 'none';
            canvas.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                beginStroke(e);
            });
            canvas.addEventListener('pointermove', (e) => {
                if (!drawing) return;
                e.preventDefault();
                moveStroke(e);
            });
            canvas.addEventListener('pointerup', (e) => {
                e.preventDefault();
                endStroke();
            });
            canvas.addEventListener('pointercancel', () => endStroke());
            canvas.addEventListener('pointerleave', () => endStroke());
        }

        toolBtns.forEach(btn => {
            btn.addEventListener('click', () => setTool(btn.dataset.tool));
        });

        if (colorInput) colorInput.addEventListener('input', (e) => setColor(e.target.value));
        if (sizeInput) sizeInput.addEventListener('input', (e) => setSize(e.target.value));
        if (bgBtn) {
            bgBtn.addEventListener('click', () => {
                setBg(ps.bg === 'white' ? 'transparent' : 'white');
                fillBackgroundIfNeeded();
            });
        }

        if (btnUndo) btnUndo.addEventListener('click', doUndo);
        if (btnRedo) btnRedo.addEventListener('click', doRedo);
        if (btnClear) btnClear.addEventListener('click', () => clearCanvas());
        if (btnOpen) btnOpen.addEventListener('click', () => fileInput && fileInput.click());
        if (btnSave) btnSave.addEventListener('click', () => saveAsPng());

        if (fileInput) {
            fileInput.addEventListener('change', () => {
                const file = fileInput.files && fileInput.files[0];
                if (file) openImageFile(file);
                fileInput.value = '';
            });
        }

        const minimizeBtn = win.querySelector('.window-control.minimize');
        const maximizeBtn = win.querySelector('.window-control.maximize');
        const closeBtn = win.querySelector('.window-control.close');

        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const minimized = win.style.display === 'none';
                if (minimized) {
                    win.style.display = 'flex';
                    focusWindow(win);
                    updateWindowAppBarState(win, true, false);
                    setTimeout(() => resizeCanvasToStage(true), 0);
                } else {
                    win.style.display = 'none';
                    win.classList.remove('window-focused');
                    updateWindowAppBarState(win, false, true);
                }
                savePaintWindowsState();
            });
        }

        let isMaximized = false;
        let originalPos = null;
        if (maximizeBtn) {
            maximizeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isMaximized) {
                    if (originalPos) {
                        win.style.left = originalPos.left;
                        win.style.top = originalPos.top;
                        win.style.width = originalPos.width;
                        win.style.height = originalPos.height;
                    }
                    isMaximized = false;
                } else {
                    originalPos = {
                        left: win.style.left,
                        top: win.style.top,
                        width: win.style.width,
                        height: win.style.height
                    };
                    maximizeWindowToBounds(win);
                    isMaximized = true;
                }

                setTimeout(() => resizeCanvasToStage(true), 0);
                savePaintWindowsState();
            });
        }

        if (closeBtn) {
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = win.id;
                if (id) removeWindowFromAppBar(id);
                win.remove();
                savePaintWindowsState();
            });
        }

        win.addEventListener('keydown', (e) => {
            const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
            if (tag === 'input' || tag === 'textarea') return;

            const key = (e.key || '').toLowerCase();
            const ctrl = e.ctrlKey || e.metaKey;

            if (ctrl && key === 'z') {
                e.preventDefault();
                if (e.shiftKey) doRedo();
                else doUndo();
                return;
            }
            if (ctrl && key === 'y') {
                e.preventDefault();
                doRedo();
                return;
            }
            if (key === 'b') setTool('brush');
            if (key === 'e') setTool('eraser');
        });

        const ro = (window.ResizeObserver && stage)
            ? new ResizeObserver(() => resizeCanvasToStage(true))
            : null;
        if (ro && stage) ro.observe(stage);

        fillBackgroundIfNeeded();
        savePaintWindowsState();

        return win;
    }

    if (!paintInitialized) {
        paintInitialized = true;
        const saved = getSavedPaintWindowsState();
        if (saved && saved.length > 0) {
            saved.forEach(st => createPaintWindow(st));
        }
    }

    return function openPaint() {
        createPaintWindow(null);
    };
}

// Desktop Items Functionality
// Global variable to track if desktop items are locked
let desktopIconsLocked = false;
// Global variable to track if grid is enabled for DESKTOP ICONS ONLY
// This setting does NOT affect window positioning or any other UI elements
let desktopGridEnabled = false;
// Grid size in pixels (for desktop icons only)
const GRID_SIZE = 20;

function getDockTopBoundaryPx() {
    const dock = document.querySelector('.dock');
    if (!dock) return window.innerHeight;
    if (dock.classList.contains('dock-auto-hide-hidden')) return window.innerHeight;
    const rect = dock.getBoundingClientRect();
    const top = (rect && typeof rect.top === 'number') ? rect.top : window.innerHeight;
    return Math.max(0, Math.min(window.innerHeight, top));
}

function getDesktopIconBounds(desktopIconsContainer, iconEl, containerRect = null) {
    const rect = containerRect || (desktopIconsContainer ? desktopIconsContainer.getBoundingClientRect() : null);
    const iconW = iconEl ? (iconEl.offsetWidth || 0) : 0;
    const iconH = iconEl ? (iconEl.offsetHeight || 0) : 0;
    const containerW = desktopIconsContainer ? desktopIconsContainer.clientWidth : document.documentElement.clientWidth;
    const containerH = desktopIconsContainer ? desktopIconsContainer.clientHeight : document.documentElement.clientHeight;
    let maxX = containerW - iconW;
    let maxY = containerH - iconH;
    const dockTop = getDockTopBoundaryPx();
    const dockRelativeMaxY = rect ? (dockTop - rect.top - iconH) : (dockTop - iconH);
    maxY = Math.min(maxY, dockRelativeMaxY);
    return {
        maxX: Math.max(0, maxX),
        maxY: Math.max(0, maxY)
    };
}

// Desktop Items Functionality
function initDesktopIcons() {
    // Load saved lock state
    const savedLockState = localStorage.getItem('desktopIconsLocked');
    if (savedLockState === 'true') {
        desktopIconsLocked = true;
    }
    
    // Load saved grid state - default to Grid Mode (true) if not set
    const savedGridState = localStorage.getItem('desktopGridEnabled');
    if (savedGridState === null) {
        // First time - default to Grid Mode
        desktopGridEnabled = true;
        localStorage.setItem('desktopGridEnabled', 'true');
    } else {
        desktopGridEnabled = savedGridState === 'true';
    }
    
    // Helper functions for future desktop icons
    function saveIconPosition(icon, iconId) {
        const position = {
            left: icon.style.left || icon.offsetLeft + 'px',
            top: icon.style.top || icon.offsetTop + 'px'
        };
        localStorage.setItem(`${iconId}Position`, JSON.stringify(position));
    }
    
    // Make saveIconPosition available globally
    window.saveIconPosition = saveIconPosition;
    
    function makeIconDraggable(icon, iconId) {
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let pendingPositionDrag = false;
        let dragStartTime = 0;
        // Drag anchors for desktop reposition dragging (container-relative coords)
        let dragPointerStartClientX = 0;
        let dragPointerStartClientY = 0;
        let dragIconStartLeft = 0;
        let dragIconStartTop = 0;
        let dragScaleX = 1;
        let dragScaleY = 1;
        let dragContainer = null;
        // For smooth desktop reposition dragging, use transform during drag (no layout),
        // then commit left/top on mouseup.
        let dragBaseLeft = 0;
        let dragBaseTop = 0;
        // Cursor "grab point" within the icon (container-relative), so the cursor always stays attached.
        let dragGrabOffsetX = 0;
        let dragGrabOffsetY = 0;

        function setDesktopDragLayer(isOn) {
            const desktopIconsContainer = document.querySelector('.desktop-icons');
            if (!desktopIconsContainer) return;
            desktopIconsContainer.classList.toggle('drag-layer-top', !!isOn);
        }
        
        // Make icon draggable for HTML5 drag and drop (for dragging to Files app)
        const filePath = icon.dataset.filePath;
        let positionDragActive = false;
        let dragStartPos = null;
        let currentMousePos = null;
        let mouseLeaveCleanup = null;

        function startPositionDrag(mouseEvent) {
            // Raise z-index when position dragging starts so icon appears above windows
            icon.style.zIndex = '10001';
            icon.classList.add('is-dragging');
            setDesktopDragLayer(true);

            positionDragActive = true;
            isDragging = true;

            dragContainer = document.querySelector('.desktop-icons');
            const containerRect = dragContainer ? dragContainer.getBoundingClientRect() : null;
            // If the desktop is scaled (CSS transform/zoom), correct pointer deltas back into layout pixels.
            dragScaleX = (dragContainer && dragContainer.clientWidth) ? (containerRect.width / dragContainer.clientWidth) : 1;
            dragScaleY = (dragContainer && dragContainer.clientHeight) ? (containerRect.height / dragContainer.clientHeight) : 1;
            if (!isFinite(dragScaleX) || dragScaleX <= 0) dragScaleX = 1;
            if (!isFinite(dragScaleY) || dragScaleY <= 0) dragScaleY = 1;
            // If we're effectively unscaled, snap to exactly 1 to avoid tiny ratio errors causing drift on fast moves.
            if (Math.abs(dragScaleX - 1) < 0.02) dragScaleX = 1;
            if (Math.abs(dragScaleY - 1) < 0.02) dragScaleY = 1;

            // Prepare for transform-based dragging
            dragBaseLeft = dragIconStartLeft;
            dragBaseTop = dragIconStartTop;
            // Compute the cursor grab offset within the icon (container-relative).
            // This ensures the cursor stays "attached" to the same point on the icon with no drift.
            if (containerRect && mouseEvent && typeof mouseEvent.clientX === 'number' && typeof mouseEvent.clientY === 'number') {
                const pointerX = (mouseEvent.clientX - containerRect.left) / dragScaleX;
                const pointerY = (mouseEvent.clientY - containerRect.top) / dragScaleY;
                dragGrabOffsetX = pointerX - dragBaseLeft;
                dragGrabOffsetY = pointerY - dragBaseTop;
            } else {
                dragGrabOffsetX = 0;
                dragGrabOffsetY = 0;
            }
            icon.style.willChange = 'transform';
            icon.style.transform = 'translate3d(0px, 0px, 0px)';

            // Swap handlers: from "maybe start" to actual drag
            document.removeEventListener('mousemove', maybeStartDrag, true);
            document.addEventListener('mousemove', drag, true);
        }

        function maybeStartDrag(mouseEvent) {
            // Always track the latest mouse position so HTML5 `dragstart` can compute a correct drag-image offset.
            // (On fast drags, `dragstart` can fire with unreliable `e.clientX/Y` in some browsers.)
            currentMousePos = { x: mouseEvent.clientX, y: mouseEvent.clientY };

            // If HTML5 drag has started, stop position-drag prep and let native DnD proceed
            if (icon.classList.contains('dragging')) {
                document.removeEventListener('mousemove', maybeStartDrag, true);
                document.removeEventListener('mouseup', stopDrag, true);
                pendingPositionDrag = false;
                return;
            }

            if (!pendingPositionDrag) {
                // Non-file icons: start position dragging immediately on first move
                startPositionDrag(mouseEvent);
                return;
            }

            const dx = mouseEvent.clientX - dragStartPos.x;
            const dy = mouseEvent.clientY - dragStartPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const elapsed = dragStartTime ? (Date.now() - dragStartTime) : 0;

            // Wait until the mouse has moved a bit to distinguish click vs drag
            if (dist < 6) return;

            // If Files is open and we're dragging generally *toward* a Files window, don't start
            // desktop reposition dragging (it tends to suppress native dragstart and makes drop unreliable).
            const filesWindows = Array.from(document.querySelectorAll('.window[data-file-explorer-window]'))
                .filter(w => w && w.style.display !== 'none' && document.body.contains(w));
            if (filesWindows.length > 0 && dragStartPos) {
                // Choose the closest Files window to the drag start point
                let closest = null;
                let closestDist = Infinity;
                for (const w of filesWindows) {
                    const r = w.getBoundingClientRect();
                    const cx = r.left + r.width / 2;
                    const cy = r.top + r.height / 2;
                    const ddx = cx - dragStartPos.x;
                    const ddy = cy - dragStartPos.y;
                    const d = Math.sqrt(ddx * ddx + ddy * ddy);
                    if (d < closestDist) {
                        closestDist = d;
                        closest = { cx, cy };
                    }
                }
                if (closest) {
                    const dragDirX = mouseEvent.clientX - dragStartPos.x;
                    const dragDirY = mouseEvent.clientY - dragStartPos.y;
                    const toFilesX = closest.cx - dragStartPos.x;
                    const toFilesY = closest.cy - dragStartPos.y;
                    const dragLen = Math.sqrt(dragDirX * dragDirX + dragDirY * dragDirY) || 1;
                    const toFilesLen = Math.sqrt(toFilesX * toFilesX + toFilesY * toFilesY) || 1;
                    const cosTheta = (dragDirX * toFilesX + dragDirY * toFilesY) / (dragLen * toFilesLen);

                    // If the drag is roughly pointed at Files and Files is reasonably close,
                    // wait briefly and let HTML5 drag start. Otherwise, allow desktop reposition.
                    const filesIsClose = closestDist < 700;
                    const shouldWaitForHtml5 = (cosTheta > 0.4) && filesIsClose && elapsed < 250 && dist < 140;
                    if (shouldWaitForHtml5) {
                        return;
                    }
                }
            }

            // If we are currently over a Files window, also wait and let HTML5 drag start.
            // (No listener removal here; dragstart/dragend will clean up reliably.)
            const el = document.elementFromPoint(mouseEvent.clientX, mouseEvent.clientY);
            const overFiles = !!(el && (el.closest('.window[data-file-explorer-window]') || el.closest('.file-explorer-content')));
            if (overFiles) return;

            // Otherwise, it's a desktop reposition drag
            startPositionDrag(mouseEvent);
        }
        
        // Set up HTML5 drag handlers for files/folders
        if (filePath) {
            icon.draggable = true;
            
            icon.addEventListener('dragstart', (e) => {
                // Decide if this should become an HTML5 drag (Desktop -> Files) or remain a desktop reposition drag.
                // If we let HTML5 drag start while you're just repositioning, the `.dragging` class can linger and
                // temporarily make the icon un-draggable (pointer-events: none). So be strict here.

                // Use event position (most accurate), then current mouse position, then dragStartPos.
                // Some browsers can briefly report bogus `0,0` on very fast drags; clamp/guard so the drag image
                // doesn't "drift" away from the cursor.
                const fallbackX = (currentMousePos && typeof currentMousePos.x === 'number')
                    ? currentMousePos.x
                    : (dragStartPos && typeof dragStartPos.x === 'number' ? dragStartPos.x : 0);
                const fallbackY = (currentMousePos && typeof currentMousePos.y === 'number')
                    ? currentMousePos.y
                    : (dragStartPos && typeof dragStartPos.y === 'number' ? dragStartPos.y : 0);
                const rawX = (typeof e.clientX === 'number') ? e.clientX : null;
                const rawY = (typeof e.clientY === 'number') ? e.clientY : null;

                let mouseX = (rawX !== null) ? rawX : fallbackX;
                let mouseY = (rawY !== null) ? rawY : fallbackY;

                // Heuristic: if `raw` is 0 but our fallback is clearly not near 0, treat `raw` as unreliable.
                if (dragStartPos) {
                    if (rawX === 0 && fallbackX > 10 && dragStartPos.x > 10) mouseX = fallbackX;
                    if (rawY === 0 && fallbackY > 10 && dragStartPos.y > 10) mouseY = fallbackY;
                }
                // If the event and our tracked mouse position disagree wildly, prefer the tracked position.
                // This tends to happen on very fast drags where the browser reports stale coordinates in `dragstart`.
                if (rawX !== null && Math.abs(rawX - fallbackX) > 120) mouseX = fallbackX;
                if (rawY !== null && Math.abs(rawY - fallbackY) > 120) mouseY = fallbackY;

                const filesWindows = Array.from(document.querySelectorAll('.window[data-file-explorer-window]'))
                    .filter(w => w && w.style.display !== 'none' && document.body.contains(w));

                // Allow if mouse is inside a Files window bounds (more reliable than elementFromPoint
                // because the icon layer may be above windows).
                let shouldAllowHTML5Drag = false;
                let closestRect = null;
                let closestDist = Infinity;
                for (const w of filesWindows) {
                    const r = w.getBoundingClientRect();
                    const cx = r.left + r.width / 2;
                    const cy = r.top + r.height / 2;
                    const dx0 = (dragStartPos ? (cx - dragStartPos.x) : 0);
                    const dy0 = (dragStartPos ? (cy - dragStartPos.y) : 0);
                    const d0 = dragStartPos ? Math.sqrt(dx0 * dx0 + dy0 * dy0) : 0;
                    if (d0 < closestDist) {
                        closestDist = d0;
                        closestRect = r;
                    }
                    const isInside = mouseX >= r.left && mouseX <= r.right && mouseY >= r.top && mouseY <= r.bottom;
                    if (isInside) {
                        shouldAllowHTML5Drag = true;
                    }
                }

                // Otherwise, allow if you're clearly aiming at a nearby Files window early in the gesture.
                if (!shouldAllowHTML5Drag && dragStartPos && closestRect) {
                    const filesCenterX = closestRect.left + closestRect.width / 2;
                    const filesCenterY = closestRect.top + closestRect.height / 2;
                    const dragDirX = mouseX - dragStartPos.x;
                    const dragDirY = mouseY - dragStartPos.y;
                    const toFilesX = filesCenterX - dragStartPos.x;
                    const toFilesY = filesCenterY - dragStartPos.y;
                    const dragLen = Math.sqrt(dragDirX * dragDirX + dragDirY * dragDirY) || 1;
                    const toFilesLen = Math.sqrt(toFilesX * toFilesX + toFilesY * toFilesY) || 1;
                    const cosTheta = (dragDirX * toFilesX + dragDirY * toFilesY) / (dragLen * toFilesLen);
                    const dragDistance = Math.sqrt(dragDirX * dragDirX + dragDirY * dragDirY);
                    const elapsed = dragStartTime ? (Date.now() - dragStartTime) : 0;

                    // This is intentionally permissive so Desktop -> Files works reliably,
                    // while desktop reposition is handled by our manual mousedown drag.
                    shouldAllowHTML5Drag = (closestDist < 1200) && (cosTheta > 0.2) && (elapsed < 800) && (dragDistance > 8);
                }

                if (!shouldAllowHTML5Drag) {
                    // Keep it as a desktop reposition drag.
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }

                // Ensure desktop icons layer is above windows while dragging
                setDesktopDragLayer(true);
                // Important: while doing native HTML5 drag, don't let desktop icons intercept dragover/drop.
                // Otherwise the drag can appear "over" the Files window but never actually drops into it.
                const desktopIconsContainer = document.querySelector('.desktop-icons');
                if (desktopIconsContainer) {
                    desktopIconsContainer.classList.add('drag-pass-through');
                }
                // If a native drag starts, stop any pending position-drag listeners so we don't interfere
                pendingPositionDrag = false;
                document.removeEventListener('mousemove', maybeStartDrag, true);
                document.removeEventListener('mouseup', stopDrag, true);
                
                // Stop position dragging and allow HTML5 drag
                isDragging = false;
                positionDragActive = false;
                document.removeEventListener('mousemove', drag, true);
                document.removeEventListener('mouseup', stopDrag, true);
                // Clean up mouseleave handler
                if (mouseLeaveCleanup) {
                    window.removeEventListener('mouseleave', mouseLeaveCleanup);
                    mouseLeaveCleanup = null;
                }
                
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', filePath);
                e.dataTransfer.setData('item-type', icon.dataset.itemType || 'file');
                icon.classList.add('dragging');
                // Some parts of the app check `globalThis`, others check `window`  keep both in sync.
                globalThis.isDraggingFromDesktop = true;
                window.isDraggingFromDesktop = true;
                
                // Create a custom drag image to ensure it appears on top
                // Clone the icon for the drag image
                const dragImage = icon.cloneNode(true);
                dragImage.style.position = 'fixed';
                dragImage.style.top = '-1000px';
                dragImage.style.left = '-1000px';
                dragImage.style.zIndex = '99999';
                dragImage.style.opacity = '0.9';
                dragImage.style.pointerEvents = 'none';
                dragImage.style.transform = 'none';
                dragImage.classList.remove('dragging'); // Remove dragging class from clone
                document.body.appendChild(dragImage);
                
                // Force a reflow to ensure the element is rendered
                dragImage.offsetHeight;
                
                // Set the custom drag image with proper offset
                const rect = icon.getBoundingClientRect();
                // Use the same stable pointer coordinates we computed above; `e.clientX/Y` can be unreliable on fast drags.
                // Clamp to the icon bounds so the drag image can't jump far away due to bad coordinates.
                const offsetX0 = mouseX - rect.left;
                const offsetY0 = mouseY - rect.top;
                const w = rect.width || icon.offsetWidth || 0;
                const h = rect.height || icon.offsetHeight || 0;
                // If the computed offset is clearly bogus (far outside icon bounds), fall back to centering the cursor.
                const slack = 16;
                const safeOffsetX0 = (offsetX0 < -slack || offsetX0 > w + slack) ? (w / 2) : offsetX0;
                const safeOffsetY0 = (offsetY0 < -slack || offsetY0 > h + slack) ? (h / 2) : offsetY0;
                const offsetX = Math.max(0, Math.min(safeOffsetX0, w));
                const offsetY = Math.max(0, Math.min(safeOffsetY0, h));
                e.dataTransfer.setDragImage(dragImage, offsetX, offsetY);
                
                // Clean up the drag image after drag starts
                requestAnimationFrame(() => {
                    if (dragImage.parentNode) {
                        dragImage.parentNode.removeChild(dragImage);
                    }
                });
            });
            
            icon.addEventListener('dragend', (e) => {
                // Clean up HTML5 drag state
                icon.classList.remove('dragging');
                globalThis.isDraggingFromDesktop = false;
                window.isDraggingFromDesktop = false;
                setDesktopDragLayer(false);
                const desktopIconsContainer = document.querySelector('.desktop-icons');
                if (desktopIconsContainer) {
                    desktopIconsContainer.classList.remove('drag-pass-through');
                }
                
                // Clean up position dragging state (in case it wasn't properly cleaned up)
                isDragging = false;
                positionDragActive = false;
                document.removeEventListener('mousemove', drag, true);
                document.removeEventListener('mouseup', stopDrag, true);
                
                // Clean up mouseleave handler
                if (mouseLeaveCleanup) {
                    window.removeEventListener('mouseleave', mouseLeaveCleanup);
                    mouseLeaveCleanup = null;
                }
                
                // Clear position tracking variables
                dragStartPos = null;
                currentMousePos = null;
                
                // Remove dragging classes
                icon.classList.remove('is-dragging');
                
                // Reset z-index when HTML5 drag ends
                icon.style.zIndex = '';
                
                // If the drop was cancelled or didn't complete, ensure icon position is valid
                // Check if icon position needs to be saved (icon wasn't actually moved)
                const currentLeft = parseInt(icon.style.left.replace('px', '')) || icon.offsetLeft;
                const currentTop = parseInt(icon.style.top.replace('px', '')) || icon.offsetTop;
                
                // Ensure icon position is within bounds
                const bounds = getDesktopIconBounds(desktopIconsContainer, icon, desktopIconsContainer ? desktopIconsContainer.getBoundingClientRect() : null);
                
                let finalLeft = Math.max(0, Math.min(currentLeft, bounds.maxX));
                let finalTop = Math.max(0, Math.min(currentTop, bounds.maxY));
                
                // Check for overlap and adjust if needed
                if (checkIconOverlap(finalLeft, finalTop, icon.offsetWidth, icon.offsetHeight, iconId)) {
                    const newPosition = findNonOverlappingPosition(
                        icon.offsetWidth, 
                        icon.offsetHeight, 
                        finalLeft, 
                        finalTop, 
                        iconId
                    );
                    finalLeft = newPosition.left;
                    finalTop = newPosition.top;
                }
                
                // Snap to grid if enabled
                if (desktopGridEnabled) {
                    finalLeft = snapToGrid(finalLeft);
                    finalTop = snapToGrid(finalTop);
                }
                
                // Apply final position
                icon.style.left = finalLeft + 'px';
                icon.style.top = finalTop + 'px';
                
                // Ensure pointer events are enabled
                icon.style.pointerEvents = 'all';
                
                // Save icon position after drag ends
                saveIconPosition(icon, iconId);
                
                // Use a small delay to ensure everything is reset before next drag can start
                setTimeout(() => {
                    // Double-check that dragging classes are removed
                    icon.classList.remove('is-dragging');
                    icon.classList.remove('dragging');
                    icon.style.zIndex = '';
                    icon.style.pointerEvents = 'all';
                }, 50);
                
                // Clean up Files app drag state
                const filesWindows = document.querySelectorAll('.file-explorer-content');
                filesWindows.forEach(filesWindow => {
                    const itemsContainer = filesWindow.querySelector('.file-explorer-items');
                    if (itemsContainer) {
                        itemsContainer.querySelectorAll('.file-item').forEach(item => {
                            item.classList.remove('drag-over');
                        });
                    }
                    const sidebarItems = filesWindow.querySelectorAll('.file-explorer-sidebar .sidebar-item');
                    sidebarItems.forEach(item => {
                        item.classList.remove('drag-over-sidebar');
                    });
                });
            });
        }
        
        icon.addEventListener('mousedown', function(e) {
            // Check if icons are locked - if so, prevent dragging
            if (desktopIconsLocked) {
                return;
            }
            
            // Stop propagation to prevent windows from interfering
            e.stopPropagation();
            
            // Ensure any previous drag state is cleaned up first
            isDragging = false;
            positionDragActive = false;
            document.removeEventListener('mousemove', drag, true);
            document.removeEventListener('mouseup', stopDrag, true);
            
            // Clean up any previous mouseleave handler
            if (mouseLeaveCleanup) {
                window.removeEventListener('mouseleave', mouseLeaveCleanup);
                mouseLeaveCleanup = null;
            }
            
            // Remove any stale dragging classes
            icon.classList.remove('is-dragging');
            icon.classList.remove('dragging');
            // Reset any transform-based dragging state
            icon.style.transform = '';
            icon.style.willChange = '';
            
            // Initialize position tracking variables
            dragStartPos = { x: e.clientX, y: e.clientY };
            currentMousePos = { x: e.clientX, y: e.clientY };
            dragStartTime = Date.now();
            // Anchor drag to the original mousedown position so fast movement before drag activation
            // doesn't create a permanent cursor/icon offset.
            dragPointerStartClientX = e.clientX;
            dragPointerStartClientY = e.clientY;
            dragIconStartLeft = parseFloat(icon.style.left) || icon.offsetLeft || 0;
            dragIconStartTop = parseFloat(icon.style.top) || icon.offsetTop || 0;
            dragBaseLeft = dragIconStartLeft;
            dragBaseTop = dragIconStartTop;

            // For file/folder icons, delay starting position-drag so HTML5 drag can initiate
            // (needed to allow dragging from Desktop into Files app).
            // For non-file icons, keep the old behavior (position-drag immediately).
            pendingPositionDrag = !!filePath;
            positionDragActive = false;
            isDragging = false;

            // Use capture phase to ensure we catch mouseup even if it's outside
            // Start with maybeStartDrag so HTML5 drag can still fire for file icons.
            document.addEventListener('mousemove', maybeStartDrag, true);
            document.addEventListener('mouseup', stopDrag, true);
            
            // Safety: also listen for mouseleave on window to clean up if mouse leaves browser
            mouseLeaveCleanup = () => {
                if (isDragging && !icon.classList.contains('dragging')) {
                    stopDrag();
                    if (mouseLeaveCleanup) {
                        window.removeEventListener('mouseleave', mouseLeaveCleanup);
                        mouseLeaveCleanup = null;
                    }
                }
            };
            window.addEventListener('mouseleave', mouseLeaveCleanup);
        });
        
        
        // Snap to grid function - ONLY used for desktop icons, never for windows
        function snapToGrid(value) {
            return Math.round(value / GRID_SIZE) * GRID_SIZE;
        }

        // Drag performance: mousemove can fire far more often than the browser can paint.
        // When you move quickly this can look like the cursor is "drifting away" from the icon.
        // We batch DOM work to once per animation frame.
        let dragRafId = 0;
        let dragFrameClientX = 0;
        let dragFrameClientY = 0;
        let dragFrameButtons = 0;
        let dragFrameWhich = 0;

        function processDragFrame() {
            dragRafId = 0;
            if (!isDragging) return;

            // If HTML5 drag has started (icon has dragging class), stop position dragging
            if (icon.classList.contains('dragging')) {
                isDragging = false;
                positionDragActive = false;
                document.removeEventListener('mousemove', drag, true);
                document.removeEventListener('mouseup', stopDrag, true);
                dragStartPos = null;
                currentMousePos = null;
                if (mouseLeaveCleanup) {
                    window.removeEventListener('mouseleave', mouseLeaveCleanup);
                    mouseLeaveCleanup = null;
                }
                return;
            }

            // Recompute scale each frame in case desktop is zoomed/resized mid-drag.
            const desktopIconsContainer = dragContainer || document.querySelector('.desktop-icons');
            if (desktopIconsContainer) {
                dragContainer = desktopIconsContainer;
                const r = desktopIconsContainer.getBoundingClientRect();
                dragScaleX = desktopIconsContainer.clientWidth ? (r.width / desktopIconsContainer.clientWidth) : 1;
                dragScaleY = desktopIconsContainer.clientHeight ? (r.height / desktopIconsContainer.clientHeight) : 1;
                if (!isFinite(dragScaleX) || dragScaleX <= 0) dragScaleX = 1;
                if (!isFinite(dragScaleY) || dragScaleY <= 0) dragScaleY = 1;
                if (Math.abs(dragScaleX - 1) < 0.02) dragScaleX = 1;
                if (Math.abs(dragScaleY - 1) < 0.02) dragScaleY = 1;
                // Compute desired position in the same coordinate space as the icon (container-relative),
                // based on current pointer position minus the initial grab offset.
                const pointerX = (dragFrameClientX - r.left) / dragScaleX;
                const pointerY = (dragFrameClientY - r.top) / dragScaleY;
                const desiredX = pointerX - dragGrabOffsetX;
                const desiredY = pointerY - dragGrabOffsetY;
                currentX = desiredX;
                currentY = desiredY;
            } else {
                // No container (shouldn't happen): fall back to delta-based movement.
                const dx = (dragFrameClientX - dragPointerStartClientX) / dragScaleX;
                const dy = (dragFrameClientY - dragPointerStartClientY) / dragScaleY;
                currentX = dragIconStartLeft + dx;
                currentY = dragIconStartTop + dy;
            }

            // Keep icon within desktop bounds (container-relative), and above the dock.
            const bounds = getDesktopIconBounds(desktopIconsContainer, icon, desktopIconsContainer ? desktopIconsContainer.getBoundingClientRect() : null);
            currentX = Math.max(0, Math.min(currentX, bounds.maxX));
            currentY = Math.max(0, Math.min(currentY, bounds.maxY));

            // Apply via transform for smooth dragging (avoid layout thrash).
            const tx = currentX - dragBaseLeft;
            const ty = currentY - dragBaseTop;
            icon.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
        }

        function drag(e) {
            if (!isDragging) return;

            // Update current mouse position for dragstart check
            currentMousePos = { x: e.clientX, y: e.clientY };

            // Safety check: if mouse buttons aren't pressed, stop dragging
            // This handles cases where mouseup event might be missed
            if (e.buttons === 0 || e.which === 0) {
                stopDrag(e);
                return;
            }

            e.preventDefault();
            e.stopPropagation(); // Prevent events from reaching windows that might interfere

            dragFrameClientX = e.clientX;
            dragFrameClientY = e.clientY;
            dragFrameButtons = e.buttons;
            dragFrameWhich = e.which;

            if (!dragRafId) {
                dragRafId = requestAnimationFrame(processDragFrame);
            }
        }
        
        async function stopDrag(e) {
            // Stop propagation to prevent windows from interfering
            if (e) {
                e.stopPropagation();
            }

            if (dragRafId) {
                cancelAnimationFrame(dragRafId);
                dragRafId = 0;
            }

            // If we were transform-dragging, commit the final position back into left/top before
            // any overlap/grid logic runs.
            if (icon && icon.style && icon.style.transform) {
                const leftToCommit = (typeof currentX === 'number') ? currentX : (parseFloat(icon.style.left) || icon.offsetLeft || 0);
                const topToCommit = (typeof currentY === 'number') ? currentY : (parseFloat(icon.style.top) || icon.offsetTop || 0);
                icon.style.transform = '';
                icon.style.left = leftToCommit + 'px';
                icon.style.top = topToCommit + 'px';
                icon.style.willChange = '';
            }
            
            // Ensure we always clean up dragging state
            isDragging = false;
            positionDragActive = false;
            document.removeEventListener('mousemove', drag, true);
            document.removeEventListener('mousemove', maybeStartDrag, true);
            document.removeEventListener('mouseup', stopDrag, true);
            pendingPositionDrag = false;
            
            // Clean up mouseleave handler
            if (mouseLeaveCleanup) {
                window.removeEventListener('mouseleave', mouseLeaveCleanup);
                mouseLeaveCleanup = null;
            }
            
            // Reset drag start position
            dragStartPos = null;
            currentMousePos = null;
            dragContainer = null;
            
            // Remove dragging class
            icon.classList.remove('is-dragging');
            setDesktopDragLayer(false);
            
            // Reset z-index when dragging stops (unless HTML5 drag is active)
            if (!icon.classList.contains('dragging')) {
                icon.style.zIndex = '';
            }

            // If a desktop FILE/FOLDER icon was dragged and released over ANY non-Files window,
            // snap it back to its pre-drag desktop position (prevents "dropping onto windows").
            // IMPORTANT: Do NOT block Desktop -> Files drops.
            try {
                if (filePath && !icon.classList.contains('dragging')) {
                    const dropX = (e && typeof e.clientX === 'number') ? e.clientX : (currentMousePos ? currentMousePos.x : null);
                    const dropY = (e && typeof e.clientY === 'number') ? e.clientY : (currentMousePos ? currentMousePos.y : null);
                    if (dropX !== null && dropY !== null) {
                        const windowsUnderPoint = Array.from(document.querySelectorAll('.window'))
                            .filter(w => w && w.style.display !== 'none' && document.body.contains(w));

                        let topWin = null;
                        let topZ = -Infinity;
                        for (const w of windowsUnderPoint) {
                            const r = w.getBoundingClientRect();
                            const inside = dropX >= r.left && dropX <= r.right && dropY >= r.top && dropY <= r.bottom;
                            if (!inside) continue;
                            const zStr = (w.style && w.style.zIndex) || (window.getComputedStyle ? window.getComputedStyle(w).zIndex : '0');
                            const z = parseInt(zStr || '0', 10) || 0;
                            if (z >= topZ) {
                                topZ = z;
                                topWin = w;
                            }
                        }

                        const overFilesWin = !!(topWin && topWin.matches && topWin.matches('.window[data-file-explorer-window]'));
                        if (topWin && !overFilesWin) {
                            // Restore the icon back to where it was before the drag began.
                            icon.style.transform = '';
                            icon.style.willChange = '';
                            icon.style.left = (dragIconStartLeft || 0) + 'px';
                            icon.style.top = (dragIconStartTop || 0) + 'px';
                            // Persist the restored position and stop here.
                            saveIconPosition(icon, iconId);
                            return;
                        }
                    }
                }
            } catch (err) {
                // If anything goes wrong, don't block normal drag behavior.
            }

            // If this was a desktop reposition drag for a real file/folder icon and we released over a Files window,
            // treat it as a drop into Files (move into the active folder). This makes Desktop -> Files reliable even
            // when native HTML5 drag doesn't start.
            try {
                if (filePath && !icon.classList.contains('dragging')) {
                    const dropX = (e && typeof e.clientX === 'number') ? e.clientX : (currentMousePos ? currentMousePos.x : null);
                    const dropY = (e && typeof e.clientY === 'number') ? e.clientY : (currentMousePos ? currentMousePos.y : null);
                    if (dropX !== null && dropY !== null) {
                        const filesWindows = Array.from(document.querySelectorAll('.window[data-file-explorer-window]'))
                            .filter(w => w && w.style.display !== 'none' && document.body.contains(w));

                        // Find the topmost Files window under the drop point
                        let targetWin = null;
                        let topZ = -Infinity;
                        for (const w of filesWindows) {
                            const r = w.getBoundingClientRect();
                            const inside = dropX >= r.left && dropX <= r.right && dropY >= r.top && dropY <= r.bottom;
                            if (!inside) continue;
                            const z = parseInt((w.style && w.style.zIndex) || '0', 10) || 0;
                            if (z >= topZ) {
                                topZ = z;
                                targetWin = w;
                            }
                        }

                        if (targetWin && typeof targetWin.getActiveTab === 'function') {
                            const tab = targetWin.getActiveTab();
                            const targetPath = tab && tab.currentPath ? tab.currentPath : null;
                            if (targetPath) {
                                const fs = await initFileSystem();
                                const sourceType = icon.dataset.itemType || 'file';
                                try {
                                    await fs.move(filePath, targetPath);
                                } catch (err) {
                                    if (err && err.message && err.message.includes('already exists')) {
                                        const desiredName = filePath.split('/').pop();
                                        const newName = await getNonConflictingName(fs, targetPath, desiredName, sourceType);
                                        await fs.move(filePath, targetPath, newName);
                                    } else {
                                        throw err;
                                    }
                                }

                                // Hide and refresh desktop icons (so it disappears immediately)
                                icon.style.display = 'none';
                                icon.classList.remove('dragging');

                                if (window.refreshDesktopIcons) {
                                    await window.refreshDesktopIcons();
                                }
                                if (typeof targetWin.refreshCurrentView === 'function') {
                                    await targetWin.refreshCurrentView();
                                }
                                return; // Don't continue with saving desktop position
                            }
                        }
                    }
                }
            } catch (err) {
                alert('Error moving item: ' + (err && err.message ? err.message : err));
            }
            
            // Snap to grid if enabled (desktop icons only).
            // Previously we only snapped when overlap resolution happened, which made Grid Mode appear "broken".
            let currentLeft = parseInt((icon.style.left || '').replace('px', ''), 10);
            let currentTop = parseInt((icon.style.top || '').replace('px', ''), 10);
            if (!isFinite(currentLeft)) currentLeft = icon.offsetLeft || 0;
            if (!isFinite(currentTop)) currentTop = icon.offsetTop || 0;
            if (desktopGridEnabled) {
                currentLeft = snapToGrid(currentLeft);
                currentTop = snapToGrid(currentTop);
                icon.style.left = currentLeft + 'px';
                icon.style.top = currentTop + 'px';
            }
            
            // Check for overlap and adjust position if needed
            if (checkIconOverlap(currentLeft, currentTop, icon.offsetWidth, icon.offsetHeight, iconId)) {
                // Find a non-overlapping position near the current position
                const newPosition = findNonOverlappingPosition(
                    icon.offsetWidth, 
                    icon.offsetHeight, 
                    currentLeft, 
                    currentTop, 
                    iconId
                );
                
                // Snap to grid if enabled
                let finalLeft = newPosition.left;
                let finalTop = newPosition.top;
                if (desktopGridEnabled) {
                    finalLeft = snapToGrid(finalLeft);
                    finalTop = snapToGrid(finalTop);
                }
                
                icon.style.left = finalLeft + 'px';
                icon.style.top = finalTop + 'px';
            }
            
            saveIconPosition(icon, iconId);
            
            // HTML5 drag is always enabled, no need to re-enable
        }
    }
    
    // Helper function to get display name (with or without extension based on global setting)
    function getDisplayFileName(fileName) {
        const showExtensions = localStorage.getItem('showFileExtensions') === 'true'; // Default to false (hide extensions)
        if (showExtensions || fileName.lastIndexOf('.') <= 0) {
            // Show extensions or file has no extension
            return fileName;
        }
        // Hide extension
        const lastDotIndex = fileName.lastIndexOf('.');
        return lastDotIndex > 0 ? fileName.substring(0, lastDotIndex) : fileName;
    }
    
    // Make getDisplayFileName available globally
    window.getDisplayFileName = getDisplayFileName;

    // Apply a saved desktop icon size to a single icon element.
    // NOTE: This must live inside `initDesktopIcons()` because icons are created/refreshed here.
    // The desktop context menu also has its own sizing logic, but refresh needs to be able to
    // size newly-created icons after a page reload.
    function applyDesktopIconSizeToIcon(icon, size) {
        if (!icon) return;
        const sizes = {
            small: { icon: 32, svg: 32, label: 11, container: 70 },
            medium: { icon: 48, svg: 48, label: 12, container: 80 },
            large: { icon: 64, svg: 64, label: 13, container: 100 }
        };
        const sizeConfig = sizes[size] || sizes.small;

        const iconImage = icon.querySelector('.desktop-icon-image');
        const iconLabel = icon.querySelector('.desktop-icon-label');
        const iconSvg = iconImage ? iconImage.querySelector('svg') : null;

        if (iconImage) {
            iconImage.style.width = sizeConfig.icon + 'px';
            iconImage.style.height = sizeConfig.icon + 'px';
        }

        if (iconSvg) {
            iconSvg.style.width = sizeConfig.svg + 'px';
            iconSvg.style.height = sizeConfig.svg + 'px';
        }

        if (iconLabel) {
            iconLabel.style.fontSize = sizeConfig.label + 'px';
            iconLabel.style.maxWidth = sizeConfig.container + 'px';
        }

        icon.style.width = sizeConfig.container + 'px';
    }

    // Expose for other modules (context menu, debugging, etc.)
    window.applyDesktopIconSizeToIcon = applyDesktopIconSizeToIcon;
    
    // Helper function to check if a position would overlap with existing icons
    function checkIconOverlap(left, top, iconWidth, iconHeight, excludeIconId = null) {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (!desktopIconsContainer) return false;
        
        const icons = desktopIconsContainer.querySelectorAll('.desktop-icon');
        const padding = 5; // Minimum spacing between icons
        
        for (const icon of icons) {
            // Skip the icon we're checking for (when moving an existing icon)
            if (excludeIconId && icon.id === excludeIconId) {
                continue;
            }
            
            // Get icon position from style (already relative to container)
            // Handle both "80px" and "80" formats
            const iconLeftStr = icon.style.left || '';
            const iconTopStr = icon.style.top || '';
            const iconLeft = parseInt(iconLeftStr.replace('px', '')) || icon.offsetLeft || 0;
            const iconTop = parseInt(iconTopStr.replace('px', '')) || icon.offsetTop || 0;
            const iconWidthActual = icon.offsetWidth || 80; // Default to 80px if not available
            const iconHeightActual = icon.offsetHeight || 80; // Default to 80px if not available
            
            const iconRight = iconLeft + iconWidthActual;
            const iconBottom = iconTop + iconHeightActual;
            
            // Check if the new position overlaps with this icon
            const newRight = left + iconWidth;
            const newBottom = top + iconHeight;
            
            // Check for overlap (with padding)
            if (!(newRight + padding < iconLeft || 
                  left - padding > iconRight || 
                  newBottom + padding < iconTop || 
                  top - padding > iconBottom)) {
                return true; // Overlap detected
            }
        }
        
        return false; // No overlap
    }
    
    // Helper function to find a non-overlapping position
    function findNonOverlappingPosition(iconWidth, iconHeight, startLeft = 80, startTop = 20, excludeIconId = null) {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (!desktopIconsContainer) return { left: startLeft, top: startTop };
        
        const containerRect = desktopIconsContainer.getBoundingClientRect();
        const maxX = containerRect.width - iconWidth;
        const dockTop = getDockTopBoundaryPx();
        const dockRelativeMaxY = dockTop - containerRect.top - iconHeight;
        const maxY = Math.max(0, Math.min(containerRect.height - iconHeight, dockRelativeMaxY));
        
        const stepX = 100; // Horizontal step
        const stepY = 100; // Vertical step
        
        // Try positions in a grid pattern
        for (let y = startTop; y <= maxY; y += stepY) {
            for (let x = startLeft; x <= maxX; x += stepX) {
                if (!checkIconOverlap(x, y, iconWidth, iconHeight, excludeIconId)) {
                    return { left: x, top: y };
                }
            }
        }
        
        // If no position found in grid, try smaller steps
        for (let y = startTop; y <= maxY; y += 20) {
            for (let x = startLeft; x <= maxX; x += 20) {
                if (!checkIconOverlap(x, y, iconWidth, iconHeight, excludeIconId)) {
                    return { left: x, top: y };
                }
            }
        }
        
        // Fallback: return start position
        return { left: startLeft, top: startTop };
    }
    
    // Helper function to get file icon SVG (similar to Files app)
    function getFileIconSvg(fileName, isFolder = false) {
        if (isFolder) {
            return '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
        }
        
        const ext = fileName.split('.').pop().toLowerCase();
        const iconMap = {
            'lnk': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>',
            'txt': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>',
            'jpg': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
            'jpeg': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
            'png': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
            'gif': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>',
            'mp3': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>',
            'mp4': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>',
            'zip': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
            'pdf': '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>'
        };
        return iconMap[ext] || '<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path><path d="M16 13H8"></path><path d="M16 17H8"></path><path d="M10 9H8"></path></svg>';
    }

    function isDesktopImageFile(fileName) {
        const ext = String(fileName || '').split('.').pop().toLowerCase();
        const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
        return imageExts.includes(ext);
    }

    async function applyDesktopImagePreview(iconImageEl, filePath, fileName) {
        if (!iconImageEl || !filePath || !fileName) return;
        // Skip if already applied for this path
        if (iconImageEl.dataset && iconImageEl.dataset.previewPath === filePath && iconImageEl.querySelector('img')) {
            return;
        }
        try {
            const imageUrl = await getImageUrlFromFilesystem(filePath);
            if (!imageUrl) return;

            // Build DOM nodes (safer than innerHTML for URLs)
            iconImageEl.textContent = '';
            const img = document.createElement('img');
            img.alt = fileName;
            img.draggable = false;
            img.src = imageUrl;
            img.addEventListener('error', () => {
                // Fallback to icon if preview fails
                iconImageEl.innerHTML = getFileIconSvg(fileName, false);
                if (iconImageEl.dataset) delete iconImageEl.dataset.previewPath;
            }, { once: true });
            iconImageEl.appendChild(img);
            if (iconImageEl.dataset) iconImageEl.dataset.previewPath = filePath;
        } catch (e) {
            // Non-fatal
        }
    }
    
    // Function to create a desktop icon
    function createDesktopIcon(iconId, label, iconSvg, filePath = null, itemType = null, options = null) {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (!desktopIconsContainer) return null;
        
        // Check if icon already exists
        const existingIcon = document.getElementById(iconId);
        if (existingIcon) return existingIcon;
        
        // Create icon element
        const icon = document.createElement('div');
        icon.className = 'desktop-icon';
        icon.id = iconId;
        icon.style.position = 'absolute';
        
        // Set data attributes for drag and drop
        if (filePath) {
            icon.dataset.filePath = filePath;
            icon.dataset.itemType = itemType || 'file';
        }
        
        // Create icon image
        const iconImage = document.createElement('div');
        iconImage.className = 'desktop-icon-image';
        iconImage.innerHTML = iconSvg;

        // For image files, show a live preview instead of a generic icon
        if (itemType === 'file' && filePath && isDesktopImageFile(label)) {
            // Keep placeholder icon while loading
            applyDesktopImagePreview(iconImage, filePath, label);
        }
        
        // Create icon label - use display name (respects extension visibility setting)
        const iconLabel = document.createElement('div');
        iconLabel.className = 'desktop-icon-label';
        // For files, use display name (may hide extension); for folders, use full name
        const displayLabel = (itemType === 'file' && filePath) ? 
            (window.getDisplayFileName ? window.getDisplayFileName(label) : label) : label;
        iconLabel.textContent = displayLabel;
        
        // Assemble icon
        icon.appendChild(iconImage);
        icon.appendChild(iconLabel);
        
        const opts = options || {};

        // Load saved position
        const savedPosition = localStorage.getItem(`${iconId}Position`);
        let iconLeft, iconTop;
        const hasSavedPosition = !!savedPosition;
        if (savedPosition) {
            try {
                const position = JSON.parse(savedPosition);
                iconLeft = parseInt(position.left) || 0;
                iconTop = parseInt(position.top) || 0;
            } catch (e) {
                console.warn('Could not parse saved position for', iconId);
                iconLeft = 0;
                iconTop = 0;
            }
        } else {
            // Default position (top-left area, accounting for dock)
            // Prefer a caller-provided placement index to avoid repeated DOM scans during bulk refresh.
            // Fallback to counting existing file icons.
            const placementIndex = (typeof opts.placementIndex === 'number')
                ? opts.placementIndex
                : desktopIconsContainer.querySelectorAll('.desktop-icon[data-file-path]').length;

            const savedSize = opts.savedIconSize || localStorage.getItem('desktopIconSize') || 'small';
            const sizes = {
                small: { icon: 32, label: 11, container: 70 },
                medium: { icon: 48, label: 12, container: 80 },
                large: { icon: 64, label: 13, container: 100 }
            };
            const sizeConfig = sizes[savedSize] || sizes.small;

            // Cell sizes are intentionally roomy so we don't need expensive overlap checks for default placement.
            const cellWidth = Math.max(100, sizeConfig.container + 24);
            const cellHeight = Math.max(100, sizeConfig.icon + 60);
            const containerRect = desktopIconsContainer.getBoundingClientRect();
            const leftMargin = 20;
            const rightMargin = 20;
            const topMargin = 20;
            const availableWidth = Math.max(1, (containerRect.width - leftMargin - rightMargin));
            const iconsPerRow = Math.max(1, Math.floor(availableWidth / cellWidth));
            const row = Math.floor(placementIndex / iconsPerRow);
            const col = placementIndex % iconsPerRow;
            iconLeft = leftMargin + col * cellWidth;
            iconTop = topMargin + row * cellHeight;
        }
        
        // Snap to grid if grid mode is enabled - read from localStorage to ensure current state
        const gridEnabled = (typeof opts.gridEnabled === 'boolean')
            ? opts.gridEnabled
            : (localStorage.getItem('desktopGridEnabled') === 'true');
        if (gridEnabled) {
            iconLeft = Math.round(iconLeft / GRID_SIZE) * GRID_SIZE;
            iconTop = Math.round(iconTop / GRID_SIZE) * GRID_SIZE;
        }

        // Apply saved desktop icon size to newly created icons (caller can provide cached value).
        // Without this, icons created during `refreshDesktopIcons()` can fall back to CSS defaults (medium),
        // because `setDesktopIconSize()` can run before the async refresh creates any icons.
        try {
            const savedSize = opts.savedIconSize || localStorage.getItem('desktopIconSize') || 'small';
            applyDesktopIconSizeToIcon(icon, savedSize);
        } catch (e) {
            // Non-fatal; keep default sizing
        }

        icon.style.left = iconLeft + 'px';
        icon.style.top = iconTop + 'px';

        // Add icon to DOM now that we have an initial position.
        desktopIconsContainer.appendChild(icon);

        // For bulk refresh default placement, skip expensive overlap checks (we already spaced cells generously).
        const shouldSkipOverlap = !hasSavedPosition && !!opts.skipOverlapForDefaultPlacement;
        if (!shouldSkipOverlap) {
            const iconWidth = icon.offsetWidth || 80;
            const iconHeight = icon.offsetHeight || 80;

            // Check for overlap and find a non-overlapping position if needed
            if (checkIconOverlap(iconLeft, iconTop, iconWidth, iconHeight, iconId)) {
                const newPosition = findNonOverlappingPosition(iconWidth, iconHeight, iconLeft, iconTop, iconId);
                iconLeft = newPosition.left;
                iconTop = newPosition.top;

                // Snap to grid again if enabled
                if (gridEnabled) {
                    iconLeft = Math.round(iconLeft / GRID_SIZE) * GRID_SIZE;
                    iconTop = Math.round(iconTop / GRID_SIZE) * GRID_SIZE;
                }

                icon.style.left = iconLeft + 'px';
                icon.style.top = iconTop + 'px';
            }
        }
        
        // Apply lock state (cursor style) - read from localStorage to ensure current state
        const isLocked = (typeof opts.isLocked === 'boolean')
            ? opts.isLocked
            : (localStorage.getItem('desktopIconsLocked') === 'true');
        if (isLocked) {
            icon.style.cursor = 'default';
        } else {
            icon.style.cursor = 'move';
        }
        
        // Icon is already added to desktop (was added earlier for dimension calculation)
        
        // Make icon draggable
        makeIconDraggable(icon, iconId);
        
        // Add context menu handler for files/folders
        if (filePath) {
            icon.addEventListener('contextmenu', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove existing context menu
                const existing = document.querySelector('.file-context-menu');
                if (existing) existing.remove();
                
                const menu = document.createElement('div');
                menu.className = 'context-menu file-context-menu show';
                
                // Position menu, ensuring it stays within viewport
                let left = e.pageX;
                let top = e.pageY;
                const menuWidth = 220;
                const menuHeight = 400;
                
                if (left + menuWidth > window.innerWidth) {
                    left = window.innerWidth - menuWidth - 10;
                }
                if (top + menuHeight > window.innerHeight) {
                    top = window.innerHeight - menuHeight - 10;
                }
                
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                menu.style.display = 'flex';
                menu.style.zIndex = '10000';
                
                // Helper function to check if file is an image
                function isImageFile(fileName) {
                    const ext = fileName.split('.').pop().toLowerCase();
                    const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
                    return imageExts.includes(ext);
                }
                
                // Helper function to get user folder path
                function getUserFolderPath(folderName) {
                    const loggedInUser = localStorage.getItem('loggedInUser');
                    if (loggedInUser) {
                        try {
                            const user = JSON.parse(loggedInUser);
                            return `/Users/${user.name}/${folderName}`;
                        } catch (e) {
                            console.warn('Could not parse logged-in user:', e);
                        }
                    }
                    return `/${folderName}`;
                }
                
                // Build menu HTML
                let menuHTML = '';
                
                if (itemType === 'folder') {
                    menuHTML = `
                        <div class="context-menu-item" data-action="open">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </div>
                            <span>Open</span>
                        </div>
                        <div class="context-menu-item" data-action="open-new-window">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="9" y1="3" x2="9" y2="21"></line>
                                </svg>
                            </div>
                            <span>Open in New Window</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="cut">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="6" cy="6" r="3"></circle>
                                    <circle cx="6" cy="18" r="3"></circle>
                                    <line x1="6" y1="9" x2="6" y2="15"></line>
                                    <path d="M20 4l-7 7m0 0l7 7m-7-7v12"></path>
                                </svg>
                            </div>
                            <span>Cut</span>
                            <span class="context-menu-shortcut">Ctrl+X</span>
                        </div>
                        <div class="context-menu-item" data-action="copy">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </div>
                            <span>Copy</span>
                            <span class="context-menu-shortcut">Ctrl+C</span>
                        </div>
                        <div class="context-menu-item" data-action="duplicate">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </div>
                            <span>Duplicate</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="rename">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </div>
                            <span>Rename</span>
                            <span class="context-menu-shortcut">F2</span>
                        </div>
                        <div class="context-menu-item" data-action="properties">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </div>
                            <span>Properties</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="delete">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </div>
                            <span>Delete</span>
                            <span class="context-menu-shortcut">Del</span>
                        </div>
                    `;
                } else {
                    menuHTML = `
                        <div class="context-menu-item" data-action="open">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </div>
                            <span>Open</span>
                            <span class="context-menu-shortcut">Enter</span>
                        </div>
                        <div class="context-menu-item" data-action="open-with">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <polyline points="12 6 12 12 16 14"></polyline>
                                </svg>
                            </div>
                            <span>Open With...</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="cut">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="6" cy="6" r="3"></circle>
                                    <circle cx="6" cy="18" r="3"></circle>
                                    <line x1="6" y1="9" x2="6" y2="15"></line>
                                    <path d="M20 4l-7 7m0 0l7 7m-7-7v12"></path>
                                </svg>
                            </div>
                            <span>Cut</span>
                            <span class="context-menu-shortcut">Ctrl+X</span>
                        </div>
                        <div class="context-menu-item" data-action="copy">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </div>
                            <span>Copy</span>
                            <span class="context-menu-shortcut">Ctrl+C</span>
                        </div>
                        <div class="context-menu-item" data-action="duplicate">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                            </div>
                            <span>Duplicate</span>
                        </div>
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="rename">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </div>
                            <span>Rename</span>
                            <span class="context-menu-shortcut">F2</span>
                        </div>
                        <div class="context-menu-item" data-action="download">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                            </div>
                            <span>Download</span>
                        </div>
                        <div class="context-menu-item" data-action="properties">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="16" x2="12" y2="12"></line>
                                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                </svg>
                            </div>
                            <span>Properties</span>
                        </div>
                        ${isImageFile(label) ? `
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="set-background">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                    <polyline points="21 15 16 10 5 21"></polyline>
                                </svg>
                            </div>
                            <span>Set As Background</span>
                        </div>
                        ` : ''}
                        <div class="context-menu-divider"></div>
                        <div class="context-menu-item" data-action="delete">
                            <div class="context-menu-icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                            </div>
                            <span>Delete</span>
                            <span class="context-menu-shortcut">Del</span>
                        </div>
                    `;
                }
                
                menu.innerHTML = menuHTML;
                document.body.appendChild(menu);
                
                // Handle menu item clicks
                menu.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const action = item.dataset.action;
                        menu.remove();
                        
                        try {
                            const fs = await initFileSystem();
                            
                            if (action === 'open') {
                                if (itemType === 'folder') {
                                    // Open folder in Files app
                                    const filesWindow = document.querySelector('.file-explorer-content');
                                    if (filesWindow && (filesWindow.style.display !== 'none')) {
                                        const sidebarItem = filesWindow.querySelector('[data-location="desktop"]');
                                        if (sidebarItem) {
                                            sidebarItem.click();
                                        }
                                        focusWindow(filesWindow);
                                    } else {
                                        initFileExplorer();
                                        setTimeout(() => {
                                            const newFilesWindow = document.querySelector('.file-explorer-content');
                                            if (newFilesWindow) {
                                                const sidebarItem = newFilesWindow.querySelector('[data-location="desktop"]');
                                                if (sidebarItem) {
                                                    sidebarItem.click();
                                                }
                                                focusWindow(newFilesWindow);
                                            }
                                        }, 100);
                                    }
                                } else {
                                    // Open file
                                    const ext = label.split('.').pop().toLowerCase();
                                    const textExts = ['txt', 'md', 'js', 'css', 'html', 'json', 'xml', 'csv', 'log'];
                                    const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
                                    const file = await fs.getFile(filePath);
                                    
                                    if (imageExts.includes(ext)) {
                                        const openViewer = initViewer();
                                        if (openViewer) {
                                            openViewer(filePath);
                                        }
                                    } else if (textExts.includes(ext) || !file.isBinary) {
                                        if (window.openEditorWindow) {
                                            await window.openEditorWindow(filePath, label);
                                        }
                                    } else if (ext === 'lnk') {
                                        try {
                                            const content = await fs.getFileContent(filePath);
                                            const shortcutData = JSON.parse(content);
                                            if (shortcutData.appName === 'Files') {
                                                initFileExplorer();
                                            } else if (shortcutData.appName === 'Settings') {
                                                initSettingsWindow();
                                            } else if (shortcutData.appName === 'Editor') {
                                                openTextEditor();
                                            } else if (shortcutData.appName === 'Viewer') {
                                                const openViewer = initViewer();
                                                if (openViewer) openViewer();
                                            }
                                        } catch (e) {
                                            console.error('Error reading shortcut:', e);
                                        }
                                    } else {
                                        alert(`File type ${ext} not directly openable. Use Files app to download.`);
                                    }
                                }
                            } else if (action === 'open-new-window') {
                                // Open folder in new Files app window
                                if (itemType === 'folder') {
                                    const openFileExplorer = initFileExplorer();
                                    if (openFileExplorer) {
                                        openFileExplorer(filePath);
                                    }
                                } else {
                                    // For files, just open a new Files window at the root
                                    const openFileExplorer = initFileExplorer();
                                    if (openFileExplorer) {
                                        openFileExplorer();
                                    }
                                }
                            } else if (action === 'open-with') {
                                // For now, just open normally
                                const ext = label.split('.').pop().toLowerCase();
                                const textExts = ['txt', 'md', 'js', 'css', 'html', 'json', 'xml', 'csv', 'log'];
                                const file = await fs.getFile(filePath);
                                
                                if (textExts.includes(ext) || !file.isBinary) {
                                    if (window.openEditorWindow) {
                                        await window.openEditorWindow(filePath, label);
                                    }
                                }
                            } else if (action === 'cut') {
                                const itemObj = itemType === 'folder' ? await fs.getFolder(filePath) : await fs.getFile(filePath);
                                // Store in a global clipboard (we'll need to create one if it doesn't exist)
                                if (!window.desktopClipboard) {
                                    window.desktopClipboard = {};
                                }
                                window.desktopClipboard = { type: 'cut', item: itemObj, path: filePath, name: label, itemType: itemType };
                            } else if (action === 'copy') {
                                const itemObj = itemType === 'folder' ? await fs.getFolder(filePath) : await fs.getFile(filePath);
                                if (!window.desktopClipboard) {
                                    window.desktopClipboard = {};
                                }
                                window.desktopClipboard = { type: 'copy', item: itemObj, path: filePath, name: label, itemType: itemType };
                            } else if (action === 'duplicate') {
                                const parentPath = fs.getParentPath(filePath);
                                let newName = label;
                                let counter = 1;
                                
                                // Find unique name
                                while (true) {
                                    const testPath = parentPath === '/' ? `/${newName}` : `${parentPath}/${newName}`;
                                    const exists = itemType === 'folder' ? await fs.getFolder(testPath) : await fs.getFile(testPath);
                                    if (!exists) break;
                                    
                                    const ext = label.includes('.') ? label.substring(label.lastIndexOf('.')) : '';
                                    const base = label.includes('.') ? label.substring(0, label.lastIndexOf('.')) : label;
                                    newName = `${base} (${counter})${ext}`;
                                    counter++;
                                }
                                
                                if (itemType === 'folder') {
                                    await fs.createFolder(parentPath, newName);
                                    // Copy folder contents recursively
                                    const sourceDir = await fs.listDirectory(filePath);
                                    const newPath = parentPath === '/' ? `/${newName}` : `${parentPath}/${newName}`;
                                    
                                    // Copy files
                                    for (const file of sourceDir.files) {
                                        const content = await fs.getFileContent(file.path);
                                        await fs.createFile(newPath, file.name, content);
                                    }
                                    
                                    // Copy subfolders recursively
                                    async function duplicateFolderRecursive(sourceFolderPath, targetParentPath) {
                                        const dir = await fs.listDirectory(sourceFolderPath);
                                        const folderName = sourceFolderPath.split('/').pop();
                                        await fs.createFolder(targetParentPath, folderName);
                                        const newFolderPath = targetParentPath === '/' ? `/${folderName}` : `${targetParentPath}/${folderName}`;
                                        
                                        for (const file of dir.files) {
                                            const content = await fs.getFileContent(file.path);
                                            await fs.createFile(newFolderPath, file.name, content);
                                        }
                                        
                                        for (const folder of dir.folders) {
                                            await duplicateFolderRecursive(folder.path, newFolderPath);
                                        }
                                    }
                                    
                                    for (const folder of sourceDir.folders) {
                                        await duplicateFolderRecursive(folder.path, newPath);
                                    }
                                } else {
                                    const content = await fs.getFileContent(filePath);
                                    await fs.createFile(parentPath, newName, content);
                                }
                                
                                // Refresh desktop icons
                                if (window.refreshDesktopIcons) {
                                    await window.refreshDesktopIcons();
                                }
                                
                                // Refresh Files app if showing Desktop
                                const filesWindow = document.querySelector('.file-explorer-content');
                                if (filesWindow) {
                                    const activeSidebarItem = filesWindow.querySelector('.sidebar-item.active[data-location="desktop"]');
                                    if (activeSidebarItem) {
                                        activeSidebarItem.click();
                                    }
                                }
                            } else if (action === 'rename') {
                                const newName = await showRenameDialog(label, 'Rename');
                                if (newName && newName !== label) {
                                    if (/[<>:"/\\|?*]/.test(newName)) {
                                        showNotification('File name cannot contain: < > : " / \\ | ? *', 'error');
                                        return;
                                    }
                                    await fs.rename(filePath, newName);
                                    
                                    // Refresh desktop icons
                                    if (window.refreshDesktopIcons) {
                                        await window.refreshDesktopIcons();
                                    }
                                    
                                    // Refresh Files app if showing Desktop
                                    const filesWindow = document.querySelector('.file-explorer-content');
                                    if (filesWindow) {
                                        const activeSidebarItem = filesWindow.querySelector('.sidebar-item.active[data-location="desktop"]');
                                        if (activeSidebarItem) {
                                            activeSidebarItem.click();
                                        }
                                    }
                                }
                            } else if (action === 'download') {
                                const content = await fs.getFileContent(filePath);
                                let blob;
                                if (content instanceof Blob) {
                                    blob = content;
                                } else {
                                    blob = new Blob([content], { type: 'text/plain' });
                                }
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = label;
                                a.click();
                                URL.revokeObjectURL(url);
                            } else if (action === 'properties') {
                                // Use the shared global Properties window (same as Files app)
                                if (typeof globalThis.showProperties === 'function') {
                                    await globalThis.showProperties(filePath, itemType, label);
                                }
                            } else if (action === 'set-background') {
                                if (itemType === 'file' && isImageFile(label)) {
                                    try {
                                        // Always call the global background setter (avoids any accidental shadowing)
                                        if (typeof globalThis.setCustomBackground === 'function') {
                                            await globalThis.setCustomBackground(filePath);
                                        }
                                    } catch (error) {
                                        alert('Error setting background: ' + error.message);
                                    }
                                }
                            } else if (action === 'delete') {
                                const message = `Are you sure you want to delete "${label}"?`;
                                const confirmed = await showConfirmationDialog(message, 'Delete');
                                if (confirmed) {
                                    // Ensure Trash folder exists
                                    const trashPath = getUserFolderPath('Trash');
                                    let trashFolder = await fs.getFolder(trashPath);
                                    if (!trashFolder) {
                                        const pathParts = trashPath.split('/').filter(p => p);
                                        const folderName = pathParts.pop();
                                        const parentPath = '/' + pathParts.join('/');
                                        await fs.createFolder(parentPath, folderName);
                                    }
                                    
                                    if (itemType === 'folder') {
                                        await fs.moveFolderToTrash(filePath);
                                    } else {
                                        await fs.moveToTrash(filePath);
                                    }
                                    
                                    // Refresh desktop icons
                                    if (window.refreshDesktopIcons) {
                                        await window.refreshDesktopIcons();
                                    }
                                    
                                    // Refresh Files app if showing Desktop
                                    const filesWindow = document.querySelector('.file-explorer-content');
                                    if (filesWindow) {
                                        const activeSidebarItem = filesWindow.querySelector('.sidebar-item.active[data-location="desktop"]');
                                        if (activeSidebarItem) {
                                            activeSidebarItem.click();
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            alert('Error: ' + error.message);
                        }
                    });
                });
                
                // Close menu when clicking outside or pressing Escape
                const closeMenu = () => {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                    document.removeEventListener('keydown', escapeHandler);
                };
                
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        closeMenu();
                    }
                };
                
                setTimeout(() => {
                    document.addEventListener('click', closeMenu, { once: true });
                    document.addEventListener('keydown', escapeHandler, { once: true });
                }, 0);
            });
        }
        
        // Add double-click handler for files/folders
        if (filePath) {
            icon.addEventListener('dblclick', async () => {
                const fileName = filePath.split('/').pop();
                
                if (itemType === 'folder') {
                    // Open folder in Files app
                    const filesContent = document.querySelector('.file-explorer-content');
                    if (filesContent) {
                        // Find the parent window element
                        const filesWindow = filesContent.closest('.window');
                        if (filesWindow && filesWindow.style.display !== 'none') {
                            // Files app is open, navigate directly to this folder
                            if (filesWindow.navigateToPath) {
                                await filesWindow.navigateToPath(filePath);
                                focusWindow(filesWindow);
                            } else {
                                // Fallback: navigate to Desktop if navigateToPath not available
                                const sidebarItem = filesContent.querySelector('[data-location="desktop"]');
                                if (sidebarItem) {
                                    sidebarItem.click();
                                }
                                focusWindow(filesWindow);
                            }
                        } else {
                            // Files app is open but minimized, restore it and navigate
                            const existingWindow = filesContent.closest('.window');
                            if (existingWindow) {
                                existingWindow.style.display = 'flex';
                                if (existingWindow.navigateToPath) {
                                    await existingWindow.navigateToPath(filePath);
                                }
                                focusWindow(existingWindow);
                            } else {
                                // Open new Files window directly at this folder's path
                                const openFileExplorer = initFileExplorer();
                                if (openFileExplorer) {
                                    openFileExplorer(filePath);
                                }
                            }
                        }
                    } else {
                        // Open new Files window directly at this folder's path
                        const openFileExplorer = initFileExplorer();
                        if (openFileExplorer) {
                            openFileExplorer(filePath);
                        }
                    }
                } else {
                    // Open file - use the same logic as Files app
                    const fs = await initFileSystem();
                    const file = await fs.getFile(filePath);
                    if (file) {
                        const ext = fileName.split('.').pop().toLowerCase();
                        const textExts = ['txt', 'md', 'js', 'css', 'html', 'json', 'xml', 'csv', 'log'];
                        const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
                        
                        if (imageExts.includes(ext)) {
                            const openViewer = initViewer();
                            if (openViewer) {
                                openViewer(filePath);
                            }
                        } else if (textExts.includes(ext) || !file.isBinary) {
                            // Open in editor
                            if (window.openEditorWindow) {
                                await window.openEditorWindow(filePath, fileName);
                            }
                        } else if (ext === 'lnk') {
                            // Handle shortcut files
                            try {
                                const content = await fs.getFileContent(filePath);
                                const shortcutData = JSON.parse(content);
                                if (shortcutData.appName === 'Files') {
                                    initFileExplorer();
                                } else if (shortcutData.appName === 'Settings') {
                                    initSettingsWindow();
                                } else if (shortcutData.appName === 'Editor') {
                                    openTextEditor();
                                } else if (shortcutData.appName === 'Viewer') {
                                    const openViewer = initViewer();
                                    if (openViewer) openViewer();
                                }
                            } catch (e) {
                                console.error('Error reading shortcut:', e);
                            }
                        } else {
                            // Download binary files
                            alert(`File type ${ext} not directly openable. Use Files app to download.`);
                        }
                    }
                }
            });
        }
        
        return icon;
    }
    
    // Function to refresh desktop icons from Desktop folder
    async function refreshDesktopIcons() {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (!desktopIconsContainer) return;
        
        try {
            const fs = await initFileSystem();
            
            // Helper function to get user-specific Desktop path
            function getUserFolderPath(folderName) {
                const loggedInUser = localStorage.getItem('loggedInUser');
                if (loggedInUser) {
                    try {
                        const user = JSON.parse(loggedInUser);
                        return `/Users/${user.name}/${folderName}`;
                    } catch (e) {
                        console.warn('Could not parse logged-in user:', e);
                    }
                }
                return `/${folderName}`;
            }
            
            const desktopPath = getUserFolderPath('Desktop');
            
            // Get Desktop folder contents
            let directory;
            try {
                directory = await fs.listDirectory(desktopPath);
            } catch (e) {
                // Desktop folder doesn't exist yet, that's okay
                directory = { files: [], folders: [] };
            }
            
            // Get all existing file/folder icons (exclude special icons like butterfly)
            const existingIcons = desktopIconsContainer.querySelectorAll('.desktop-icon[data-file-path]');
            const existingPaths = new Set();
            existingIcons.forEach(icon => {
                if (icon.dataset.filePath) {
                    existingPaths.add(icon.dataset.filePath);
                }
            });

            const currentPaths = new Set();
            for (const folder of directory.folders) currentPaths.add(folder.path);
            for (const file of directory.files) currentPaths.add(file.path);

            // Cache settings used by icon creation to avoid repeated localStorage hits per icon.
            const gridEnabled = localStorage.getItem('desktopGridEnabled') === 'true';
            const isLocked = localStorage.getItem('desktopIconsLocked') === 'true';
            const savedIconSize = localStorage.getItem('desktopIconSize') || 'small';

            // Default-placement index to avoid per-icon DOM scans.
            let placementIndex = desktopIconsContainer.querySelectorAll('.desktop-icon[data-file-path]').length;
            
            // Create icons for folders
            for (const folder of directory.folders) {
                const iconId = `desktop-icon-${folder.path.replace(/[^a-zA-Z0-9]/g, '-')}`;
                if (!existingPaths.has(folder.path)) {
                    const iconSvg = getFileIconSvg(folder.name, true);
                    createDesktopIcon(iconId, folder.name, iconSvg, folder.path, 'folder', {
                        placementIndex: placementIndex++,
                        gridEnabled,
                        isLocked,
                        savedIconSize,
                        skipOverlapForDefaultPlacement: true
                    });
                } else {
                    // Update existing icon label if extension visibility changed
                    const existingIcon = document.getElementById(iconId);
                    if (existingIcon) {
                        const labelElement = existingIcon.querySelector('.desktop-icon-label');
                        if (labelElement) {
                            labelElement.textContent = folder.name; // Folders always show full name
                        }
                    }
                }
            }
            
            // Create icons for files
            for (const file of directory.files) {
                const iconId = `desktop-icon-${file.path.replace(/[^a-zA-Z0-9]/g, '-')}`;
                if (!existingPaths.has(file.path)) {
                    const iconSvg = getFileIconSvg(file.name, false);
                    createDesktopIcon(iconId, file.name, iconSvg, file.path, 'file', {
                        placementIndex: placementIndex++,
                        gridEnabled,
                        isLocked,
                        savedIconSize,
                        skipOverlapForDefaultPlacement: true
                    });
                } else {
                    // Update existing icon label if extension visibility changed
                    const existingIcon = document.getElementById(iconId);
                    if (existingIcon) {
                        const labelElement = existingIcon.querySelector('.desktop-icon-label');
                        if (labelElement) {
                            // Update label based on current extension visibility setting
                            labelElement.textContent = window.getDisplayFileName ? window.getDisplayFileName(file.name) : file.name;
                        }
                        // Ensure image files display a preview
                        if (isDesktopImageFile(file.name)) {
                            const iconImageEl = existingIcon.querySelector('.desktop-icon-image');
                            applyDesktopImagePreview(iconImageEl, file.path, file.name);
                        } else {
                            // If it used to be an image preview but isn't anymore, revert to an icon
                            const iconImageEl = existingIcon.querySelector('.desktop-icon-image');
                            if (iconImageEl && iconImageEl.querySelector('img')) {
                                iconImageEl.innerHTML = getFileIconSvg(file.name, false);
                                if (iconImageEl.dataset) delete iconImageEl.dataset.previewPath;
                            }
                        }
                    }
                }
            }
            
            // Also update all existing file icons that might have been created before
            existingIcons.forEach(icon => {
                const filePath = icon.dataset.filePath;
                const itemType = icon.dataset.itemType;
                if (filePath && itemType === 'file') {
                    // Get the actual file name from the path
                    const fileName = filePath.split('/').pop();
                    const labelElement = icon.querySelector('.desktop-icon-label');
                    if (labelElement && fileName) {
                        labelElement.textContent = window.getDisplayFileName ? window.getDisplayFileName(fileName) : fileName;
                    }
                }
            });
            
            // Remove icons for files/folders that no longer exist in Desktop
            existingIcons.forEach(icon => {
                const filePath = icon.dataset.filePath;
                if (filePath) {
                    if (!currentPaths.has(filePath)) {
                        icon.remove();
                        // Clean up saved position
                        const iconId = icon.id;
                        if (iconId) {
                            localStorage.removeItem(`${iconId}Position`);
                        }
                    }
                }
            });

            // Ensure icon sizing is applied after refresh completes.
            // Without this, a page reload can show CSS defaults (medium) if icons are created after the
            // initial size application runs.
            try {
                desktopIconsContainer.querySelectorAll('.desktop-icon').forEach(icon => {
                    applyDesktopIconSizeToIcon(icon, savedIconSize);
                });
            } catch (e) {
                // Non-fatal
            }
        } catch (error) {
            console.error('Error refreshing desktop icons:', error);
        }
    }
    
    // Make refreshDesktopIcons available globally
    window.refreshDesktopIcons = refreshDesktopIcons;
    
    // Function to update all desktop icon labels based on extension visibility setting
    function updateDesktopIconLabels() {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        if (!desktopIconsContainer) return;
        
        const icons = desktopIconsContainer.querySelectorAll('.desktop-icon[data-file-path]');
        icons.forEach(icon => {
            const filePath = icon.dataset.filePath;
            const itemType = icon.dataset.itemType;
            
            if (filePath && itemType === 'file') {
                // Get the actual file name from the path
                const fileName = filePath.split('/').pop();
                const labelElement = icon.querySelector('.desktop-icon-label');
                if (labelElement && fileName && window.getDisplayFileName) {
                    // Update label based on current extension visibility setting
                    labelElement.textContent = window.getDisplayFileName(fileName);
                }
            }
            // Folders always show full name, no need to update
        });
    }
    
    // Make updateDesktopIconLabels available globally
    window.updateDesktopIconLabels = updateDesktopIconLabels;
    
    // Remove any existing butterfly icons
    const existingButterflyIcon = document.getElementById('butterfly-icon');
    if (existingButterflyIcon) {
        existingButterflyIcon.remove();
        localStorage.removeItem('butterfly-iconPosition');
    }
    
    // If grid mode is enabled, snap all existing icons to grid
    if (desktopGridEnabled) {
        setTimeout(() => {
            const icons = document.querySelectorAll('.desktop-icon');
            icons.forEach(icon => {
                const currentLeft = parseInt(icon.style.left) || icon.offsetLeft;
                const currentTop = parseInt(icon.style.top) || icon.offsetTop;
                const snappedLeft = Math.round(currentLeft / GRID_SIZE) * GRID_SIZE;
                const snappedTop = Math.round(currentTop / GRID_SIZE) * GRID_SIZE;
                icon.style.left = snappedLeft + 'px';
                icon.style.top = snappedTop + 'px';
                
                // Save the snapped position
                const iconId = icon.id;
                if (iconId && window.saveIconPosition) {
                    window.saveIconPosition(icon, iconId);
                }
            });
        }, 100);
    }
    
    // Setup drag and drop for desktop area
    setupDesktopDragAndDrop();
    
    // Refresh desktop icons from Desktop folder.
    // `initDesktop()` already awaits `initFileSystem()`, so an extra 500ms delay just makes reloads feel slow.
    requestAnimationFrame(async () => {
        if (window.refreshDesktopIcons) {
            await window.refreshDesktopIcons();
        }
    });
}

// Global flag to track if dragging from Files app
window.isDraggingFromFilesApp = false;
// Global flag to track if dragging from Desktop
window.isDraggingFromDesktop = false;

// Generate a non-conflicting name in a destination folder (Name (1).ext, Name (2).ext, ...)
async function getNonConflictingName(fs, destinationPath, desiredName, itemType) {
    const name = (desiredName || '').trim();
    if (!name) return desiredName;

    const isFolder = itemType === 'folder';
    const lastDot = !isFolder ? name.lastIndexOf('.') : -1;
    const base = (!isFolder && lastDot > 0) ? name.slice(0, lastDot) : name;
    const ext = (!isFolder && lastDot > 0) ? name.slice(lastDot) : '';

    for (let i = 1; i < 1000; i++) {
        const candidate = `${base} (${i})${ext}`;
        const candidatePath = destinationPath === '/' ? `/${candidate}` : `${destinationPath}/${candidate}`;
        const existsFile = await fs.getFile(candidatePath);
        const existsFolder = await fs.getFolder(candidatePath);
        if (!existsFile && !existsFolder) return candidate;
    }

    // Fallback (extremely unlikely)
    return `${base} (${Date.now()})${ext}`;
}

// Desktop Drag and Drop Functionality
function setupDesktopDragAndDrop() {
    const desktopIconsContainer = document.querySelector('.desktop-icons');
    const desktopContainer = document.querySelector('.desktop');
    if (!desktopIconsContainer || !desktopContainer) {
        console.error('Desktop containers not found:', {
            desktopIcons: !!desktopIconsContainer,
            desktop: !!desktopContainer
        });
        return;
    }

    // Helper function to get user-specific folder path (Desktop, Documents, etc.)
    // This must be in scope here; other parts of the code define it in narrower scopes.
    function getUserFolderPath(folderName) {
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                return `/Users/${user.name}/${folderName}`;
            } catch (e) {
                console.warn('Could not parse logged-in user:', e);
            }
        }
        return `/${folderName}`;
    }
    
    // Helper function to handle drop
    async function handleDesktopDrop(e) {
        if (!window.isDraggingFromFilesApp) return;
        
        // Capture drop coordinates early so we can do robust hit-testing
        const dropClientX = e.clientX;
        const dropClientY = e.clientY;

        // If the pointer is over a window (or other UI), do NOT treat this as a desktop drop.
        // Some browsers can report the desktop container as the event target; elementFromPoint is more reliable.
        try {
            const elUnderMouse = document.elementFromPoint(dropClientX, dropClientY);
            if (elUnderMouse && (
                elUnderMouse.closest('.window') ||
                elUnderMouse.closest('.dock') ||
                elUnderMouse.closest('.start-menu') ||
                elUnderMouse.closest('.notification-container')
            )) {
                return;
            }
        } catch (e) {}

        // Don't handle if dropping on a window, dock, or other interactive element
        if (e.target.closest('.window') || 
            e.target.closest('.dock') || 
            e.target.closest('.start-menu') ||
            e.target.closest('.notification-container')) {
            return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        desktopIconsContainer.classList.remove('drag-over-desktop');
        desktopIconsContainer.style.pointerEvents = 'none';
        desktopIconsContainer.style.zIndex = '900';
        window.isDraggingFromFilesApp = false;
        
        const sourcePath = e.dataTransfer.getData('text/plain');
        const sourceType = e.dataTransfer.getData('item-type');
        
        if (sourcePath) {
            try {
                const fs = await initFileSystem();
                const sourceParent = fs.getParentPath(sourcePath);
                
                // Get user-specific Desktop path
                const desktopPath = getUserFolderPath('Desktop');
                
                // Don't move if already in Desktop folder
                if (sourceParent === desktopPath) {
                    return;
                }
                
                // Prevent moving a folder into itself or its children
                if (desktopPath.startsWith(sourcePath + '/')) {
                    alert('Cannot move a folder into itself or its children');
                    return;
                }
                
                // Ensure Desktop folder exists
                let desktopFolder = await fs.getFolder(desktopPath);
                if (!desktopFolder) {
                    const pathParts = desktopPath.split('/').filter(p => p);
                    const folderName = pathParts.pop();
                    const parentPath = '/' + pathParts.join('/');
                    await fs.createFolder(parentPath, folderName);
                }
                
                // Move item to Desktop folder
                let movedItem;
                try {
                    movedItem = await fs.move(sourcePath, desktopPath);
                } catch (err) {
                    // Keep both by auto-renaming on conflict
                    if (err && err.message && err.message.includes('already exists')) {
                        const desiredName = sourcePath.split('/').pop();
                        const newName = await getNonConflictingName(fs, desktopPath, desiredName, sourceType);
                        movedItem = await fs.move(sourcePath, desktopPath, newName);
                    } else {
                        throw err;
                    }
                }

                // Save drop position so the moved item appears where the cursor was released
                try {
                    const newPath = movedItem && movedItem.path ? movedItem.path : null;
                    if (newPath && typeof dropClientX === 'number' && typeof dropClientY === 'number') {
                        const iconId = `desktop-icon-${newPath.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const containerRect = desktopIconsContainer.getBoundingClientRect();

                        // Desktop icons are ~80px wide; position so cursor lands near the icon center
                        const ICON_W = 80;
                        const ICON_H = 80;
                        let left = dropClientX - containerRect.left - Math.round(ICON_W / 2);
                        let top = dropClientY - containerRect.top - Math.round(ICON_H / 2);

                        // Clamp within the desktop icon container bounds and above the dock
                        const dockTop = getDockTopBoundaryPx();
                        const dockRelativeMaxY = dockTop - containerRect.top - ICON_H;
                        const maxX = Math.max(0, containerRect.width - ICON_W);
                        const maxY = Math.max(0, Math.min(containerRect.height - ICON_H, dockRelativeMaxY));
                        left = Math.max(0, Math.min(left, maxX));
                        top = Math.max(0, Math.min(top, maxY));

                        // Snap to grid if enabled
                        const gridEnabled = localStorage.getItem('desktopGridEnabled') === 'true';
                        if (gridEnabled && typeof GRID_SIZE !== 'undefined') {
                            left = Math.round(left / GRID_SIZE) * GRID_SIZE;
                            top = Math.round(top / GRID_SIZE) * GRID_SIZE;
                        }

                        localStorage.setItem(`${iconId}Position`, JSON.stringify({ left: `${left}px`, top: `${top}px` }));
                    }
                } catch (posErr) {
                    console.warn('Could not save drop position for desktop item:', posErr);
                }
                
                // Refresh desktop icons
                if (window.refreshDesktopIcons) {
                    await window.refreshDesktopIcons();
                }
                
                // Refresh Files app if it's open and showing Desktop
                const filesWindow = document.querySelector('.file-explorer-content');
                if (filesWindow) {
                    const itemsContainer = filesWindow.querySelector('.file-explorer-items');
                    if (itemsContainer) {
                        // Check if Files app is currently showing Desktop
                        const activeSidebarItem = filesWindow.querySelector('.sidebar-item.active[data-location="desktop"]');
                        if (activeSidebarItem) {
                            // Trigger a refresh by clicking the Desktop sidebar item
                            activeSidebarItem.click();
                        }
                    }
                }
            } catch (error) {
                // Don't show a dialog for protected sidebar folders; just ignore the drop.
                const msg = (error && error.message) ? error.message : String(error || '');
                if (msg.includes('Sidebar folders cannot be moved') || msg.includes('Cannot move this folder')) {
                    return;
                }
                alert('Error moving item to Desktop: ' + msg);
            }
        }
    }
    
    // Enable pointer events on desktop container when dragging from Files app
    // This is needed because the container has pointer-events: none by default
    document.addEventListener('dragover', (e) => {
        if (window.isDraggingFromFilesApp) {
            // Enable pointer events on desktop container so it can receive drag events
            desktopIconsContainer.style.pointerEvents = 'all';
            desktopIconsContainer.style.zIndex = '10000';
        }
    });
    
    // Allow dropping files/folders from Files app onto desktop icons container
    // Also allow dropping desktop icons when repositioning on desktop
    desktopIconsContainer.addEventListener('dragover', (e) => {
        if (window.isDraggingFromFilesApp) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'move';
            // Add visual feedback
            desktopIconsContainer.classList.add('drag-over-desktop');
        } else if (window.isDraggingFromDesktop) {
            // CRITICAL: Check if we're over a window FIRST - if so, don't handle it
            // Use elementFromPoint to check what's actually under the mouse cursor
            const elementUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
            const windowUnderMouse = elementUnderMouse && elementUnderMouse.closest('.window');
            
            // Also check if event target is a window (for cases where elementFromPoint doesn't work)
            const targetWindow = e.target.closest('.window');
            
            // If over any window, don't handle - let the window handle it
            if (windowUnderMouse || targetWindow) {
                return; // Don't prevent default or stop propagation
            }
            
            // Only handle if we're actually over the desktop (not a window)
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'move';
        }
    });
    
    desktopIconsContainer.addEventListener('dragleave', (e) => {
        // Only remove highlight if leaving the container itself
        if (e.target === desktopIconsContainer || !desktopIconsContainer.contains(e.relatedTarget)) {
            desktopIconsContainer.classList.remove('drag-over-desktop');
        }
    });
    
    desktopIconsContainer.addEventListener('drop', handleDesktopDrop);
    
    // Also handle drops on the main desktop container (for areas not covered by desktop-icons)
    desktopContainer.addEventListener('dragover', (e) => {
        if (window.isDraggingFromFilesApp) {
            // Don't prevent default if over a window or other interactive element
            if (e.target.closest('.window') || 
                e.target.closest('.dock') || 
                e.target.closest('.start-menu') ||
                e.target.closest('.notification-container')) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'move';
            // Add visual feedback to desktop-icons container
            desktopIconsContainer.style.pointerEvents = 'all';
            desktopIconsContainer.style.zIndex = '10000';
            desktopIconsContainer.classList.add('drag-over-desktop');
        } else if (window.isDraggingFromDesktop) {
            // CRITICAL: Check if we're over a window FIRST - if so, don't handle it
            // Use elementFromPoint to check what's actually under the mouse cursor
            const elementUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
            const windowUnderMouse = elementUnderMouse && elementUnderMouse.closest('.window');
            
            // Also check if event target is a window
            const targetWindow = e.target.closest('.window');
            
            // If over any window, don't handle - let the window handle it
            if (windowUnderMouse || targetWindow) {
                return; // Don't prevent default or stop propagation
            }
            
            // Don't handle if over other interactive elements
            if (e.target.closest('.dock') || 
                e.target.closest('.desktop-icon') ||
                e.target.closest('.start-menu') ||
                e.target.closest('.notification-container')) {
                return;
            }
            
            // Only handle if we're actually over the desktop (not a window or other element)
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'move';
        }
    });
    
    desktopContainer.addEventListener('dragleave', (e) => {
        // Only remove highlight if leaving the desktop container itself
        if (e.target === desktopContainer || !desktopContainer.contains(e.relatedTarget)) {
            desktopIconsContainer.classList.remove('drag-over-desktop');
        }
    });
    
    desktopContainer.addEventListener('drop', handleDesktopDrop);
}

// Helper function to load image from filesystem and return blob URL
async function getImageUrlFromFilesystem(imagePath) {
    try {
        // Check global cache first
        if (globalImageCache.has(imagePath)) {
            const cached = globalImageCache.get(imagePath);
            return cached.url;
        }
        
        const fs = await initFileSystem();
        const file = await fs.getFile(imagePath);
        if (!file) return null;
        
        const content = await fs.getFileContent(imagePath);
        let blob = null;
        
        if (content instanceof Blob) {
            blob = content;
        } else if (file.content instanceof ArrayBuffer) {
            const ext = imagePath.split('.').pop().toLowerCase();
            const mimeType = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' :
                           ext === 'png' ? 'image/png' :
                           ext === 'gif' ? 'image/gif' :
                           ext === 'webp' ? 'image/webp' :
                           ext === 'svg' ? 'image/svg+xml' :
                           ext === 'bmp' ? 'image/bmp' : 'image/jpeg';
            blob = new Blob([file.content], { type: mimeType });
        } else {
            return null;
        }
        
        // Create blob URL and cache it with blob reference to prevent garbage collection
        const imageUrl = URL.createObjectURL(blob);
        globalImageCache.set(imagePath, { url: imageUrl, blob: blob });
        return imageUrl;
    } catch (error) {
        console.warn('Error loading image from filesystem:', error);
        return null;
    }
}

// Set Custom Background from Image File
async function setCustomBackground(imagePath) {
    try {
        const desktop = document.querySelector('.desktop');
        if (!desktop) return;
        
        // Load image from filesystem and create blob URL
        const imageUrl = await getImageUrlFromFilesystem(imagePath);
        if (imageUrl) {
            // Apply the background
            desktop.style.backgroundImage = `url("${imageUrl}")`;
            desktop.style.background = `url("${imageUrl}"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)`;
            desktop.style.backgroundSize = 'cover';
            desktop.style.backgroundPosition = 'center';
            desktop.style.backgroundRepeat = 'no-repeat';
            desktop.style.animation = 'none';
            
            // Add to custom backgrounds list if not already there
            const stored = localStorage.getItem('customBackgrounds');
            const customBackgrounds = stored ? JSON.parse(stored) : [];
            const fileName = imagePath.split('/').pop();
            const exists = customBackgrounds.some(bg => bg.path === imagePath);
            if (!exists) {
                customBackgrounds.push({
                    path: imagePath,
                    name: fileName
                });
                localStorage.setItem('customBackgrounds', JSON.stringify(customBackgrounds));
            }
            
            // Save custom background path to localStorage
            localStorage.setItem('desktopBackground', `custom-${imagePath}`);
            localStorage.setItem('customBackgroundPath', imagePath);
            
            // Refresh background options in Settings window if open
            // Find all Settings windows and dispatch event to each
            const settingsWindows = document.querySelectorAll('.window[data-app="settings"], [data-settings-window="true"]');
            settingsWindows.forEach(settingsWindow => {
                settingsWindow.dispatchEvent(new CustomEvent('refreshBackgrounds'));
            });
        } else {
            throw new Error('Could not load image from filesystem');
        }
    } catch (error) {
        console.error('Error setting custom background:', error);
        throw error;
    }
}

// Restore Desktop Background
// Synchronous function to apply preset backgrounds immediately (prevents flicker)
function restoreDesktopBackgroundSync() {
    const desktop = document.querySelector('.desktop');
    if (!desktop) return;
    
    const savedBackground = localStorage.getItem('desktopBackground') || 'default';
    
    // Only apply preset backgrounds synchronously - custom backgrounds will be handled async
    if (savedBackground && !savedBackground.startsWith('custom-') && savedBackground !== 'custom') {
    switch(savedBackground) {
        case 'default':
                desktop.style.backgroundImage = 'url("../assets/images/Peak.jpg")';
                desktop.style.background = 'url("../assets/images/Peak.jpg"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)';
            desktop.style.backgroundSize = 'cover';
            desktop.style.backgroundPosition = 'center';
            desktop.style.backgroundRepeat = 'no-repeat';
            desktop.style.animation = 'none';
            break;
        case 'dark-blue':
                desktop.style.backgroundImage = 'url("../assets/images/Mountain.jpg")';
                desktop.style.background = 'url("../assets/images/Mountain.jpg"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)';
                desktop.style.backgroundSize = 'cover';
                desktop.style.backgroundPosition = 'center';
                desktop.style.backgroundRepeat = 'no-repeat';
                desktop.style.animation = 'none';
            break;
        case 'mountain':
                desktop.style.backgroundImage = 'url("../assets/images/Mountain.jpg")';
                desktop.style.background = 'url("../assets/images/Mountain.jpg"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)';
            desktop.style.backgroundSize = 'cover';
            desktop.style.backgroundPosition = 'center';
            desktop.style.backgroundRepeat = 'no-repeat';
            desktop.style.animation = 'none';
            break;
        }
    }
}

async function restoreDesktopBackground() {
    const desktop = document.querySelector('.desktop');
    if (!desktop) return;
    
    const savedBackground = localStorage.getItem('desktopBackground') || 'default';
    
    // Check for custom background first
    if (savedBackground && savedBackground.startsWith('custom-')) {
        const customPath = savedBackground.replace('custom-', '');
        if (customPath) {
            // Check if already loaded (to avoid flicker from reloading)
            const currentBg = desktop.style.backgroundImage;
            if (currentBg && currentBg.includes('blob:')) {
                // Already loaded, don't reload
                return;
            }
            
            const imageUrl = await getImageUrlFromFilesystem(customPath);
            if (imageUrl) {
                desktop.style.backgroundImage = `url("${imageUrl}")`;
                desktop.style.background = `url("${imageUrl}"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)`;
                desktop.style.backgroundSize = 'cover';
                desktop.style.backgroundPosition = 'center';
                desktop.style.backgroundRepeat = 'no-repeat';
                desktop.style.animation = 'none';
                return;
            } else {
                // Fallback to default if custom image can't be loaded
                console.warn('Could not load custom background, falling back to default');
                restoreDesktopBackgroundSync(); // Apply default synchronously
            }
        }
    } else if (savedBackground === 'custom') {
        // Legacy format - try to get from customBackgroundPath
        const customPath = localStorage.getItem('customBackgroundPath');
        if (customPath) {
            // Check if already loaded (to avoid flicker from reloading)
            const currentBg = desktop.style.backgroundImage;
            if (currentBg && currentBg.includes('blob:')) {
                // Already loaded, don't reload
                return;
            }
            
            const imageUrl = await getImageUrlFromFilesystem(customPath);
            if (imageUrl) {
                desktop.style.backgroundImage = `url("${imageUrl}")`;
                desktop.style.background = `url("${imageUrl}"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)`;
                desktop.style.backgroundSize = 'cover';
                desktop.style.backgroundPosition = 'center';
                desktop.style.backgroundRepeat = 'no-repeat';
                desktop.style.animation = 'none';
                return;
            } else {
                // Fallback to default if custom image can't be loaded
                console.warn('Could not load custom background, falling back to default');
                restoreDesktopBackgroundSync(); // Apply default synchronously
            }
        }
    } else {
        // Preset background - already applied synchronously, but ensure it's set
        restoreDesktopBackgroundSync();
    }
}

// Start loading custom background immediately when script loads (before initDesktop)
// Uses global image cache to prevent flickering
(function() {
    const savedBackground = localStorage.getItem('desktopBackground') || 'default';
    if (savedBackground && (savedBackground.startsWith('custom-') || savedBackground === 'custom')) {
        const customPath = savedBackground.startsWith('custom-') ? savedBackground.replace('custom-', '') : localStorage.getItem('customBackgroundPath');
        if (customPath) {
            // Start loading immediately using cached function
            (async function() {
                try {
                    // Wait for getImageUrlFromFilesystem to be available
                    let imageUrl = null;
                    let attempts = 0;
                    while (!imageUrl && attempts < 50) {
                        if (typeof getImageUrlFromFilesystem === 'function') {
                            imageUrl = await getImageUrlFromFilesystem(customPath);
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 50));
                        attempts++;
                    }
                    
                    if (imageUrl) {
                        const desktop = document.querySelector('.desktop');
                        if (desktop) {
                            desktop.style.backgroundImage = `url("${imageUrl}")`;
                            desktop.style.background = `url("${imageUrl}"), linear-gradient(135deg, #2d3a4e 0%, #3a4a5e 50%, #4a5a6e 100%)`;
                            desktop.style.backgroundSize = 'cover';
                            desktop.style.backgroundPosition = 'center';
                            desktop.style.backgroundRepeat = 'no-repeat';
                            desktop.style.animation = 'none';
                        }
                    }
                } catch (e) {
                    console.warn('Error preloading custom background:', e);
                }
            })();
        }
    }
})();

// Desktop Context Menu Functionality
function initDesktopContextMenu() {
    const desktop = document.querySelector('.desktop');
    const contextMenu = document.getElementById('desktop-context-menu');
    const desktopIcons = document.querySelector('.desktop-icons');
    
    if (!desktop || !contextMenu) return;
    
    // Helper function to get user-specific folder path
    function getUserFolderPath(folderName) {
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                return `/Users/${user.name}/${folderName}`;
            } catch (e) {
                console.warn('Could not parse logged-in user:', e);
            }
        }
        return `/${folderName}`;
    }
    
    // Function to update toggle icons menu state
    function updateToggleIconsMenu() {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        const toggleText = document.getElementById('toggle-icons-text');
        const toggleItem = contextMenu.querySelector('[data-action="toggle-icons"]');
        const toggleIcon = toggleItem ? toggleItem.querySelector('.context-menu-icon svg') : null;
        
        if (!desktopIconsContainer || !toggleText || !toggleIcon) return;
        
        // Check saved preference first, then fall back to style
        const savedVisibility = localStorage.getItem('desktopIconsVisible');
        let isVisible;
        if (savedVisibility !== null) {
            isVisible = savedVisibility === 'true';
        } else {
            // Check current display state
            const currentDisplay = desktopIconsContainer.style.display;
            const computedDisplay = window.getComputedStyle(desktopIconsContainer).display;
            isVisible = currentDisplay ? (currentDisplay !== 'none') : (computedDisplay !== 'none');
        }
        
        // Update menu text and icon
        toggleText.textContent = isVisible ? 'Hide Desktop Items' : 'Show Desktop Items';
        
        if (isVisible) {
            // Show icon (regular eye)
            toggleIcon.innerHTML = `
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            `;
        } else {
            // Hide icon (eye with slash)
            toggleIcon.innerHTML = `
                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                <line x1="1" y1="1" x2="23" y2="23"></line>
            `;
        }
    }
    
    // Show context menu on right-click
    desktop.addEventListener('contextmenu', function(e) {
        // Don't show menu if clicking on dock, icons, or windows
        if (e.target.closest('.dock') || 
            e.target.closest('.desktop-icon') || 
            e.target.closest('.window') ||
            e.target.closest('.desktop-icons')) {
            return;
        }
        
        e.preventDefault();
        
        // Update toggle icons menu state before showing
        updateToggleIconsMenu();
        updateLockIconsMenu();
        updateGridMenu();
        
        // Position menu at cursor location
        const x = e.clientX;
        const y = e.clientY;
        
        contextMenu.style.left = x + 'px';
        contextMenu.style.top = y + 'px';
        contextMenu.classList.add('show');
        
        // Ensure menu stays within viewport
        setTimeout(() => {
            const rect = contextMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (rect.right > viewportWidth) {
                contextMenu.style.left = (viewportWidth - rect.width - 10) + 'px';
            }
            if (rect.bottom > viewportHeight) {
                contextMenu.style.top = (viewportHeight - rect.height - 10) + 'px';
            }
        }, 0);
    });
    
    // Hide context menu on left-click outside
    // Use a flag to prevent hiding when clicking inside the menu
    let isClickingInMenu = false;
    contextMenu.addEventListener('mousedown', function(e) {
        isClickingInMenu = true;
    });
    
    contextMenu.addEventListener('mouseup', function(e) {
        // Reset flag after a short delay to allow click handler to process
        setTimeout(() => {
            isClickingInMenu = false;
        }, 100);
    });
    
    document.addEventListener('click', function(e) {
        // Only hide if menu is actually shown
        if (!contextMenu.classList.contains('show')) {
            return;
        }
        
        // Don't hide if clicking on the context menu or its children
        if (contextMenu.contains(e.target) || isClickingInMenu) {
            return;
        }
        
        // Don't hide if clicking on a desktop icon (they have their own context menu)
        if (e.target.closest('.desktop-icon')) {
            return;
        }
        
        // Hide menu for clicks outside
        contextMenu.classList.remove('show');
    }, true); // Use capture phase
    
    // Function to set desktop icon size
    function applyDesktopIconSizeToIcon(icon, size) {
        if (!icon) return;
        const sizes = {
            small: { icon: 32, svg: 32, label: 11, container: 70 },
            medium: { icon: 48, svg: 48, label: 12, container: 80 },
            large: { icon: 64, svg: 64, label: 13, container: 100 }
        };
        const sizeConfig = sizes[size] || sizes.small;

        const iconImage = icon.querySelector('.desktop-icon-image');
        const iconLabel = icon.querySelector('.desktop-icon-label');
        const iconSvg = iconImage ? iconImage.querySelector('svg') : null;

        if (iconImage) {
            iconImage.style.width = sizeConfig.icon + 'px';
            iconImage.style.height = sizeConfig.icon + 'px';
        }

        if (iconSvg) {
            iconSvg.style.width = sizeConfig.svg + 'px';
            iconSvg.style.height = sizeConfig.svg + 'px';
        }

        if (iconLabel) {
            iconLabel.style.fontSize = sizeConfig.label + 'px';
            iconLabel.style.maxWidth = sizeConfig.container + 'px';
        }

        icon.style.width = sizeConfig.container + 'px';
    }

    function setDesktopIconSize(size) {
        const icons = document.querySelectorAll('.desktop-icon');
        icons.forEach(icon => applyDesktopIconSizeToIcon(icon, size));
        
        // Save preference
        localStorage.setItem('desktopIconSize', size);
        
        // Update menu checkmarks
        updateIconSizeMenu();
    }
    
    // Update menu to show current selection
    function updateIconSizeMenu() {
        const currentSize = localStorage.getItem('desktopIconSize') || 'small';
        const menuItems = contextMenu.querySelectorAll('.context-menu-item[data-action^="icon-size-"]');
        
        menuItems.forEach(item => {
            const action = item.dataset.action;
            const check = item.querySelector('.context-menu-check');
            
            if (action === `icon-size-${currentSize}`) {
                if (check) check.style.display = 'inline';
                item.style.background = 'rgba(93, 173, 226, 0.15)';
                item.style.color = '#5dade2';
            } else {
                if (check) check.style.display = 'none';
                item.style.background = '';
                item.style.color = '';
            }
        });
    }
    
    // Function to toggle desktop items visibility
    function toggleDesktopIcons() {
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        
        if (!desktopIconsContainer) return;
        
        // Check current state - use computed style if style.display is not explicitly set
        const currentDisplay = desktopIconsContainer.style.display;
        const computedDisplay = window.getComputedStyle(desktopIconsContainer).display;
        const isVisible = currentDisplay ? (currentDisplay !== 'none') : (computedDisplay !== 'none');
        const newVisibility = !isVisible;
        
        // Toggle visibility
        desktopIconsContainer.style.display = newVisibility ? 'flex' : 'none';
        
        // Save preference first
        localStorage.setItem('desktopIconsVisible', newVisibility ? 'true' : 'false');
        
        // Update menu state after a brief delay to ensure DOM updates
        setTimeout(() => {
            updateToggleIconsMenu();
        }, 0);
    }
    
    // Function to toggle desktop items lock state
    function toggleDesktopIconsLock() {
        // Read current state from localStorage to ensure consistency
        const savedLockState = localStorage.getItem('desktopIconsLocked');
        const currentLocked = savedLockState === 'true';
        const newLocked = !currentLocked;
        
        // Update global variable
        desktopIconsLocked = newLocked;
        
        // Save preference
        localStorage.setItem('desktopIconsLocked', newLocked ? 'true' : 'false');
        
        // Update cursor style for all icons
        const icons = document.querySelectorAll('.desktop-icon');
        icons.forEach(icon => {
            if (newLocked) {
                icon.style.cursor = 'default';
            } else {
                icon.style.cursor = 'move';
            }
        });
        
        // Update menu state after a brief delay to ensure DOM updates
        setTimeout(() => {
            updateLockIconsMenu();
        }, 0);
    }
    
    // Function to update lock icons menu state
    function updateLockIconsMenu() {
        const lockText = document.getElementById('toggle-lock-text');
        const lockItem = contextMenu.querySelector('[data-action="toggle-lock"]');
        const lockIcon = lockItem ? lockItem.querySelector('.context-menu-icon svg') : null;
        
        if (!lockText || !lockIcon) return;
        
        // Read from localStorage to ensure we have the latest state
        const savedLockState = localStorage.getItem('desktopIconsLocked');
        const isLocked = savedLockState === 'true';
        
        // Update global variable to keep in sync
        desktopIconsLocked = isLocked;
        
        // Update menu text and icon
        if (isLocked) {
            lockText.textContent = 'Unlock Desktop Items';
            // Locked icon (closed lock)
            lockIcon.innerHTML = `
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            `;
        } else {
            lockText.textContent = 'Lock Desktop Items';
            // Unlocked icon (open lock)
            lockIcon.innerHTML = `
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 8.66-3.13"></path>
                <path d="M2 2l20 20"></path>
            `;
        }
    }
    
    // Function to toggle desktop grid - ONLY affects desktop icons, never windows
    function toggleDesktopGrid() {
        // Read current state from localStorage to ensure consistency
        const savedGridState = localStorage.getItem('desktopGridEnabled');
        const currentEnabled = savedGridState === 'true';
        const newEnabled = !currentEnabled;
        
        // Update global variable (desktop icons only - windows are not affected)
        desktopGridEnabled = newEnabled;
        
        // Save preference
        localStorage.setItem('desktopGridEnabled', newEnabled ? 'true' : 'false');
        
        // Update menu state after a brief delay to ensure DOM updates
        setTimeout(() => {
            updateGridMenu();
        }, 0);
        
        // Snap all existing desktop icons to grid if enabling (windows are NOT affected)
        if (newEnabled) {
            const icons = document.querySelectorAll('.desktop-icon');
            icons.forEach(icon => {
                const currentLeft = parseInt(icon.style.left) || icon.offsetLeft;
                const currentTop = parseInt(icon.style.top) || icon.offsetTop;
                const snappedLeft = Math.round(currentLeft / GRID_SIZE) * GRID_SIZE;
                const snappedTop = Math.round(currentTop / GRID_SIZE) * GRID_SIZE;
                icon.style.left = snappedLeft + 'px';
                icon.style.top = snappedTop + 'px';
                
                // Save the snapped position
                const iconId = icon.id;
                if (iconId && window.saveIconPosition) {
                    window.saveIconPosition(icon, iconId);
                } else {
                    // Fallback: save directly to localStorage
                    const position = {
                        left: icon.style.left || icon.offsetLeft + 'px',
                        top: icon.style.top || icon.offsetTop + 'px'
                    };
                    localStorage.setItem(`${iconId}Position`, JSON.stringify(position));
                }
            });
        }
    }
    
    // Function to update grid menu state
    function updateGridMenu() {
        const gridText = document.getElementById('toggle-grid-text');
        
        if (!gridText) return;
        
        // Read from localStorage to ensure we have the latest state
        const savedGridState = localStorage.getItem('desktopGridEnabled');
        const isEnabled = savedGridState === 'true';
        
        // Update global variable to keep in sync
        desktopGridEnabled = isEnabled;
        
        // Update menu text
        if (isEnabled) {
            gridText.textContent = 'Grid Mode';
        } else {
            gridText.textContent = 'Freeform Mode';
        }
    }
    
    // Handle menu item clicks using event delegation
    contextMenu.addEventListener('click', function(e) {
        // Find the closest menu item (in case clicking on child elements)
        const menuItem = e.target.closest('.context-menu-item');
        if (!menuItem) return;
        
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        const action = menuItem.dataset.action;
        if (!action) return;
        
        // Handle icon size changes
        if (action && action.startsWith('icon-size-')) {
            const size = action.replace('icon-size-', '');
            try {
                setDesktopIconSize(size);
            } catch (error) {
                console.error('Error setting icon size:', error);
            }
            contextMenu.classList.remove('show');
            return;
        }
        
        // Handle toggle icons
        if (action === 'toggle-icons') {
            try {
                toggleDesktopIcons();
            } catch (error) {
                console.error('Error toggling desktop icons:', error);
            }
            // Hide menu after a brief delay to allow state updates
            setTimeout(() => {
                contextMenu.classList.remove('show');
            }, 50);
            return;
        }
        
        // Handle toggle lock
        if (action === 'toggle-lock') {
            try {
                toggleDesktopIconsLock();
            } catch (error) {
                console.error('Error toggling desktop icons lock:', error);
            }
            // Hide menu after a brief delay to allow state updates
            setTimeout(() => {
                contextMenu.classList.remove('show');
            }, 50);
            return;
        }
        
        // Handle toggle grid
        if (action === 'toggle-grid') {
            try {
                toggleDesktopGrid();
            } catch (error) {
                console.error('Error toggling desktop grid:', error);
            }
            // Hide menu after a brief delay to allow state updates
            setTimeout(() => {
                contextMenu.classList.remove('show');
            }, 50);
            return;
        }
            
            // Handle new file
            if (action === 'new-file') {
                contextMenu.classList.remove('show');
                (async () => {
                    try {
                        const fs = await initFileSystem();
                        const desktopPath = getUserFolderPath('Desktop');
                        
                        // Ensure Desktop folder exists
                        let desktopFolder = await fs.getFolder(desktopPath);
                        if (!desktopFolder) {
                            const pathParts = desktopPath.split('/').filter(p => p);
                            const folderName = pathParts.pop();
                            const parentPath = '/' + pathParts.join('/');
                            await fs.createFolder(parentPath, folderName);
                        }
                        
                        const suggestedName = await getUniqueChildName(fs, desktopPath, 'New File.txt', 'file');
                        const name = await showRenameDialog(suggestedName, 'Create New File', null, { allowUnchanged: true, selectBaseName: true });
                        if (!name) return;
                        
                        // Create the file
                        await fs.createFile(desktopPath, name.trim(), '');
                        
                        // Refresh both Files windows and desktop icons
                        await refreshFileSystemViews(desktopPath);
                    } catch (error) {
                        alert('Error creating file: ' + error.message);
                    }
                })();
                return;
            }
            
            // Handle new folder
            if (action === 'new-folder') {
                contextMenu.classList.remove('show');
                (async () => {
                    try {
                        const fs = await initFileSystem();
                        const desktopPath = getUserFolderPath('Desktop');
                        
                        // Ensure Desktop folder exists
                        let desktopFolder = await fs.getFolder(desktopPath);
                        if (!desktopFolder) {
                            const pathParts = desktopPath.split('/').filter(p => p);
                            const folderName = pathParts.pop();
                            const parentPath = '/' + pathParts.join('/');
                            await fs.createFolder(parentPath, folderName);
                        }
                        
                        const suggestedName = await getUniqueChildName(fs, desktopPath, 'New Folder', 'folder');
                        const name = await showRenameDialog(suggestedName, 'Create New Folder', null, { allowUnchanged: true });
                        if (!name) return;
                        
                        // Create the folder
                        await fs.createFolder(desktopPath, name.trim());
                        
                        // Refresh both Files windows and desktop icons
                        await refreshFileSystemViews(desktopPath);
                    } catch (error) {
                        alert('Error creating folder: ' + error.message);
                    }
                })();
                return;
            }
    });
    
    // Apply saved icon size on load
    setTimeout(() => {
        const savedIconSize = localStorage.getItem('desktopIconSize') || 'small';
        setDesktopIconSize(savedIconSize);
        
        // Apply saved desktop items visibility
        const desktopIconsContainer = document.querySelector('.desktop-icons');
        const iconsVisible = localStorage.getItem('desktopIconsVisible');
        
        if (desktopIconsContainer) {
            // Default to visible if not set
            if (iconsVisible === 'false') {
                desktopIconsContainer.style.display = 'none';
            }
            // Update menu state
            updateToggleIconsMenu();
        }
        
        // Apply saved lock state
        if (desktopIconsLocked) {
            const icons = document.querySelectorAll('.desktop-icon');
            icons.forEach(icon => {
                icon.style.cursor = 'default';
            });
        }
        updateLockIconsMenu();
        
        // Apply saved grid state and update menu
        updateGridMenu();
    }, 100);
    
    // Hide menu on escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && contextMenu.classList.contains('show')) {
            contextMenu.classList.remove('show');
        }
    });
}

// Start Menu Functionality
// Text Editor App
// Save and restore Editor window state
function saveEditorWindowsState() {
    const editorWindows = Array.from(document.querySelectorAll('[data-editor-path]'));
    const windowsState = editorWindows.map(window => {
        const path = window.dataset.editorPath;
        const isMinimized = window.style.display === 'none';
        
        // Get tabs data from window (stored when tabs are created)
        const tabsData = window.editorTabsData || [];
        const activeTabId = window.editorActiveTabId || null;
        
        // If no tabs data, try to get content from textarea (for legacy single-file windows)
        let legacyContent = '';
        if (tabsData.length === 0) {
            const textarea = window.querySelector('#editor-textarea');
            if (textarea) {
                legacyContent = textarea.value || '';
            }
        }
        
        // Save all tabs with their data
        const savedTabs = tabsData.map(tab => ({
            id: tab.id,
            filePath: tab.filePath,
            fileName: tab.fileName,
            displayName: tab.displayName,
            content: tab.content || '',
            savedContent: tab.savedContent || '',
            currentSavePath: tab.currentSavePath || '',
            currentSaveFileName: tab.currentSaveFileName || tab.fileName,
            undoHistory: tab.undoHistory ? tab.undoHistory.map(item => String(item)) : [],
            undoHistoryIndex: tab.undoHistoryIndex !== undefined ? tab.undoHistoryIndex : -1
        }));
        
        // If no tabs but we have content, create a single tab entry
        if (savedTabs.length === 0 && legacyContent) {
            savedTabs.push({
                id: 'tab-1',
                filePath: path,
                fileName: path.split('/').pop() || 'Untitled',
                displayName: path.split('/').pop() || 'Untitled',
                content: legacyContent,
                savedContent: legacyContent,
                currentSavePath: path,
                currentSaveFileName: path.split('/').pop() || 'Untitled',
                undoHistory: [],
                undoHistoryIndex: -1
            });
        }
        
        // Get current position and dimensions
        let left = parseInt(window.style.left) || window.offsetLeft || 200;
        let top = parseInt(window.style.top) || window.offsetTop || 100;
        let width = parseInt(window.style.width) || window.offsetWidth || 900;
        let height = parseInt(window.style.height) || window.offsetHeight || 650;
        
        // Sanitize values before saving - ensure they're valid
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const minLeft = 0;
        
        const maxLeft = viewportWidth - width;
        if (left > maxLeft || left + width > viewportWidth) {
            left = Math.max(minLeft, maxLeft);
        }
        if (left < minLeft) {
            left = minLeft;
        }
        
        // Ensure width isn't too large
        if (width > viewportWidth - minLeft) {
            width = Math.max(600, viewportWidth - minLeft - 20);
        }
        
        return {
            windowId: window.id || null, // Save window ID for restoration
            path: path,
            left: left + 'px',
            top: top + 'px',
            width: width + 'px',
            height: height + 'px',
            minimized: isMinimized,
            tabs: savedTabs,
            activeTabId: activeTabId || (savedTabs.length > 0 ? savedTabs[0].id : null)
        };
    });
    localStorage.setItem('editorWindowsState', JSON.stringify(windowsState));
}

function getEditorWindowsState() {
    const saved = localStorage.getItem('editorWindowsState');
    if (saved) {
        try {
            return JSON.parse(saved);
        } catch (e) {
            return [];
        }
    }
    return [];
}

async function restoreEditorWindows() {
    const windowsState = getEditorWindowsState();
    if (!windowsState || windowsState.length === 0) return;
    
    // Ensure file system is fully initialized before restoring windows
    let fs;
    try {
        fs = await initFileSystem();
        // Verify database is ready by checking if db is not null
        if (!fs || !fs.db) {
            console.warn('File system database not ready, waiting...');
            // Wait a bit and try again
            await new Promise(resolve => setTimeout(resolve, 100));
            fs = await initFileSystem();
            if (!fs || !fs.db) {
                console.error('File system database still not ready, skipping Editor window restoration');
                return;
            }
        }
    } catch (error) {
        console.error('Error initializing file system for Editor restoration:', error);
        return;
    }
    
    for (const state of windowsState) {
        try {
            // Check if we have tabs to restore
            if (state.tabs && Array.isArray(state.tabs) && state.tabs.length > 0) {
                // Restore window with tabs
                // Use the first tab's path as the initial path (or active tab if specified)
                const activeTabId = state.activeTabId || state.tabs[0].id;
                const activeTab = state.tabs.find(t => t.id === activeTabId) || state.tabs[0];
                
                // Always restore the window, even if file doesn't exist (for unsaved/new files)
                // The openEditorWindow function will handle loading the content from savedTabs
                try {
                    await openEditorWindow(
                        activeTab.filePath,
                        activeTab.fileName,
                        state.left,
                        state.top,
                        state.width,
                        state.height,
                        state.minimized,
                        state.tabs, // Pass tabs data
                        activeTabId // Pass active tab ID
                    );
                } catch (error) {
                    console.error('Error restoring editor window with tabs:', error);
                }
            } else {
                // Legacy: restore single file (no tabs)
                // Try to get the file, but restore window even if file doesn't exist
                let file = null;
                try {
                    // Only try to get file if database is ready
                    if (fs && fs.db) {
                        file = await fs.getFile(state.path);
                    }
                } catch (e) {
                    // File might not exist (e.g., temporary file), but we should still restore the window
                }
                
                if (file) {
                    // File exists, open it with saved position
                    const fileName = file.name;
                    await openEditorWindow(state.path, fileName, state.left, state.top, state.width, state.height, state.minimized);
                } else if (isTempEditorFile(state.path)) {
                    // Temporary file - restore window with empty content
                    await openEditorWindow(state.path, 'New Document', state.left, state.top, state.width, state.height, state.minimized);
                } else if (state.path) {
                    // Even if file doesn't exist and it's not a temp file, try to restore the window
                    // This handles cases where files were deleted but windows should still be restored
                    const fileName = state.path.split('/').pop() || 'Untitled';
                    await openEditorWindow(state.path, fileName, state.left, state.top, state.width, state.height, state.minimized);
                }
            }
            // Note: Temporary files (created when opening Editor) are now restored
            // because they exist on disk until the user saves or closes without saving.
        } catch (error) {
            console.error('Error restoring editor window:', error);
        }
    }
}

async function openEditorWindow(path, fileName, left = '200px', top = '100px', width = '900px', height = '650px', minimized = false, savedTabs = null, savedActiveTabId = null) {
    const windowsContainer = document.getElementById('windows-container');
    if (!windowsContainer) return;
    
    // Check if editor already open for this file
    const existingEditor = document.querySelector(`[data-editor-path="${path}"]`);
    if (existingEditor) {
        focusWindow(existingEditor);
        return;
    }
    
    const window = document.createElement('div');
    window.className = 'window';
    // Set window ID to match appBarId so icon removal works correctly
    const windowId = 'editor-' + path;
    window.id = windowId;
    window.setAttribute('id', windowId);
    window.dataset.editorPath = path;
    
    // Sanitize position values before applying them
    const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
    const minLeft = 0;
    
    // Check if this is a new window (using default parameters) or restored window
    // If left/top/width/height are the default values, it's a new window
    const isNewWindow = (left === '200px' || left === 200) && 
                        (top === '100px' || top === 100) && 
                        (width === '900px' || width === 900) && 
                        (height === '650px' || height === 650);
    
    let savedLeft, savedTop;
    if (isNewWindow) {
        // Calculate staggered position for new windows
        const staggeredPos = calculateStaggeredPosition('editor', 200, 100);
        savedLeft = staggeredPos.left;
        savedTop = staggeredPos.top;
    } else {
        savedLeft = parseInt(left) || 200;
        savedTop = parseInt(top) || 100;
    }
    
    let savedWidth = parseInt(width) || 900;
    let savedHeight = parseInt(height) || 650;
    
    // Validate saved width/height aren't too large
    if (savedWidth > viewportWidth - minLeft) {
        savedWidth = Math.max(600, viewportWidth - minLeft - 20);
    }
    if (savedHeight > (document.documentElement.clientHeight || window.innerHeight)) {
        savedHeight = Math.max(400, (document.documentElement.clientHeight || window.innerHeight) - 20);
    }
    
    // Validate saved position - if window would extend beyond viewport, adjust it
    const maxLeft = viewportWidth - savedWidth;
    if (savedLeft > maxLeft || savedLeft + savedWidth > viewportWidth) {
        savedLeft = Math.max(minLeft, maxLeft);
    }
    if (savedLeft < minLeft) {
        savedLeft = minLeft;
    }
    
    window.style.left = savedLeft + 'px';
    window.style.top = savedTop + 'px';
    window.style.width = savedWidth + 'px';
    window.style.height = savedHeight + 'px';
    
    if (minimized) {
        window.style.display = 'none';
    }
    
    // Validate and fix window position to ensure it's fully visible
    setTimeout(() => {
        validateAndFixWindowPosition(window);
    }, 0);
    setTimeout(() => {
        validateAndFixWindowPosition(window);
    }, 200);
    setTimeout(() => {
        validateAndFixWindowPosition(window);
    }, 500);
    
    // Final aggressive check - detect if controls are off-screen and force fix
    setTimeout(() => {
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const windowRight = parseInt(window.style.left) + (window.offsetWidth || parseInt(window.style.width));
        if (windowRight > viewportWidth) {
            const minLeft = 0;
            const windowWidth = window.offsetWidth || parseInt(window.style.width) || 900;
            const maxLeft = viewportWidth - windowWidth;
            window.style.left = Math.max(minLeft, maxLeft) + 'px';
            if (saveEditorWindowsState) {
                saveEditorWindowsState();
            }
        }
    }, 1000);
    
    window.innerHTML = `
        <div class="window-header">
            <div class="window-title">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="4" y1="6" x2="20" y2="6"></line>
                    <line x1="4" y1="12" x2="20" y2="12"></line>
                    <line x1="4" y1="18" x2="20" y2="18"></line>
                </svg>
                Editor
            </div>
            <div class="window-controls">
                <div class="window-control minimize">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </div>
                <div class="window-control maximize">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                    </svg>
                </div>
                <div class="window-control close">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </div>
            </div>
        </div>
        <div class="window-content" style="display: flex; flex-direction: column; padding: 0;">
            <div class="editor-tabs">
                <button class="editor-tab-new" id="editor-new-tab-button" title="New Tab">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <div class="editor-tabs-list" id="editor-tabs-list">
                    <!-- Tabs will be dynamically added here -->
                </div>
            </div>
            <div class="app-toolbar editor-toolbar">
                <button class="nav-button" id="editor-open-btn" title="Open File">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
                <button class="nav-button" id="editor-save-btn" title="Save">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                </button>
                <button class="nav-button" id="editor-save-as-btn" title="Save As">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <path d="M14 2v6h6"></path>
                        <path d="M12 18v-6"></path>
                        <path d="M9 15h6"></path>
                    </svg>
                </button>
                <button class="nav-button" id="editor-undo-btn" title="Undo">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 7v6h6"></path>
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
                    </svg>
                </button>
                <button class="nav-button" id="editor-redo-btn" title="Redo">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 7v6h-6"></path>
                        <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"></path>
                    </svg>
                </button>
            </div>
            <div style="position: relative; flex: 1; display: flex; flex-direction: column;">
            <textarea id="editor-textarea" style="flex: 1; background: rgba(25, 25, 35, 0.85); color: rgba(255,255,255,0.9); border: none; outline: none; padding: 15px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; font-size: 13px; resize: none; white-space: pre-wrap; overflow-wrap: break-word; word-wrap: break-word; word-break: break-word; overflow-x: hidden; overflow-y: auto; width: 100%; min-width: 0; box-sizing: border-box;"></textarea>
                <div id="editor-status-bar" class="editor-status-bar">
                    <span id="editor-lines">0 Lines</span>
                    <span id="editor-chars">0 Characters</span>
                    <span id="editor-size">0 B</span>
                </div>
            </div>
        </div>
        <div class="window-resize-handle n"></div>
        <div class="window-resize-handle s"></div>
        <div class="window-resize-handle e"></div>
        <div class="window-resize-handle w"></div>
        <div class="window-resize-handle ne"></div>
        <div class="window-resize-handle nw"></div>
        <div class="window-resize-handle se"></div>
        <div class="window-resize-handle sw"></div>
    `;
    
    windowsContainer.appendChild(window);
    
    // Function to update status bar (lines, characters, file size)
    // Define this early so it's available for the async file loading
    const updateStatusBar = () => {
        const textarea = window.querySelector('#editor-textarea');
        const linesSpan = window.querySelector('#editor-lines');
        const charsSpan = window.querySelector('#editor-chars');
        const sizeSpan = window.querySelector('#editor-size');
        
        if (!textarea) return;
        
        const content = textarea.value;
        const lines = content.split('\n').length;
        const characters = content.length;
        
        // Calculate file size in bytes (UTF-8 encoding)
        const sizeInBytes = new Blob([content]).size;
        
        // Format size
        let sizeText;
        if (sizeInBytes < 1024) {
            sizeText = sizeInBytes + ' B';
        } else if (sizeInBytes < 1024 * 1024) {
            sizeText = (sizeInBytes / 1024).toFixed(1) + ' KB';
        } else {
            sizeText = (sizeInBytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        if (linesSpan) linesSpan.textContent = `${lines} ${lines === 1 ? 'Line' : 'Lines'},`;
        if (charsSpan) charsSpan.textContent = `${characters} ${characters === 1 ? 'Character' : 'Characters'},`;
        // Format size - use "B" for bytes, keep KB/MB as is
        let sizeDisplay;
        if (sizeInBytes < 1024) {
            sizeDisplay = sizeInBytes + ' B';
        } else {
            sizeDisplay = sizeText; // KB/MB already formatted
        }
        if (sizeSpan) sizeSpan.textContent = sizeDisplay;
    };
    
    // Load file content
    let savedContent = ''; // Content that was last saved to disk
    let currentSavePath = '';
    let currentSaveFileName = fileName;
    
    // Load file content for all tabs (if restoring) or just the initial tab
    (async () => {
        try {
            const fs = await initFileSystem();
            
            // If we're restoring tabs, load content for all of them
            if (savedTabs && Array.isArray(savedTabs) && savedTabs.length > 0) {
                // Load content for all tabs
                for (const tab of tabs) {
                    try {
                        const content = await fs.getFileContent(tab.filePath);
                        const contentText = typeof content === 'string' ? content : await content.text();
                        
                        // Update tab content (use saved content if available, otherwise use loaded content)
                        if (!tab.content || tab.content === '') {
                            tab.content = contentText;
                        }
                        if (!tab.savedContent || tab.savedContent === '') {
                            tab.savedContent = contentText;
                        }
                        tab.currentSavePath = fs.getParentPath(tab.filePath);
                    } catch (error) {
                        console.error('Error loading content for tab:', tab.filePath, error);
                        // If file doesn't exist, keep the saved content
                    }
                }
                
                // Update textarea with active tab's content
                const activeTab = getActiveTab();
                if (activeTab && textarea) {
                    textarea.value = activeTab.content || '';
                    savedContent = activeTab.savedContent || '';
                    currentSavePath = activeTab.currentSavePath || '';
                    currentSaveFileName = activeTab.currentSaveFileName || activeTab.fileName;
                }
            } else {
                // Load content for initial tab only
            const content = await fs.getFileContent(path);
            const contentText = typeof content === 'string' ? content : await content.text();
            savedContent = contentText; // Store the saved content
            const textarea = window.querySelector('#editor-textarea');
            if (textarea) {
                textarea.value = contentText;
            }
            currentSavePath = fs.getParentPath(path);
                
                // Update tab data with loaded content (for the tab that matches this path)
                const matchingTab = tabs.find(t => t.filePath === path);
                if (matchingTab) {
                    matchingTab.content = contentText;
                    matchingTab.savedContent = contentText;
                    matchingTab.currentSavePath = currentSavePath;
                }
                
                // Save window state after loading file content
                saveEditorWindowsState();
            }
            
            // Update Save buttons state after loading file content
            // Note: updateSaveButtonsState will be defined later, so we'll call it after it's defined
            // For now, manually update the buttons
            const saveBtn = window.querySelector('#editor-save-btn');
            const saveAsBtn = window.querySelector('#editor-save-as-btn');
            if (saveBtn && saveAsBtn) {
                const textarea = window.querySelector('#editor-textarea');
                const currentContent = textarea ? textarea.value : '';
                const hasContent = currentContent.trim().length > 0;
                saveBtn.disabled = !hasContent;
                saveAsBtn.disabled = !hasContent;
            }
            
            // Update status bar after loading file
            updateStatusBar();
        } catch (error) {
            alert('Error loading file: ' + error.message);
        }
    })();
    
    let appBarId = 'editor-' + path;
    
    // Get button references early so they're available for all functions
    // These will be used by loadTabState and other functions
    let undoBtn, redoBtn, textarea;
    
    // Function to update undo/redo button states (defined early so loadTabState can use it)
    const updateUndoRedoButtons = () => {
        if (!undoBtn || !redoBtn) return;
        const history = window.editorHistory || [];
        const historyIndex = window.editorHistoryIndex !== undefined ? window.editorHistoryIndex : -1;
        undoBtn.disabled = historyIndex <= 0;
        redoBtn.disabled = historyIndex >= history.length - 1;
    };
    
    // Save state on window move/resize
    const saveStateDebounced = (() => {
        let timeout;
        return () => {
            clearTimeout(timeout);
            timeout = setTimeout(() => saveEditorWindowsState(), 100);
        };
    })();
    
    // Window controls and drag/resize setup - must happen after async operations complete
    // Define this early so it's available for tab restoration
    const setupWindowInteractions = () => {
        // Window controls - set up manually (setupWindowControls is scoped)
        // Clone and re-attach to ensure clean event listeners
        const closeBtn = window.querySelector('.window-control.close');
        const minimizeBtn = window.querySelector('.window-control.minimize');
        const maximizeBtn = window.querySelector('.window-control.maximize');
        let isMaximized = false;
        let previousSize = null;
        
        if (closeBtn) {
            // Remove the button and recreate it to ensure clean state (removes all event listeners)
            const parent = closeBtn.parentNode;
            const newCloseBtn = closeBtn.cloneNode(true);
            parent.replaceChild(newCloseBtn, closeBtn);
            // Attach our handler - this will be the only handler
            newCloseBtn.addEventListener('click', closeEditorWindow);
        }
        
        if (minimizeBtn) {
            // Clone to remove old listeners
            const parent = minimizeBtn.parentNode;
            const newMinimizeBtn = minimizeBtn.cloneNode(true);
            parent.replaceChild(newMinimizeBtn, minimizeBtn);
            
            newMinimizeBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const wasMinimized = window.style.display === 'none';
                if (wasMinimized) {
                    window.style.display = 'flex';
                    focusWindow(window);
                    updateWindowAppBarState(window, true, false);
                } else {
                    window.style.display = 'none';
                    window.classList.remove('window-focused');
                    updateWindowAppBarState(window, false, true);
                }
                saveEditorWindowsState(); // Save state after minimize/restore
            });
        }
        
        if (maximizeBtn) {
            // Clone to remove old listeners
            const parent = maximizeBtn.parentNode;
            const newMaximizeBtn = maximizeBtn.cloneNode(true);
            parent.replaceChild(newMaximizeBtn, maximizeBtn);
            
            newMaximizeBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (isMaximized) {
                    // Restore
                    if (previousSize) {
                        window.style.width = previousSize.width;
                        window.style.height = previousSize.height;
                        window.style.left = previousSize.left;
                        window.style.top = previousSize.top;
                    } else {
                        window.style.width = width;
                        window.style.height = height;
                        window.style.left = left;
                        window.style.top = top;
                    }
                    isMaximized = false;
                } else {
                    // Maximize
                    previousSize = {
                        width: window.style.width || window.offsetWidth + 'px',
                        height: window.style.height || window.offsetHeight + 'px',
                        left: window.style.left || window.offsetLeft + 'px',
                        top: window.style.top || window.offsetTop + 'px'
                    };
                    maximizeWindowToBounds(window);
                    isMaximized = true;
                }
                saveEditorWindowsState(); // Save state after maximize/restore
            });
        }
        
        // Ensure window is in DOM before setting up drag/resize
        makeWindowDraggable(window, { onDragEnd: saveStateDebounced });
        makeWindowResizable(window, { minWidth: 400, minHeight: 300, onResize: saveStateDebounced });
    };
    
    // Tab management
    const tabsList = window.querySelector('#editor-tabs-list');
    let activeTabId = null;
    let tabIdCounter = 1;
    const tabs = []; // Array to store tab data
    
    // Function to get active tab data
    const getActiveTab = () => {
        return tabs.find(t => t.id === activeTabId);
    };
    
    // Function to save current tab state (including content and history)
    const saveCurrentTabState = () => {
        const tab = getActiveTab();
        if (tab && textarea) {
            // Save content
            tab.content = textarea.value;
            
            // Save undo/redo history - create a deep copy to avoid reference issues
            if (window.editorHistory && Array.isArray(window.editorHistory) && window.editorHistory.length > 0) {
                // Create a new array with copies of each string (strings are immutable, but we want a new array)
                tab.undoHistory = window.editorHistory.map(item => String(item));
                tab.undoHistoryIndex = window.editorHistoryIndex !== undefined ? window.editorHistoryIndex : window.editorHistory.length - 1;
                tab.isUndoRedo = false; // Always reset this when saving
            } else if (window.editorHistory && Array.isArray(window.editorHistory)) {
                // Even if empty, save it
                tab.undoHistory = [];
                tab.undoHistoryIndex = -1;
                tab.isUndoRedo = false;
            }
        }
    };
    
    // Function to save current tab's undo/redo history (kept for backward compatibility)
    const saveCurrentTabHistory = () => {
        saveCurrentTabState(); // Now just calls saveCurrentTabState
    };
    
    // Function to load tab state
    const loadTabState = (tab) => {
        if (!tab) return;
        
        // Note: History is already saved by saveCurrentTabState() in setActiveTab() before this is called
        
        // Update textarea content
        if (textarea) {
            textarea.value = tab.content || '';
        }
        
        // Update saved content
        savedContent = tab.savedContent || '';
        
        // Update file info
        currentSavePath = tab.currentSavePath || '';
        currentSaveFileName = tab.currentSaveFileName || tab.fileName;
        
        // Update window data attribute
        window.dataset.editorPath = tab.filePath;
        
        // Load undo/redo history for this tab
        if (tab.undoHistory && Array.isArray(tab.undoHistory) && tab.undoHistory.length > 0) {
            // Create a deep copy of the history array to avoid reference issues
            window.editorHistory = tab.undoHistory.map(item => item);
            window.editorHistoryIndex = tab.undoHistoryIndex !== undefined ? tab.undoHistoryIndex : tab.undoHistory.length - 1;
            window.isUndoRedo = false; // Always reset this flag when loading
        } else {
            // Initialize new history for this tab with current content
            const initialContent = tab.content || textarea.value || '';
            window.editorHistory = [initialContent];
            window.editorHistoryIndex = 0;
            window.isUndoRedo = false;
            
            // Save the initialized history to the tab
            tab.undoHistory = [initialContent];
            tab.undoHistoryIndex = 0;
        }
        
        // Update undo/redo button states
        if (undoBtn && redoBtn) {
            updateUndoRedoButtons();
        }
        
        // Update Save buttons state
        updateSaveButtonsState();
        
        // Update status bar
        updateStatusBar();
    };
    
    // Function to create or update a tab
    const createOrUpdateTab = (tabId, tabLabel, tabData, isActive = false) => {
        let tabElement = tabsList.querySelector(`[data-tab-id="${tabId}"]`);
        
        if (!tabElement) {
            // Create new tab
            tabElement = document.createElement('div');
            tabElement.className = 'editor-tab';
            tabElement.dataset.tabId = tabId;
            if (isActive) {
                tabElement.classList.add('active');
                activeTabId = tabId;
            }
            
            tabElement.innerHTML = `
                <span class="editor-tab-label">${tabLabel}</span>
                <button class="editor-tab-close">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            `;
            
            // Close button handler
            const closeBtn = tabElement.querySelector('.editor-tab-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    // Don't allow closing the last tab
                    if (tabs.length > 1) {
                        // Check for unsaved changes
                        const tab = tabs.find(t => t.id === tabId);
                        if (tab) {
                            const textarea = window.querySelector('#editor-textarea');
                            const currentContent = textarea ? textarea.value : '';
                            const hasUnsaved = currentContent !== (tab.savedContent || '');
                            
                            if (hasUnsaved) {
                                const confirmed = await showConfirmationDialog(
                                    `You have unsaved changes in "${tab.displayName}". Are you sure you want to close this tab?`,
                                    'Unsaved Changes'
                                );
                                if (!confirmed) {
                                    return; // User cancelled
                                }
                            }
                            
                            // Delete temporary file if it exists
                            if (tab.filePath && isTempEditorFile(tab.filePath)) {
                                try {
                                    const fs = await initFileSystem();
                                    await fs.deleteFile(tab.filePath);
                                } catch (error) {
                                    console.error('Error deleting temporary file:', error);
                                }
                            }
                        }
                        
                        // Remove tab from array
                        const tabIndex = tabs.findIndex(t => t.id === tabId);
                        if (tabIndex !== -1) {
                            tabs.splice(tabIndex, 1);
                        }
                        window.editorTabsData = tabs; // Update window reference
                        
                        tabElement.remove();
                        
                        // If we closed the active tab, activate another tab
                        if (activeTabId === tabId) {
                            if (tabs.length > 0) {
                                // Activate the tab that was before this one, or the first one
                                const newActiveTab = tabs[Math.max(0, tabIndex - 1)] || tabs[0];
                                setActiveTab(newActiveTab.id);
                            }
                        }
                        
                        // Save window state after closing tab
                        saveEditorWindowsState();
                    }
                });
            }
            
            // Tab click handler
            tabElement.addEventListener('click', (e) => {
                if (!e.target.closest('.editor-tab-close')) {
                    setActiveTab(tabId);
                }
            });
            
            tabsList.appendChild(tabElement);
        } else {
            // Update existing tab label
            const labelElement = tabElement.querySelector('.editor-tab-label');
            if (labelElement) {
                labelElement.textContent = tabLabel;
            }
            if (isActive) {
                setActiveTab(tabId);
            }
        }
        
        return tabElement;
    };
    
    // Function to set active tab
    const setActiveTab = (tabId) => {
        // Save current tab state before switching
        saveCurrentTabState();
        
        // Switch to new tab
        activeTabId = tabId;
        window.editorActiveTabId = tabId; // Update window reference
        tabsList.querySelectorAll('.editor-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tabId === tabId);
        });
        
        // Load the new tab's state
        const tab = getActiveTab();
        loadTabState(tab);
        
        // Save window state after tab switch
        saveEditorWindowsState();
    };
    
    // Function to update tab label
    const updateTabLabel = (displayName) => {
        const tab = getActiveTab();
        if (tab) {
            tab.displayName = displayName;
            const tabElement = tabsList.querySelector(`[data-tab-id="${tab.id}"]`);
            if (tabElement) {
                const labelElement = tabElement.querySelector('.editor-tab-label');
                if (labelElement) {
                    labelElement.textContent = displayName;
                }
            }
        }
    };
    
    // Function to create a new tab with a new document
    const createNewTab = async () => {
        try {
            const fs = await initFileSystem();
            
            // Use root-level Temp Files path
            const tempFilesPath = '/Temp Files';
            
            // Ensure Temp Files folder exists
            let tempFilesFolder = await fs.getFolder(tempFilesPath);
            if (!tempFilesFolder) {
                const pathParts = tempFilesPath.split('/').filter(p => p);
                const folderName = pathParts.pop();
                const parentPath = '/' + pathParts.join('/');
                await fs.createFolder(parentPath, folderName);
            }
            
            // Create a temporary file
            const tempFileName = generateTempFileName();
            const tempPath = tempFilesPath + '/' + tempFileName;
            
            // Create empty temporary file
            await fs.createFile(tempFilesPath, tempFileName, '');
            
            // Create tab data
            const tabId = `tab-${++tabIdCounter}`;
            const tabData = {
                id: tabId,
                filePath: tempPath,
                fileName: 'New Document.txt',
                displayName: 'New Document',
                content: '',
                savedContent: '',
                currentSavePath: '',
                currentSaveFileName: 'New Document.txt',
                undoHistory: [''],
                undoHistoryIndex: 0,
                isUndoRedo: false
            };
            
            tabs.push(tabData);
            window.editorTabsData = tabs; // Update window reference
            
            // Create tab element
            createOrUpdateTab(tabId, tabData.displayName, tabData, false);
            
            // Set the new tab as active (this will switch to it and load its content)
            setActiveTab(tabId);
            
            // Save window state after creating new tab
            saveEditorWindowsState();
        } catch (error) {
            alert('Error creating new tab: ' + error.message);
        }
    };
    
    // Create initial tab or restore saved tabs
    // Use a flag to track when tab restoration completes
    let tabRestorationComplete = false;
    
    if (savedTabs && Array.isArray(savedTabs) && savedTabs.length > 0) {
        // Restore saved tabs
        (async () => {
            try {
                let maxTabId = 0;
                let fs;
                try {
                    fs = await initFileSystem();
                    // Verify database is ready
                    if (!fs || !fs.db) {
                        console.warn('File system database not ready for tab restoration, waiting...');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        fs = await initFileSystem();
                        if (!fs || !fs.db) {
                            throw new Error('File system database not ready');
                        }
                    }
                } catch (error) {
                    console.error('Error initializing file system for tab restoration:', error);
                    // Continue with tab restoration using saved content only (no file system access)
                    fs = null;
                }
                
                // Ensure Temp Files folder exists (only if fs is available)
                if (fs && fs.db) {
                    try {
                        // Use root-level Temp Files path
                        const tempFilesPath = '/Temp Files';
                        
                        let tempFilesFolder = await fs.getFolder(tempFilesPath);
                        if (!tempFilesFolder) {
                            const pathParts = tempFilesPath.split('/').filter(p => p);
                            const folderName = pathParts.pop();
                            const parentPath = '/' + pathParts.join('/');
                            await fs.createFolder(parentPath, folderName);
                        }
                    } catch (error) {
                        console.error('Error ensuring Temp Files folder exists:', error);
                    }
                }
                
                for (const savedTab of savedTabs) {
                    const tabId = savedTab.id;
                    
                    // If this is a temporary file, ensure it exists (or recreate it with saved content)
                    if (isTempEditorFile(savedTab.filePath) && fs && fs.db) {
                        try {
                            const existingFile = await fs.getFile(savedTab.filePath);
                            if (!existingFile) {
                                // File doesn't exist, recreate it with saved content
                                // Use root-level Temp Files path
                                const tempFilesPath = '/Temp Files';
                                
                                const fileName = savedTab.filePath.split('/').pop();
                                await fs.createFile(tempFilesPath, fileName, savedTab.content || '');
                            }
                        } catch (error) {
                            console.error('Error ensuring temp file exists:', savedTab.filePath, error);
                            // Continue without the file - we have the content saved in tabs
                        }
                    }
                    
                    const tabData = {
                        id: tabId,
                        filePath: savedTab.filePath,
                        fileName: savedTab.fileName,
                        displayName: savedTab.displayName,
                        content: savedTab.content || '',
                        savedContent: savedTab.savedContent || '',
                        currentSavePath: savedTab.currentSavePath || '',
                        currentSaveFileName: savedTab.currentSaveFileName || savedTab.fileName,
                        undoHistory: savedTab.undoHistory ? savedTab.undoHistory.map(item => String(item)) : [],
                        undoHistoryIndex: savedTab.undoHistoryIndex !== undefined ? savedTab.undoHistoryIndex : -1,
                        isUndoRedo: false
                    };
                    tabs.push(tabData);
                    
                    // Extract tab ID number for counter
                    const tabIdNum = parseInt(tabId.replace('tab-', ''));
                    if (!isNaN(tabIdNum) && tabIdNum > maxTabId) {
                        maxTabId = tabIdNum;
                    }
                    
                    // Create tab element (don't set as active yet)
                    createOrUpdateTab(tabId, tabData.displayName, tabData, false);
                }
                
                // Update tab counter
                tabIdCounter = maxTabId + 1;
                
                // Set active tab
                const activeTabIdToUse = savedActiveTabId || savedTabs[0].id;
                activeTabId = activeTabIdToUse;
                window.editorActiveTabId = activeTabId;
                window.editorTabsData = tabs;
                
                // Load the active tab's state
                const activeTab = getActiveTab();
                if (activeTab) {
                    loadTabState(activeTab);
                    // Update tab UI to show active state
                    tabsList.querySelectorAll('.editor-tab').forEach(tab => {
                        tab.classList.toggle('active', tab.dataset.tabId === activeTabId);
                    });
                }
                
                tabRestorationComplete = true;
                
                // Now set up window interactions after tab restoration completes
                setTimeout(() => {
                    setupWindowInteractions();
                }, 50);
            } catch (error) {
                console.error('Error restoring tabs:', error);
                tabRestorationComplete = true;
                // Still set up window interactions even if restoration failed
                setTimeout(() => {
                    setupWindowInteractions();
                }, 50);
            }
        })();
    } else {
        // Create initial tab (new window)
        const initialTabId = 'tab-1';
        const initialTabLabel = isTempEditorFile(path) ? 'New Document' : removeTxtExtension(fileName);
        const initialTabData = {
            id: initialTabId,
            filePath: path,
            fileName: fileName,
            displayName: initialTabLabel,
            content: '',
            savedContent: '',
            currentSavePath: currentSavePath,
            currentSaveFileName: fileName,
            undoHistory: [],
            undoHistoryIndex: -1,
            isUndoRedo: false
        };
        tabs.push(initialTabData);
        window.editorTabsData = tabs; // Update window reference
        window.editorActiveTabId = initialTabId; // Update active tab
        createOrUpdateTab(initialTabId, initialTabLabel, initialTabData, true);
        
        // Ensure active tab is highlighted
        tabsList.querySelectorAll('.editor-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tabId === initialTabId);
        });
    }
    
    // New Tab button handler
    const newTabButton = window.querySelector('#editor-new-tab-button');
    if (newTabButton) {
        newTabButton.addEventListener('click', (e) => {
            e.preventDefault();
            createNewTab();
        });
    }
    
    // Helper function to check if there are unsaved changes
    const hasUnsavedChanges = () => {
        const textarea = window.querySelector('#editor-textarea');
        if (!textarea) return false;
        return textarea.value !== savedContent;
    };
    
    // Helper function to save file
    const saveFile = async (savePath, saveFileName, showDialog = false) => {
        try {
            const fs = await initFileSystem();
            const textarea = window.querySelector('#editor-textarea');
            const content = textarea.value;
            
            // Prevent saving empty files - user must explicitly save via Save/Save As buttons
            // This is a safety check to prevent accidental saves
            if (!content || content.trim() === '') {
                alert('Cannot save an empty file. Please add content before saving.');
                return;
            }
            
            let finalPath = savePath;
            let finalFileName = saveFileName;
            
            // If showDialog is true, show dialog
            if (showDialog) {
                const result = await showSaveDialog(saveFileName, savePath);
                if (!result) return; // User cancelled
                finalPath = result.path;
                finalFileName = result.fileName;
            }
            
            // Ensure filename has .txt extension
            finalFileName = ensureTxtExtension(finalFileName);
            
            // If this was a temporary file, delete it first (temporary files are only kept if saved via Save buttons)
            const currentPath = window.dataset.editorPath;
            if (currentPath && isTempEditorFile(currentPath)) {
                try {
                    await fs.deleteFile(currentPath);
                } catch (error) {
                    console.error('Error deleting temporary file:', error);
                }
            }
            
            // Save file to location (this replaces the temporary file with the actual file)
            await fs.createFile(finalPath, finalFileName, content);
            savedContent = content; // Update saved content after successful save
            
            // Refresh both Files windows and desktop icons
            await refreshFileSystemViews(finalPath);
            
            // Update the window's data-editor-path and title to reflect new location
            const newPath = finalPath === '/' ? `/${finalFileName}` : `${finalPath}/${finalFileName}`;
            window.dataset.editorPath = newPath;
            currentSavePath = finalPath;
            currentSaveFileName = finalFileName;
            
            // Update active tab data
            const tab = getActiveTab();
            if (tab) {
                tab.filePath = newPath;
                tab.fileName = finalFileName;
                tab.displayName = removeTxtExtension(finalFileName);
                tab.savedContent = content;
                tab.content = content;
                tab.currentSavePath = finalPath;
                tab.currentSaveFileName = finalFileName;
            }
            
            // Update tab label instead of title bar
            updateTabLabel(removeTxtExtension(finalFileName));
            
            // Update app bar icon ID
            const oldAppBarId = 'editor-' + path;
            removeWindowFromAppBar(oldAppBarId);
            const newAppBarId = 'editor-' + newPath;
            addWindowToAppBar(window, {
                appId: newAppBarId,
                iconSvg: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg>',
                onIconClick: () => toggleWindowFromDock(window, saveEditorWindowsState)
            });
            
            // Update path for future saves
            path = newPath;
            appBarId = newAppBarId;
            
            saveEditorWindowsState(); // Save state after path change
            
            alert('File saved successfully!');
        } catch (error) {
            alert('Error saving file: ' + error.message);
        }
    };
    
    // Helper function to close window with unsaved changes check
    const closeEditorWindow = async function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const textarea = window.querySelector('#editor-textarea');
        const isEmpty = !textarea || textarea.value.trim() === '';
        
        // If textarea is empty, just close without confirmation
        if (isEmpty) {
            // Delete temporary file if it exists
            const currentPath = window.dataset.editorPath;
            if (currentPath && isTempEditorFile(currentPath)) {
                try {
                    const fs = await initFileSystem();
                    await fs.deleteFile(currentPath);
                } catch (error) {
                    console.error('Error deleting temporary file:', error);
                }
            }
            // Get window ID before removing from DOM (use window.id if available, otherwise use appBarId)
            const windowId = window.id || appBarId;
            window.remove();
            saveEditorWindowsState(); // Save state after closing (only window position, not file content)
            if (windowId) {
                removeWindowFromAppBar(windowId);
            }
            return;
        }
        
        if (hasUnsavedChanges()) {
            const fileDisplayName = currentSaveFileName || fileName;
            const confirmed = await showConfirmationDialog(`You have unsaved changes in "${fileDisplayName}". Are you sure you want to close without saving?`, 'Unsaved Changes');
            if (!confirmed) {
                return; // User cancelled, don't close
            }
        }
        
        // Delete temporary file if it exists (user closed without saving)
        const currentPath = window.dataset.editorPath;
        if (currentPath && isTempEditorFile(currentPath)) {
            try {
                const fs = await initFileSystem();
                await fs.deleteFile(currentPath);
            } catch (error) {
                console.error('Error deleting temporary file:', error);
            }
        }
        
        // Get window ID before removing from DOM (use window.id if available, otherwise use appBarId)
        const windowId = window.id || appBarId;
        window.remove();
        saveEditorWindowsState(); // Save state after closing (only window position, not file content)
        if (windowId) {
            removeWindowFromAppBar(windowId);
        }
    };
    
    // Setup custom tooltips for Open, Save and Save As buttons
    const openBtn = window.querySelector('#editor-open-btn');
    const saveBtn = window.querySelector('#editor-save-btn');
    const saveAsBtn = window.querySelector('#editor-save-as-btn');
    // Initialize button references (already declared earlier as let)
    undoBtn = window.querySelector('#editor-undo-btn');
    redoBtn = window.querySelector('#editor-redo-btn');
    textarea = window.querySelector('#editor-textarea');
    setupNavButtonTooltip(openBtn, 'Open File');
    setupNavButtonTooltip(saveBtn, 'Save');
    setupNavButtonTooltip(saveAsBtn, 'Save As');
    setupNavButtonTooltip(undoBtn, 'Undo');
    setupNavButtonTooltip(redoBtn, 'Redo');
    
    // Helper function to update Save buttons state based on content
    const updateSaveButtonsState = () => {
        const textarea = window.querySelector('#editor-textarea');
        if (!textarea) return;
        const hasContent = textarea.value.trim().length > 0;
        saveBtn.disabled = !hasContent;
        saveAsBtn.disabled = !hasContent;
    };
    
    // Update Save buttons state initially
    updateSaveButtonsState();
    updateStatusBar();
    
    // Update Save buttons state and status bar when textarea content changes
    if (textarea) {
        // Initialize global undo/redo history storage (will be loaded per tab)
        if (!window.editorHistory) {
            window.editorHistory = [];
            window.editorHistoryIndex = -1;
            window.isUndoRedo = false;
        }
        
        // Function to update undo/redo button states
        const updateUndoRedoButtons = () => {
            if (!undoBtn || !redoBtn) return;
            const history = window.editorHistory || [];
            const historyIndex = window.editorHistoryIndex !== undefined ? window.editorHistoryIndex : -1;
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        };
        
        // Undo/Redo functionality with custom history stack
        if (undoBtn && redoBtn) {
            // Function to initialize history with current textarea value
            const initializeHistory = () => {
                const tab = getActiveTab();
                if (tab) {
                    // Use tab content if available, otherwise use textarea value
                    const initialContent = tab.content !== undefined ? tab.content : (textarea ? textarea.value : '');
                    
                    // Only initialize if tab doesn't already have history
                    if (!tab.undoHistory || !Array.isArray(tab.undoHistory) || tab.undoHistory.length === 0) {
                        window.editorHistory = [initialContent];
                        window.editorHistoryIndex = 0;
                        window.isUndoRedo = false;
                        
                        // Save to tab
                        tab.undoHistory = [initialContent];
                        tab.undoHistoryIndex = 0;
                        tab.isUndoRedo = false;
                    } else {
                        // Tab already has history, use it (should have been loaded by loadTabState)
                        window.editorHistory = tab.undoHistory.map(item => item);
                        window.editorHistoryIndex = tab.undoHistoryIndex !== undefined ? tab.undoHistoryIndex : tab.undoHistory.length - 1;
                        window.isUndoRedo = false;
                    }
                    
                    updateUndoRedoButtons();
                }
            };
            
            // Function to add state to history
            const addToHistory = (value) => {
                if (window.isUndoRedo) return; // Don't add during undo/redo operations
                
                // Save to active tab's history
                const tab = getActiveTab();
                if (!tab) return;
                
                let history = window.editorHistory || [];
                let historyIndex = window.editorHistoryIndex !== undefined ? window.editorHistoryIndex : -1;
                
                // Remove any states after current index (when user types after undo)
                history = history.slice(0, historyIndex + 1);
                
                // Add new state
                history.push(value);
                historyIndex++;
                
                // Limit history size to prevent memory issues (keep last 50 states)
                if (history.length > 50) {
                    history.shift();
                    historyIndex--;
                }
                
                // Update global history
                window.editorHistory = history;
                window.editorHistoryIndex = historyIndex;
                
                // Save to tab - create a deep copy
                tab.undoHistory = history.map(item => String(item));
                tab.undoHistoryIndex = historyIndex;
                
                updateUndoRedoButtons();
            };
            
            // Undo function
            const performUndo = () => {
                const history = window.editorHistory || [];
                let historyIndex = window.editorHistoryIndex !== undefined ? window.editorHistoryIndex : -1;
                
                if (historyIndex > 0) {
                    window.isUndoRedo = true;
                    historyIndex--;
                    textarea.value = history[historyIndex];
                    textarea.focus();
                    // Restore cursor position to end
                    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    window.isUndoRedo = false;
                    
                    // Update global and tab history
                    window.editorHistoryIndex = historyIndex;
                    const tab = getActiveTab();
                    if (tab) {
                        tab.undoHistoryIndex = historyIndex;
                        tab.content = textarea.value;
                    }
                    
                    updateUndoRedoButtons();
                    updateStatusBar();
                }
            };
            
            // Redo function
            const performRedo = () => {
                const history = window.editorHistory || [];
                let historyIndex = window.editorHistoryIndex !== undefined ? window.editorHistoryIndex : -1;
                
                if (historyIndex < history.length - 1) {
                    window.isUndoRedo = true;
                    historyIndex++;
                    textarea.value = history[historyIndex];
                    textarea.focus();
                    // Restore cursor position to end
                    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    window.isUndoRedo = false;
                    
                    // Update global and tab history
                    window.editorHistoryIndex = historyIndex;
                    const tab = getActiveTab();
                    if (tab) {
                        tab.undoHistoryIndex = historyIndex;
                        tab.content = textarea.value;
                    }
                    
                    updateUndoRedoButtons();
                    updateStatusBar();
                }
            };
            
            // Undo button click
            undoBtn.addEventListener('click', (e) => {
                e.preventDefault();
                performUndo();
            });
            
            // Redo button click
            redoBtn.addEventListener('click', (e) => {
                e.preventDefault();
                performRedo();
            });
            
            // Track input changes with minimal debouncing for better responsiveness
            let inputTimeout;
            let lastValue = textarea.value;
            let saveStateTimeout;
            textarea.addEventListener('input', () => {
                updateSaveButtonsState();
                updateStatusBar();
                const currentValue = textarea.value;
                
                // Update active tab content
                const tab = getActiveTab();
                if (tab) {
                    tab.content = currentValue;
                }
                
                // Save window state when content changes (debounced)
                clearTimeout(saveStateTimeout);
                saveStateTimeout = setTimeout(() => {
                    saveEditorWindowsState();
                }, 1000); // Save after 1 second of no typing
                
                // Only add to history if value actually changed
                if (currentValue !== lastValue) {
                    clearTimeout(inputTimeout);
                    inputTimeout = setTimeout(() => {
                        addToHistory(currentValue);
                        lastValue = currentValue;
                    }, 50); // Short debounce: wait 50ms after user stops typing
                }
            });
            
            // Handle keyboard shortcuts (Ctrl+Z, Ctrl+Y, Ctrl+Shift+Z)
            textarea.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    performUndo();
                } else if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    performRedo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y')) {
                    e.preventDefault();
                    performRedo();
                }
            });
            
            // Initialize history immediately and also after a short delay to catch async file loads
            initializeHistory();
            setTimeout(() => {
                // Re-initialize in case file content loaded asynchronously
                const currentHistory = window.editorHistory || [];
                if (currentHistory.length > 0 && textarea.value !== currentHistory[0]) {
                    initializeHistory();
                } else if (currentHistory.length === 0) {
                    initializeHistory();
                }
            }, 200);
        } else {
            // Fallback if buttons don't exist
            textarea.addEventListener('input', () => {
                updateSaveButtonsState();
                updateStatusBar();
                
                // Update active tab content
                const tab = getActiveTab();
                if (tab) {
                    tab.content = textarea.value;
                }
            });
        }
    }
    
    // Open button - shows dialog to select a file to open
    openBtn.addEventListener('click', async () => {
        // Check for unsaved changes first
        if (hasUnsavedChanges()) {
            const fileDisplayName = currentSaveFileName || fileName;
            const confirmed = await showConfirmationDialog(`You have unsaved changes in "${fileDisplayName}". Are you sure you want to open a new file without saving?`, 'Unsaved Changes');
            if (!confirmed) {
                return; // User cancelled
            }
        }
        
        // Show open dialog
        const result = await showOpenDialog(currentSavePath || '/Documents');
        if (!result) return; // User cancelled
        
        // Load the selected file into the current editor window
        try {
            const fs = await initFileSystem();
            const content = await fs.getFileContent(result.path);
            const contentText = typeof content === 'string' ? content : await content.text();
            
            // Update editor content
            const textarea = window.querySelector('#editor-textarea');
            if (textarea) {
                textarea.value = contentText;
            }
            
            // Update saved content and file info
            savedContent = contentText;
            currentSavePath = fs.getParentPath(result.path);
            currentSaveFileName = result.fileName;
            
            // Update active tab data
            const tab = getActiveTab();
            if (tab) {
                tab.filePath = result.path;
                tab.fileName = result.fileName;
                tab.displayName = removeTxtExtension(result.fileName);
                tab.content = contentText;
                tab.savedContent = contentText;
                tab.currentSavePath = currentSavePath;
                tab.currentSaveFileName = result.fileName;
            }
            
            // Update Save buttons state and status bar after loading file
            updateSaveButtonsState();
            updateStatusBar();
            
            // Update tab label instead of title bar
            updateTabLabel(removeTxtExtension(result.fileName));
            
            // Update window data attribute and app bar
            window.dataset.editorPath = result.path;
            const oldAppBarId = 'editor-' + path;
            removeWindowFromAppBar(oldAppBarId);
            const newAppBarId = 'editor-' + result.path;
            addWindowToAppBar(window, {
                appId: newAppBarId,
                iconSvg: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg>',
                onIconClick: () => toggleWindowFromDock(window, saveEditorWindowsState)
            });
            
            // Update path for future saves
            path = result.path;
            appBarId = newAppBarId;
            
            saveEditorWindowsState(); // Save state after path change
        } catch (error) {
            alert('Error loading file: ' + error.message);
        }
    });
    
    // Save button - saves directly since file already exists
    if (saveBtn) {
    saveBtn.addEventListener('click', async () => {
        await saveFile(currentSavePath, currentSaveFileName, false);
    });
    }
    
    // Save As button - always shows dialog
    if (saveAsBtn) {
    saveAsBtn.addEventListener('click', async () => {
        await saveFile(currentSavePath, currentSaveFileName, true);
    });
    }
    
    // If restoring tabs, window interactions will be set up after tab restoration completes
    // Otherwise, set up immediately for new windows
    if (!savedTabs || !Array.isArray(savedTabs) || savedTabs.length === 0) {
        // For new windows, wait a bit for DOM to be ready
        setTimeout(setupWindowInteractions, 50);
            }
    // For restored tabs, setupWindowInteractions will be called after tab restoration completes
    
    // Also observe style changes as backup
    const observer = new MutationObserver(saveStateDebounced);
    observer.observe(window, { attributes: true, attributeFilter: ['style'] });
    
    addWindowToAppBar(window, {
        appId: appBarId,
        iconSvg: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg>',
        onIconClick: () => {
            toggleWindowFromDock(window, saveEditorWindowsState);
        }
    });
    
    // Save state after window is set up
    saveEditorWindowsState();
    // Ensure dock icon reflects minimized/restored state on creation/restoration
    updateWindowAppBarState(window, false, window.style.display === 'none');
    
    // Ensure active tab is always highlighted, regardless of window focus
    const ensureActiveTabHighlighted = () => {
        if (activeTabId && tabsList) {
            tabsList.querySelectorAll('.editor-tab').forEach(tab => {
                const isActive = tab.dataset.tabId === activeTabId;
                if (isActive) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
        }
    };
    
    // Ensure active tab is highlighted after a short delay (to account for async operations)
    setTimeout(ensureActiveTabHighlighted, 100);
    
    // Also ensure active tab is highlighted whenever window is clicked
    window.addEventListener('mousedown', ensureActiveTabHighlighted);
    
    if (!minimized) {
        focusWindow(window);
        // Ensure active tab is highlighted after focusing
        setTimeout(ensureActiveTabHighlighted, 50);
    }
}

// Save Dialog for Text Editor
async function showSaveDialog(fileName, currentPath) {
    return new Promise((resolve) => {
        // Get currently logged-in user to determine user-specific folder paths
        let currentUsername = null;
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                currentUsername = user.name;
            } catch (e) {
                console.warn('Could not parse logged-in user:', e);
            }
        }
        
        // Get user-specific paths
        const documentsPath = currentUsername ? `/Users/${currentUsername}/Documents` : '/Documents';
        const desktopPath = currentUsername ? `/Users/${currentUsername}/Desktop` : '/Desktop';
        const downloadsPath = currentUsername ? `/Users/${currentUsername}/Downloads` : '/Downloads';
        
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background: rgba(25, 25, 35, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 20px; min-width: 400px; max-width: 500px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);';
        
        dialog.innerHTML = `
            <div style="margin-bottom: 15px;">
                <h3 style="color: #5dade2; font-size: 16px; font-weight: 600; margin-bottom: 8px;">Save File</h3>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: rgba(255, 255, 255, 0.8); font-size: 13px; margin-bottom: 6px;">File name:</label>
                <input type="text" id="save-dialog-filename" value="${fileName}" style="width: 100%; padding: 8px 12px; background: rgba(40, 40, 50, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 13px; outline: none; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 15px; max-height: 300px; overflow-y: auto;">
                <label style="display: block; color: rgba(255, 255, 255, 0.8); font-size: 13px; margin-bottom: 6px;">Save to:</label>
                <div class="save-dialog-item" data-path="${documentsPath}" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <path d="M14 2v6h6"></path>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Documents</span>
                </div>
                <div class="save-dialog-item" data-path="${desktopPath}" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect>
                        <line x1="8" y1="21" x2="16" y2="21"></line>
                        <line x1="12" y1="17" x2="12" y2="21"></line>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Desktop</span>
                </div>
                <div class="save-dialog-item" data-path="${downloadsPath}" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Downloads</span>
                </div>
                <div class="save-dialog-item" data-path="/" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect>
                        <line x1="8" y1="21" x2="16" y2="21"></line>
                        <line x1="12" y1="17" x2="12" y2="21"></line>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Root Directory</span>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: rgba(255, 255, 255, 0.8); font-size: 13px; margin-bottom: 6px;">Or enter custom path:</label>
                <input type="text" id="save-dialog-custom-path" placeholder="${documentsPath}" style="width: 100%; padding: 8px 12px; background: rgba(40, 40, 50, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; color: rgba(255, 255, 255, 0.9); font-size: 13px; outline: none; box-sizing: border-box;">
            </div>
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button id="save-dialog-cancel" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: rgba(255, 255, 255, 0.9); cursor: pointer; font-size: 13px; transition: background 0.2s;">Cancel</button>
                <button id="save-dialog-save" style="padding: 8px 16px; background: #5dade2; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 13px; font-weight: 600; transition: background 0.2s;">Save</button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        let selectedPath = documentsPath; // Default
        
        // Style dialog items on hover
        const items = dialog.querySelectorAll('.save-dialog-item');
        items.forEach(item => {
            item.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(93, 173, 226, 0.2)';
            });
            item.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
            });
            item.addEventListener('click', function() {
                selectedPath = this.dataset.path;
                const customInput = dialog.querySelector('#save-dialog-custom-path');
                if (customInput) customInput.value = selectedPath;
            });
        });
        
        // File name input
        const fileNameInput = dialog.querySelector('#save-dialog-filename');
        
        // Custom path input
        const customInput = dialog.querySelector('#save-dialog-custom-path');
        if (customInput) {
            customInput.value = documentsPath;
            customInput.addEventListener('input', function() {
                selectedPath = this.value.trim() || documentsPath;
            });
            customInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('save-dialog-save').click();
                }
            });
        }
        
        // Cancel button
        dialog.querySelector('#save-dialog-cancel').addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve(null);
        });
        
        // Save button
        dialog.querySelector('#save-dialog-save').addEventListener('click', async () => {
            const customPath = customInput.value.trim() || selectedPath;
            const newFileName = fileNameInput.value.trim();
            
            if (!newFileName) {
                alert('Please enter a file name');
                return;
            }
            
            // Validate path
            try {
                const fs = await initFileSystem();
                const normalizedPath = customPath === '/' ? '/' : customPath.startsWith('/') ? customPath : '/' + customPath;
                
                // Check if path exists (should be a folder)
                if (normalizedPath !== '/') {
                    const folder = await fs.getFolder(normalizedPath);
                    if (!folder) {
                        alert('Directory does not exist: ' + normalizedPath);
                        return;
                    }
                }
                
                // Check if file already exists
                const filePath = normalizedPath === '/' ? `/${newFileName}` : `${normalizedPath}/${newFileName}`;
                const existingFile = await fs.getFile(filePath);
                if (existingFile) {
                    const confirmed = await showConfirmationDialog(`A file named "${newFileName}" already exists. Do you want to replace it?`, 'File Exists');
                    if (!confirmed) {
                        return;
                    }
                }
                
                document.body.removeChild(overlay);
                resolve({ path: normalizedPath, fileName: newFileName });
            } catch (error) {
                alert('Invalid directory: ' + error.message);
            }
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
                resolve(null);
            }
        });
        
        // Focus file name input and select the name part (without extension)
        setTimeout(() => {
            fileNameInput.focus();
            const nameWithoutExt = fileName.replace(/\.[^/.]+$/, '');
            const ext = fileName.includes('.') ? fileName.substring(fileName.lastIndexOf('.')) : '';
            if (nameWithoutExt) {
                fileNameInput.setSelectionRange(0, nameWithoutExt.length);
            }
        }, 100);
    });
}

// Open Dialog for Text Editor
async function showOpenDialog(currentPath) {
    return new Promise(async (resolve) => {
        // Get currently logged-in user to determine user-specific folder paths
        let currentUsername = null;
        const loggedInUser = localStorage.getItem('loggedInUser');
        if (loggedInUser) {
            try {
                const user = JSON.parse(loggedInUser);
                currentUsername = user.name;
            } catch (e) {
                console.warn('Could not parse logged-in user:', e);
            }
        }
        
        // Get user-specific paths
        const documentsPath = currentUsername ? `/Users/${currentUsername}/Documents` : '/Documents';
        const desktopPath = currentUsername ? `/Users/${currentUsername}/Desktop` : '/Desktop';
        const downloadsPath = currentUsername ? `/Users/${currentUsername}/Downloads` : '/Downloads';
        
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
        
        // Create dialog
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background: rgba(25, 25, 35, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 20px; min-width: 500px; max-width: 600px; max-height: 70vh; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); display: flex; flex-direction: column;';
        
        let selectedPath = currentPath || documentsPath;
        let filesList = [];
        
        // Function to load files from a directory
        const loadFiles = async (path) => {
            try {
                const fs = await initFileSystem();
                const directory = await fs.listDirectory(path);
                filesList = directory.files || [];
                
                const filesContainer = dialog.querySelector('#open-dialog-files');
                filesContainer.innerHTML = '';
                
                if (filesList.length === 0) {
                    filesContainer.innerHTML = '<div style="color: rgba(255, 255, 255, 0.5); padding: 20px; text-align: center;">No files in this directory</div>';
                    return;
                }
                
                filesList.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'open-dialog-file-item';
                    fileItem.dataset.path = file.path;
                    fileItem.dataset.name = file.name;
                    fileItem.style.cssText = 'padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;';
                    fileItem.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <path d="M14 2v6h6"></path>
                        </svg>
                        <span style="color: rgba(255, 255, 255, 0.9);">${file.name}</span>
                    `;
                    
                    fileItem.addEventListener('mouseenter', function() {
                        this.style.background = 'rgba(93, 173, 226, 0.2)';
                    });
                    fileItem.addEventListener('mouseleave', function() {
                        this.style.background = 'transparent';
                    });
                    fileItem.addEventListener('click', function() {
                        // Remove previous selection
                        filesContainer.querySelectorAll('.open-dialog-file-item').forEach(item => {
                            item.style.background = 'transparent';
                        });
                        // Highlight selected
                        this.style.background = 'rgba(93, 173, 226, 0.3)';
                        selectedPath = this.dataset.path;
                    });
                    
                    filesContainer.appendChild(fileItem);
                });
            } catch (error) {
                const filesContainer = dialog.querySelector('#open-dialog-files');
                filesContainer.innerHTML = '<div style="color: rgba(255, 0, 0, 0.7); padding: 20px; text-align: center;">Error loading files: ' + error.message + '</div>';
            }
        };
        
        dialog.innerHTML = `
            <div style="margin-bottom: 15px;">
                <h3 style="color: #5dade2; font-size: 16px; font-weight: 600; margin-bottom: 8px;">Open File</h3>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; color: rgba(255, 255, 255, 0.8); font-size: 13px; margin-bottom: 6px;">Browse in:</label>
                <div class="open-dialog-folder-item" data-path="${documentsPath}" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <path d="M14 2v6h6"></path>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Documents</span>
                </div>
                <div class="open-dialog-folder-item" data-path="${desktopPath}" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect>
                        <line x1="8" y1="21" x2="16" y2="21"></line>
                        <line x1="12" y1="17" x2="12" y2="21"></line>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Desktop</span>
                </div>
                <div class="open-dialog-folder-item" data-path="${downloadsPath}" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Downloads</span>
                </div>
                <div class="open-dialog-folder-item" data-path="/" style="padding: 10px; cursor: pointer; border-radius: 4px; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; transition: background 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="3" width="20" height="18" rx="2" ry="2"></rect>
                        <line x1="8" y1="21" x2="16" y2="21"></line>
                        <line x1="12" y1="17" x2="12" y2="21"></line>
                    </svg>
                    <span style="color: rgba(255, 255, 255, 0.9);">Root Directory</span>
                </div>
            </div>
            <div style="margin-bottom: 15px; flex: 1; min-height: 200px; max-height: 300px; overflow-y: auto;">
                <label style="display: block; color: rgba(255, 255, 255, 0.8); font-size: 13px; margin-bottom: 6px;">Files:</label>
                <div id="open-dialog-files" style="min-height: 150px;">
                    <div style="color: rgba(255, 255, 255, 0.5); padding: 20px; text-align: center;">Loading...</div>
                </div>
            </div>
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button id="open-dialog-cancel" style="padding: 8px 16px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: rgba(255, 255, 255, 0.9); cursor: pointer; font-size: 13px; transition: background 0.2s;">Cancel</button>
                <button id="open-dialog-open" style="padding: 8px 16px; background: #5dade2; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 13px; font-weight: 600; transition: background 0.2s;">Open</button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Style folder items on hover
        const folderItems = dialog.querySelectorAll('.open-dialog-folder-item');
        folderItems.forEach(item => {
            item.addEventListener('mouseenter', function() {
                this.style.background = 'rgba(93, 173, 226, 0.2)';
            });
            item.addEventListener('mouseleave', function() {
                this.style.background = 'transparent';
            });
            item.addEventListener('click', async function() {
                selectedPath = this.dataset.path;
                await loadFiles(selectedPath);
            });
        });
        
        // Load initial files
        await loadFiles(selectedPath);
        
        // Cancel button
        dialog.querySelector('#open-dialog-cancel').addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve(null);
        });
        
        // Open button
        dialog.querySelector('#open-dialog-open').addEventListener('click', () => {
            if (!selectedPath || !filesList.find(f => f.path === selectedPath)) {
                alert('Please select a file');
                return;
            }
            
            const selectedFile = filesList.find(f => f.path === selectedPath);
            document.body.removeChild(overlay);
            resolve({ path: selectedFile.path, fileName: selectedFile.name });
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
                resolve(null);
            }
        });
    });
}

async function openTextEditor() {
    try {
        const fs = await initFileSystem();
        
        // Use root-level Temp Files path
        const tempFilesPath = '/Temp Files';
        
        // Ensure Temp Files folder exists
        let tempFilesFolder = await fs.getFolder(tempFilesPath);
        if (!tempFilesFolder) {
            const pathParts = tempFilesPath.split('/').filter(p => p);
            const folderName = pathParts.pop();
            const parentPath = '/' + pathParts.join('/');
            await fs.createFolder(parentPath, folderName);
        }
        
        // Create a temporary file to allow window restoration after page refresh
        // This temporary file is ONLY created when opening the Editor from the Start Menu
        // The temporary file will be deleted if the user closes without saving
        // The temporary file will be replaced with the actual file when the user saves via Save/Save As buttons
        const tempFileName = generateTempFileName();
        const tempPath = tempFilesPath + '/' + tempFileName;
        
        // Create empty temporary file (allows window to be restored after page refresh)
        try {
            await fs.createFile(tempFilesPath, tempFileName, '');
            // Verify the file was created
            const createdFile = await fs.getFile(tempPath);
            if (!createdFile) {
                console.error('Temporary file was not created successfully:', tempPath);
                throw new Error('Failed to create temporary file');
            }
        } catch (createError) {
            console.error('Error creating temporary file:', createError);
            alert('Error creating temporary file: ' + createError.message);
            // If file creation fails, we can't restore the window after refresh
            // But we'll still open the window so the user can work
        }
        
        // Display name for the window title (without temp prefix)
        const fileName = 'New Document.txt';
        
        // Use the unified openEditorWindow function
        await openEditorWindow(tempPath, fileName);
    } catch (error) {
        alert('Error opening text editor: ' + error.message);
    }
}

// Calculate (advanced calculator app)
let calculateWindowCount = 0;
let calculateInitialized = false;
let globalSaveCalculateWindowsState = null;

function initCalculate() {
    const windowsContainer = document.getElementById('windows-container');
    const dockApps = document.querySelector('.dock-apps');
    
    if (!windowsContainer || !dockApps) {
        setTimeout(() => initCalculate(), 100);
        return;
    }
    
    const CALC_WINDOWS_STATE_KEY = 'calculateWindowsState';
    const CALC_APP_STATE_KEY = 'calculateAppState';
    
    function loadAppState() {
        const defaults = {
            angleMode: 'deg', // 'deg' | 'rad'
            memory: 0,
            ans: 0
        };
        try {
            const raw = localStorage.getItem(CALC_APP_STATE_KEY);
            if (!raw) return defaults;
            const parsed = JSON.parse(raw);
            return {
                angleMode: (parsed.angleMode === 'rad') ? 'rad' : 'deg',
                memory: Number.isFinite(Number(parsed.memory)) ? Number(parsed.memory) : 0,
                ans: Number.isFinite(Number(parsed.ans)) ? Number(parsed.ans) : 0
            };
        } catch (e) {
            return defaults;
        }
    }
    
    function saveAppState(nextState) {
        try {
            localStorage.setItem(CALC_APP_STATE_KEY, JSON.stringify(nextState));
        } catch (e) {
            // ignore storage errors
        }
    }
    
    const appState = loadAppState();
    
    function saveCalculateWindowsState() {
        const calcWindows = Array.from(document.querySelectorAll('[data-calculate-window]'));
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
        const minLeft = 0;
        
        const windowsState = calcWindows.map(win => {
            const isMinimized = win.style.display === 'none';
            
            let left = parseInt(win.style.left) || win.offsetLeft || 200;
            let top = parseInt(win.style.top) || win.offsetTop || 100;
            let width = parseInt(win.style.width) || win.offsetWidth || 420;
            let height = parseInt(win.style.height) || win.offsetHeight || 640;
            
            if (width > viewportWidth - minLeft) width = Math.max(360, viewportWidth - minLeft - 20);
            if (height > viewportHeight) height = Math.max(420, viewportHeight - 20);
            const maxLeft = viewportWidth - width;
            const maxTop = viewportHeight - height;
            if (left < minLeft) left = minLeft;
            if (left > maxLeft) left = Math.max(minLeft, maxLeft);
            if (top < 0) top = 0;
            if (top > maxTop) top = Math.max(0, maxTop);
            
            return {
                windowId: win.id,
                left: left + 'px',
                top: top + 'px',
                width: width + 'px',
                height: height + 'px',
                minimized: isMinimized
            };
        });
        
        try {
            localStorage.setItem(CALC_WINDOWS_STATE_KEY, JSON.stringify(windowsState));
        } catch (e) {}
    }
    
    globalSaveCalculateWindowsState = saveCalculateWindowsState;
    window.saveCalculateWindowsState = saveCalculateWindowsState;
    
    function getSavedCalculateWindowsState() {
        const raw = localStorage.getItem(CALC_WINDOWS_STATE_KEY);
        if (!raw) return [];
        try {
            const parsed = JSON.parse(raw);
            return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
            return [];
        }
    }
    
    function formatNumber(n) {
        if (!Number.isFinite(n)) return String(n);
        const v = Object.is(n, -0) ? 0 : n;
        const abs = Math.abs(v);
        if (abs !== 0 && (abs >= 1e12 || abs < 1e-9)) return v.toExponential(10).replace(/\.?0+e/, 'e');
        const s = v.toPrecision(14);
        return s.replace(/\.?0+$/, '');
    }
    
    function degToRad(x) { return x * (Math.PI / 180); }
    
    function factorialInt(n) {
        if (!Number.isFinite(n)) throw new Error('Invalid factorial');
        if (n < 0) throw new Error('Factorial of negative');
        if (Math.floor(n) !== n) throw new Error('Factorial requires integer');
        if (n > 170) return Infinity;
        let r = 1;
        for (let i = 2; i <= n; i++) r *= i;
        return r;
    }
    
    function normalizeInput(expr) {
        return String(expr || '')
            .replace(//g, '*')
            .replace(//g, '/')
            .replace(/[]/g, '-')
            .replace(//g, 'pi')
            .replace(//g, 'sqrt');
    }
    
    function tokenize(expr) {
        const s = normalizeInput(expr);
        const tokens = [];
        let i = 0;
        const isDigit = c => c >= '0' && c <= '9';
        const isAlpha = c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_';
        
        while (i < s.length) {
            const c = s[i];
            if (c === ' ' || c === '\t' || c === '\n' || c === '\r') { i++; continue; }
            
            if (isDigit(c) || (c === '.' && isDigit(s[i + 1]))) {
                let start = i;
                i++;
                while (i < s.length && (isDigit(s[i]) || s[i] === '.')) i++;
                if (i < s.length && (s[i] === 'e' || s[i] === 'E')) {
                    const ePos = i;
                    i++;
                    if (s[i] === '+' || s[i] === '-') i++;
                    const expStart = i;
                    while (i < s.length && isDigit(s[i])) i++;
                    if (expStart === i) i = ePos;
                }
                const raw = s.slice(start, i);
                const value = Number(raw);
                if (!Number.isFinite(value)) throw new Error('Invalid number');
                tokens.push({ type: 'num', value, raw });
                continue;
            }
            
            if (isAlpha(c)) {
                let start = i;
                i++;
                while (i < s.length && (isAlpha(s[i]) || isDigit(s[i]))) i++;
                const name = s.slice(start, i);
                tokens.push({ type: 'id', name });
                continue;
            }
            
            if ('+-*/^(),!%'.includes(c)) {
                tokens.push({ type: 'sym', sym: c });
                i++;
                continue;
            }
            
            throw new Error(`Unexpected character: ${c}`);
        }
        
        const out = [];
        const canEndValue = t =>
            t && (t.type === 'num' || t.type === 'id' || (t.type === 'sym' && t.sym === ')') || (t.type === 'sym' && (t.sym === '!' || t.sym === '%')));
        const canStartValue = t =>
            t && (t.type === 'num' || t.type === 'id' || (t.type === 'sym' && t.sym === '('));
        
        for (let j = 0; j < tokens.length; j++) {
            const prev = out[out.length - 1];
            const cur = tokens[j];
            if (canEndValue(prev) && canStartValue(cur)) {
                out.push({ type: 'sym', sym: '*' });
            }
            out.push(cur);
        }
        
        return out;
    }
    
    function toRpn(tokens) {
        const output = [];
        const opStack = [];
        const parenStack = [];
        const callStack = [];
        
        const precedence = (op) => {
            switch (op) {
                case '^': return 4;
                case 'neg': return 3;
                case '*':
                case '/': return 2;
                case '+':
                case '-': return 1;
                default: return 0;
            }
        };
        const assoc = (op) => (op === '^' || op === 'neg') ? 'right' : 'left';
        
        for (let i = 0; i < tokens.length; i++) {
            const t = tokens[i];
            
            if (callStack.length > 0 && !callStack[callStack.length - 1].hadArg) {
                if (t.type === 'num' || t.type === 'id' || (t.type === 'sym' && t.sym === '(') || (t.type === 'sym' && t.sym === '-') ) {
                    callStack[callStack.length - 1].hadArg = true;
                }
            }
            
            if (t.type === 'num') {
                output.push(t);
                continue;
            }
            
            if (t.type === 'id') {
                const next = tokens[i + 1];
                const isFunc = next && next.type === 'sym' && next.sym === '(';
                if (isFunc) opStack.push({ type: 'func', name: t.name });
                else output.push(t);
                continue;
            }
            
            if (t.type === 'sym') {
                const sym = t.sym;
                
                if (sym === '(') {
                    const prevInput = tokens[i - 1];
                    const isFuncCall = !!(prevInput && prevInput.type === 'id' && opStack.length > 0 && opStack[opStack.length - 1].type === 'func');
                    opStack.push({ type: 'lparen' });
                    parenStack.push({ isFuncCall });
                    if (isFuncCall) callStack.push({ commas: 0, hadArg: false });
                    continue;
                }
                
                if (sym === ')') {
                    while (opStack.length > 0 && opStack[opStack.length - 1].type !== 'lparen') {
                        output.push(opStack.pop());
                    }
                    if (opStack.length === 0) throw new Error('Mismatched parentheses');
                    opStack.pop();
                    
                    const paren = parenStack.pop();
                    if (paren && paren.isFuncCall) {
                        const call = callStack.pop() || { commas: 0, hadArg: false };
                        const argCount = call.hadArg ? (call.commas + 1) : 0;
                        if (opStack.length === 0 || opStack[opStack.length - 1].type !== 'func') throw new Error('Invalid function call');
                        const fn = opStack.pop();
                        fn.argCount = argCount;
                        output.push(fn);
                    }
                    continue;
                }
                
                if (sym === ',') {
                    while (opStack.length > 0 && opStack[opStack.length - 1].type !== 'lparen') {
                        output.push(opStack.pop());
                    }
                    if (callStack.length === 0) throw new Error('Unexpected comma');
                    callStack[callStack.length - 1].commas++;
                    continue;
                }
                
                if (sym === '!' || sym === '%') {
                    output.push({ type: 'op', op: sym });
                    continue;
                }
                
                if ('+-*/^'.includes(sym)) {
                    const prev = tokens[i - 1];
                    const unary = (sym === '-') && (
                        !prev ||
                        (prev.type === 'sym' && (prev.sym === '(' || prev.sym === ',')) ||
                        (prev.type === 'sym' && '+-*/^'.includes(prev.sym))
                    );
                    const op = unary ? 'neg' : sym;
                    const p = precedence(op);
                    const a = assoc(op);
                    
                    while (opStack.length > 0) {
                        const top = opStack[opStack.length - 1];
                        if (top.type === 'op') {
                            const tp = precedence(top.op);
                            if ((a === 'left' && p <= tp) || (a === 'right' && p < tp)) {
                                output.push(opStack.pop());
                                continue;
                            }
                        }
                        break;
                    }
                    opStack.push({ type: 'op', op });
                    continue;
                }
                
                throw new Error(`Unexpected symbol: ${sym}`);
            }
        }
        
        while (opStack.length > 0) {
            const t = opStack.pop();
            if (t.type === 'lparen') throw new Error('Mismatched parentheses');
            output.push(t);
        }
        
        return output;
    }
    
    function evalRpn(rpn, angleMode, ansValue) {
        const stack = [];
        
        const getConst = (name) => {
            const n = String(name || '').toLowerCase();
            if (n === 'pi') return Math.PI;
            if (n === 'e') return Math.E;
            if (n === 'ans') return Number.isFinite(ansValue) ? ansValue : 0;
            throw new Error(`Unknown identifier: ${name}`);
        };
        
        const fns = {
            sqrt: { min: 1, max: 1, fn: (a) => Math.sqrt(a[0]) },
            abs: { min: 1, max: 1, fn: (a) => Math.abs(a[0]) },
            floor: { min: 1, max: 1, fn: (a) => Math.floor(a[0]) },
            ceil: { min: 1, max: 1, fn: (a) => Math.ceil(a[0]) },
            round: { min: 1, max: 1, fn: (a) => Math.round(a[0]) },
            ln: { min: 1, max: 1, fn: (a) => Math.log(a[0]) },
            log: { min: 1, max: 1, fn: (a) => (Math.log10 ? Math.log10(a[0]) : Math.log(a[0]) / Math.LN10) },
            sin: { min: 1, max: 1, fn: (a) => Math.sin(angleMode === 'deg' ? degToRad(a[0]) : a[0]) },
            cos: { min: 1, max: 1, fn: (a) => Math.cos(angleMode === 'deg' ? degToRad(a[0]) : a[0]) },
            tan: { min: 1, max: 1, fn: (a) => Math.tan(angleMode === 'deg' ? degToRad(a[0]) : a[0]) },
            asin: { min: 1, max: 1, fn: (a) => (angleMode === 'deg' ? (Math.asin(a[0]) * 180 / Math.PI) : Math.asin(a[0])) },
            acos: { min: 1, max: 1, fn: (a) => (angleMode === 'deg' ? (Math.acos(a[0]) * 180 / Math.PI) : Math.acos(a[0])) },
            atan: { min: 1, max: 1, fn: (a) => (angleMode === 'deg' ? (Math.atan(a[0]) * 180 / Math.PI) : Math.atan(a[0])) },
            min: { min: 1, max: Infinity, fn: (a) => Math.min(...a) },
            max: { min: 1, max: Infinity, fn: (a) => Math.max(...a) },
            mod: { min: 2, max: 2, fn: (a) => a[0] % a[1] },
            pow: { min: 2, max: 2, fn: (a) => Math.pow(a[0], a[1]) }
        };
        
        for (const t of rpn) {
            if (t.type === 'num') { stack.push(t.value); continue; }
            if (t.type === 'id') { stack.push(getConst(t.name)); continue; }
            if (t.type === 'op') {
                if (t.op === 'neg') {
                    if (stack.length < 1) throw new Error('Missing operand');
                    stack.push(-stack.pop());
                    continue;
                }
                if (t.op === '!' || t.op === '%') {
                    if (stack.length < 1) throw new Error('Missing operand');
                    const a = stack.pop();
                    stack.push(t.op === '!' ? factorialInt(a) : (a / 100));
                    continue;
                }
                if ('+-*/^'.includes(t.op)) {
                    if (stack.length < 2) throw new Error('Missing operand');
                    const b = stack.pop();
                    const a = stack.pop();
                    switch (t.op) {
                        case '+': stack.push(a + b); break;
                        case '-': stack.push(a - b); break;
                        case '*': stack.push(a * b); break;
                        case '/': stack.push(a / b); break;
                        case '^': stack.push(Math.pow(a, b)); break;
                    }
                    continue;
                }
                throw new Error(`Unknown operator: ${t.op}`);
            }
            if (t.type === 'func') {
                const name = String(t.name || '').toLowerCase();
                const spec = fns[name];
                if (!spec) throw new Error(`Unknown function: ${t.name}`);
                const argc = Number.isFinite(t.argCount) ? t.argCount : 1;
                if (argc < spec.min || argc > spec.max) throw new Error(`Wrong args for ${name}`);
                if (stack.length < argc) throw new Error('Missing function args');
                const args = stack.splice(stack.length - argc, argc);
                stack.push(spec.fn(args));
                continue;
            }
            throw new Error('Invalid expression');
        }
        
        if (stack.length !== 1) throw new Error('Invalid expression');
        return stack[0];
    }
    
    function evaluateExpression(expr) {
        const tokens = tokenize(expr);
        const rpn = toRpn(tokens);
        return evalRpn(rpn, appState.angleMode, appState.ans);
    }
    
    function createCalculateWindow(restoreState = null) {
        const windowId = restoreState ? restoreState.windowId : `calculate-window-${calculateWindowCount++}`;
        const win = document.createElement('div');
        win.className = 'window';
        win.id = windowId;
        win.setAttribute('id', windowId);
        win.setAttribute('data-calculate-window', 'true');
        // Make sizing math predictable for this app: width/height represent the outer box.
        // (Other windows can stay content-box.)
        win.style.boxSizing = 'border-box';
        
        const isMinimized = !!(restoreState && restoreState.minimized);
        win.style.display = isMinimized ? 'none' : 'flex';
        
        if (restoreState) {
            const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
            const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
            const minLeft = 0;
            
            let savedLeft = parseInt(restoreState.left) || 200;
            let savedTop = parseInt(restoreState.top) || 100;
            let savedWidth = parseInt(restoreState.width) || 420;
            let savedHeight = parseInt(restoreState.height) || 640;
            
            if (savedWidth > viewportWidth - minLeft) savedWidth = Math.max(360, viewportWidth - minLeft - 20);
            if (savedHeight > viewportHeight) savedHeight = Math.max(420, viewportHeight - 20);
            
            const maxLeft = viewportWidth - savedWidth;
            const maxTop = viewportHeight - savedHeight;
            if (savedLeft < minLeft) savedLeft = minLeft;
            if (savedLeft > maxLeft) savedLeft = Math.max(minLeft, maxLeft);
            if (savedTop < 0) savedTop = 0;
            if (savedTop > maxTop) savedTop = Math.max(0, maxTop);
            
            win.style.left = savedLeft + 'px';
            win.style.top = savedTop + 'px';
            win.style.width = savedWidth + 'px';
            win.style.height = savedHeight + 'px';
        } else {
            const staggeredPos = calculateStaggeredPosition('calculate', 220, 110);
            win.style.left = staggeredPos.left + 'px';
            win.style.top = staggeredPos.top + 'px';
            // Default size chosen so the entire keypad is visible without scrolling on a typical viewport.
            win.style.width = '440px';
            // Tuned so the window ends close to the bottom of the keypad (no big empty area under "0").
            win.style.height = '640px';
        }
        
        setTimeout(() => validateAndFixWindowPosition(win), 0);
        setTimeout(() => validateAndFixWindowPosition(win), 200);
        
        const angleIcon = (mode) => {
            const m = (mode === 'rad') ? 'rad' : 'deg';
            if (m === 'rad') {
                return `<span class="calculate-tool-letter" aria-hidden="true">R</span>`;
            }
            return `<span class="calculate-tool-letter" aria-hidden="true">D</span>`;
        };

        const clearIcon = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <circle cx="12" cy="12" r="9"></circle>
            <path d="M9 9l6 6"></path>
            <path d="M15 9l-6 6"></path>
        </svg>`;

        win.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="5" y="2" width="14" height="20" rx="2"></rect>
                        <path d="M8 6h8"></path>
                        <path d="M8 10h2"></path><path d="M12 10h2"></path><path d="M8 14h2"></path><path d="M12 14h2"></path><path d="M8 18h2"></path><path d="M12 18h2"></path>
                    </svg>
                    Calculate
                </div>
                <div class="window-controls">
                    <div class="window-control minimize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </div>
                    <div class="window-control maximize">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                    </div>
                    <div class="window-control close">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </div>
                </div>
            </div>
            <div class="window-content calculate-content">
                <div class="calculate-toolbar app-toolbar" role="toolbar" aria-label="Calculator toolbar">
                    <button class="nav-button" type="button" data-action="toggleAngle" aria-label="Toggle angle mode" title="Angle mode">${angleIcon(appState.angleMode)}</button>
                    <div class="calculate-toolbar-spacer"></div>
                </div>
                <div class="calculate-body">
                    <div class="calculate-display">
                        <input class="calculate-expression" type="text" spellcheck="false" autocomplete="off" autocapitalize="off" inputmode="decimal" aria-label="Expression" />
                    </div>
                    <div class="calculate-panels">
                        <div class="calculate-keypad" role="group" aria-label="Calculator buttons">
                            <button class="calc-btn calc-btn-memory" type="button" data-action="mc">MC</button>
                            <button class="calc-btn calc-btn-memory" type="button" data-action="mr">MR</button>
                            <button class="calc-btn calc-btn-memory" type="button" data-action="mplus">M+</button>
                            <button class="calc-btn calc-btn-memory" type="button" data-action="mminus">M-</button>
                            <button class="calc-btn calc-btn-clear calc-btn-icon" type="button" data-action="ac" aria-label="Clear">${clearIcon}</button>
                            <button class="calc-btn calc-btn-clear" type="button" data-action="back"></button>
                            
                            <button class="calc-btn calc-btn-function" type="button" data-insert="sin(">sin</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="cos(">cos</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="tan(">tan</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="log(">log</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="ln(">ln</button>
                            <button class="calc-btn calc-btn-operator" type="button" data-insert="^">x</button>
                            
                            <button class="calc-btn calc-btn-function" type="button" data-insert="asin(">asin</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="acos(">acos</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="atan(">atan</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="sqrt("></button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="pi"></button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="e">e</button>
                            
                            <button class="calc-btn" type="button" data-insert="(">(</button>
                            <button class="calc-btn" type="button" data-insert=")">)</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="abs(">abs</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="mod(">mod</button>
                            <button class="calc-btn calc-btn-operator" type="button" data-insert="%">%</button>
                            <button class="calc-btn calc-btn-operator" type="button" data-insert="/"></button>
                            
                            <button class="calc-btn" type="button" data-insert="7">7</button>
                            <button class="calc-btn" type="button" data-insert="8">8</button>
                            <button class="calc-btn" type="button" data-insert="9">9</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="!">x!</button>
                            <button class="calc-btn calc-btn-operator" type="button" data-insert="*"></button>
                            <button class="calc-btn calc-btn-operator" type="button" data-action="negate"></button>
                            
                            <button class="calc-btn" type="button" data-insert="4">4</button>
                            <button class="calc-btn" type="button" data-insert="5">5</button>
                            <button class="calc-btn" type="button" data-insert="6">6</button>
                            <button class="calc-btn calc-btn-operator" type="button" data-insert="-"></button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert="ans">ans</button>
                            <button class="calc-btn calc-btn-function" type="button" data-insert=",">,</button>
                            
                            <button class="calc-btn" type="button" data-insert="1">1</button>
                            <button class="calc-btn" type="button" data-insert="2">2</button>
                            <button class="calc-btn" type="button" data-insert="3">3</button>
                            <button class="calc-btn calc-btn-operator" type="button" data-insert="+">+</button>
                            <button class="calc-btn" type="button" data-insert=".">.</button>
                            <button class="calc-btn calc-btn-equals" type="button" data-action="equals">=</button>
                            
                            <button class="calc-btn calc-btn-wide" type="button" data-insert="0">0</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="window-resize-handle n"></div>
            <div class="window-resize-handle s"></div>
            <div class="window-resize-handle e"></div>
            <div class="window-resize-handle w"></div>
            <div class="window-resize-handle ne"></div>
            <div class="window-resize-handle nw"></div>
            <div class="window-resize-handle se"></div>
            <div class="window-resize-handle sw"></div>
        `;
        
        windowsContainer.appendChild(win);
        
        addWindowToAppBar(win, {
            iconSvg: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <rect x="5" y="2" width="14" height="20" rx="2"></rect>
                <path d="M8 6h8"></path>
                <path d="M8 10h2"></path><path d="M12 10h2"></path><path d="M8 14h2"></path><path d="M12 14h2"></path><path d="M8 18h2"></path><path d="M12 18h2"></path>
            </svg>`,
            onIconClick: function() {
                toggleWindowFromDock(win, saveCalculateWindowsState);
            }
        });
        updateWindowAppBarState(win, false, isMinimized);
        
        if (!isMinimized) {
            focusWindow(win);
        }
        
        makeWindowDraggable(win, { onDragEnd: saveCalculateWindowsState });
        
        const exprInput = win.querySelector('.calculate-expression');
        const angleBtn = win.querySelector('[data-action="toggleAngle"]');

        function fitHeightToKeypad() {
            // Shrink the window so the distance from the bottom row of buttons to the window border
            // matches the same padding used on the sides (12px via .calculate-panels padding).
            // Keep the bottom spacing consistent with left/right by using the side padding as the target.
            try {
                const panels = win.querySelector('.calculate-panels');
                const keypad = win.querySelector('.calculate-keypad');
                if (!panels || !keypad) return;

                const lastBtn = keypad.querySelector('.calc-btn-wide') || keypad.lastElementChild;
                if (!lastBtn) return;

                const panelsStyle = getComputedStyle(panels);
                // Use side padding as the single source of truth so bottom spacing matches left/right.
                const padSide =
                    parseFloat(panelsStyle.paddingLeft) ||
                    parseFloat(panelsStyle.paddingRight) ||
                    parseFloat(panelsStyle.paddingBottom) ||
                    0;

                const winRect = win.getBoundingClientRect();
                const lastRect = lastBtn.getBoundingClientRect();

                // Desired outer height so that:
                //   windowBottomBorder - lastButtonBottom === padSide
                // +2px buffer prevents clipping due to subpixel rounding.
                const desiredOuterPx = Math.ceil((lastRect.bottom - winRect.top) + padSide + 2);
                const currentOuterPx = Math.ceil(winRect.height);

                // Adjust in either direction to avoid clipping and keep spacing exact.
                if (Math.abs(currentOuterPx - desiredOuterPx) > 1) {
                    win.style.height = Math.max(200, desiredOuterPx) + 'px';
                }
            } catch (e) {}
        }
        
        function insertText(text) {
            if (!exprInput) return;
            const value = exprInput.value || '';
            const start = exprInput.selectionStart ?? value.length;
            const end = exprInput.selectionEnd ?? value.length;
            const next = value.slice(0, start) + text + value.slice(end);
            exprInput.value = next;
            const caret = start + text.length;
            exprInput.setSelectionRange(caret, caret);
            exprInput.focus();
        }
        
        function backspace() {
            if (!exprInput) return;
            const value = exprInput.value || '';
            let start = exprInput.selectionStart ?? value.length;
            let end = exprInput.selectionEnd ?? value.length;
            if (start !== end) {
                const next = value.slice(0, start) + value.slice(end);
                exprInput.value = next;
                exprInput.setSelectionRange(start, start);
                return;
            }
            if (start <= 0) return;
            const next = value.slice(0, start - 1) + value.slice(start);
            exprInput.value = next;
            exprInput.setSelectionRange(start - 1, start - 1);
        }
        
        function clearAll() {
            if (exprInput) exprInput.value = '';
            if (exprInput) exprInput.focus();
        }
        
        function toggleAngle() {
            appState.angleMode = (appState.angleMode === 'deg') ? 'rad' : 'deg';
            if (angleBtn) angleBtn.innerHTML = angleIcon(appState.angleMode);
            saveAppState(appState);
        }
        
        function copyResult() {
            const text = (exprInput && exprInput.value) ? exprInput.value : '';
            if (!text) return;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).catch(() => {});
            } else {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    ta.remove();
                } catch (e) {}
            }
        }
        
        function equals() {
            if (!exprInput) return;
            const expr = exprInput.value.trim();
            if (!expr) return;
            try {
                const v = evaluateExpression(expr);
                const formatted = formatNumber(v);
                appState.ans = v;
                // Put the answer directly into the text field.
                exprInput.value = formatted;
                exprInput.setSelectionRange(formatted.length, formatted.length);
                saveAppState(appState);
            } catch (e) {
                // Keep expression text; no separate result panel exists anymore.
            }
        }
        
        function negateAtCursor() {
            if (!exprInput) return;
            const value = exprInput.value || '';
            const start = exprInput.selectionStart ?? value.length;
            if (start > 0 && value[start - 1] === '-') {
                exprInput.value = value.slice(0, start - 1) + value.slice(start);
                exprInput.setSelectionRange(start - 1, start - 1);
            } else {
                exprInput.value = value.slice(0, start) + '-' + value.slice(start);
                exprInput.setSelectionRange(start + 1, start + 1);
            }
            exprInput.focus();
        }
        
        win.addEventListener('click', (e) => {
            const btn = e.target.closest('button');
            if (!btn) return;
            
            const insert = btn.getAttribute('data-insert');
            if (insert !== null && insert !== undefined) {
                insertText(insert);
                return;
            }
            
            const action = btn.getAttribute('data-action');
            if (!action) return;
            
            switch (action) {
                case 'toggleAngle': toggleAngle(); break;
                case 'copyResult': copyResult(); break;
                case 'ac': clearAll(); break;
                case 'back': backspace(); break;
                case 'equals': equals(); break;
                case 'negate': negateAtCursor(); break;
                case 'mc': appState.memory = 0; saveAppState(appState); break;
                case 'mr': insertText(formatNumber(appState.memory)); break;
                case 'mplus':
                    try {
                        const v = exprInput && exprInput.value.trim() ? evaluateExpression(exprInput.value) : (Number.isFinite(appState.ans) ? appState.ans : 0);
                        appState.memory += v;
                        saveAppState(appState);
                    } catch (err) {}
                    break;
                case 'mminus':
                    try {
                        const v2 = exprInput && exprInput.value.trim() ? evaluateExpression(exprInput.value) : (Number.isFinite(appState.ans) ? appState.ans : 0);
                        appState.memory -= v2;
                        saveAppState(appState);
                    } catch (err2) {}
                    break;
            }
        });
        
        if (exprInput) {
            exprInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); equals(); return; }
                if (e.key === 'Escape') { e.preventDefault(); clearAll(); return; }
                if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C')) copyResult();
            });
        }
        
        const closeBtn = win.querySelector('.window-control.close');
        const minimizeBtn = win.querySelector('.window-control.minimize');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = win.id;
                win.remove();
                saveCalculateWindowsState();
                if (id) removeWindowFromAppBar(id);
            });
        }
        
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const minimized = win.style.display === 'none';
                if (minimized) {
                    win.style.display = 'flex';
                    focusWindow(win);
                    updateWindowAppBarState(win, true, false);
                } else {
                    win.style.display = 'none';
                    win.classList.remove('window-focused');
                    updateWindowAppBarState(win, false, true);
                }
                saveCalculateWindowsState();
            });
        }
        
        win.addEventListener('mousedown', () => {
            if (win.style.display !== 'none') focusWindow(win);
        });
        
        if (exprInput) exprInput.focus();
        setTimeout(() => saveCalculateWindowsState(), 0);
        setTimeout(() => fitHeightToKeypad(), 0);
        setTimeout(() => fitHeightToKeypad(), 120);
        
        return win;
    }
    
    if (!calculateInitialized) {
        calculateInitialized = true;
        const saved = getSavedCalculateWindowsState();
        if (saved && saved.length > 0) {
            saved.forEach(state => createCalculateWindow(state));
        }
    }
    
    return function openCalculate() {
        createCalculateWindow(null);
    };
}

function initStartMenu() {
    const searchIcon = document.getElementById('search-icon');
    const startMenu = document.getElementById('start-menu');
    const startMenuApps = document.getElementById('start-menu-apps');
    const startMenuSearch = document.getElementById('start-menu-search');
    const startMenuSearchResults = document.getElementById('start-menu-search-results');
    const startMenuEmpty = document.getElementById('start-menu-empty');
    
    
    if (!searchIcon || !startMenu || !startMenuApps || !startMenuSearch || !startMenuSearchResults || !startMenuEmpty) {
        console.error('initStartMenu: Missing elements', {
            searchIcon: !!searchIcon,
            startMenu: !!startMenu,
            startMenuApps: !!startMenuApps,
            startMenuSearch: !!startMenuSearch,
            startMenuSearchResults: !!startMenuSearchResults,
            startMenuEmpty: !!startMenuEmpty
        });
        return;
    }
    
    // Applications
    const apps = [
        { name: 'Settings', path: 'M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0 M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z' },
        { name: 'Files', path: 'M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z M14 2v6h6 M16 13H8 M16 17H8 M10 9H8' },
        { name: 'Viewer', path: 'M3 3h18v18H3z M8.5 8.5m-1.5 0a1.5 1.5 0 1 0 3 0a1.5 1.5 0 1 0-3 0 M21 15l-5-5-11 11' },
        { name: 'Paint', path: 'M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z' },
        { name: 'Calculate', path: 'M7 2h10a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2 M8 6h8 M8 10h2 M12 10h2 M8 14h2 M12 14h2 M8 18h2 M12 18h2' },
        { name: 'Player', path: 'M12 2a10 10 0 1 0 0 20a10 10 0 0 0 0-20z M10 8l6 4-6 4V8z' },
        { name: 'Editor', path: 'M4 6h16 M4 12h16 M4 18h16' },
        { name: 'Tasks', path: 'M3 3h18v18H3z M9 3v18 M3 9h18' }
    ];

    const START_MENU_SEARCH_DELAY_MS = 250;
    const START_MENU_MAX_FS_RESULTS = 20;
    let startMenuSearchTimeout = null;
    let startMenuSearchRequest = 0;
    let startMenuSearchPending = false;
    let lastFsResults = { folders: [], files: [] };
    
    function openStartMenuApp(app) {
        if (!app) return;
        startMenu.classList.remove('show');
        if (app.name === 'Files') {
            const openFileExplorer = initFileExplorer();
            if (openFileExplorer) {
                openFileExplorer();
            }
        } else if (app.name === 'Settings') {
            const openSettings = initSettingsWindow();
            if (openSettings) {
                openSettings();
            }
        } else if (app.name === 'Editor') {
            openTextEditor();
        } else if (app.name === 'Viewer') {
            const openViewer = initViewer();
            if (openViewer) {
                openViewer();
            }
        } else if (app.name === 'Paint') {
            const openPaint = initPaint();
            if (openPaint) {
                openPaint();
            }
        } else if (app.name === 'Calculate') {
            const openCalculate = initCalculate();
            if (openCalculate) {
                openCalculate();
            }
        } else if (app.name === 'Player') {
            const openPlayer = initPlayer();
            if (openPlayer) {
                openPlayer();
            }
        } else if (app.name === 'Tasks') {
            const openTaskManager = initTaskManager();
            if (openTaskManager) {
                // Fresh open: center like other apps (do not reuse saved geometry).
                openTaskManager({ restore: false });
            }
        }
    }

    function getVisibleApps(filterText = '') {
        const query = filterText.trim().toLowerCase();
        if (!query) return apps;
        return apps.filter(app => app.name.toLowerCase().includes(query));
    }

    function renderApps(filterText = '') {
        const visibleApps = getVisibleApps(filterText);

        // 6x4 grid (max 24 visible items). Menu size adapts to app count.
        const maxCols = 6;
        const maxRows = 4;
        const count = visibleApps.length;
        const cols = Math.max(1, Math.min(maxCols, count));
        const rows = Math.max(1, Math.min(maxRows, Math.ceil(count / cols) || 1));
        startMenu.style.setProperty('--start-menu-cols', String(cols));
        startMenu.style.setProperty('--start-menu-rows', String(rows));

        startMenuApps.innerHTML = '';
        updateStartMenuEmptyState(count);
        
        visibleApps.forEach(app => {
            const appItem = document.createElement('div');
            appItem.className = 'start-menu-app';
            
            const icon = document.createElement('div');
            icon.className = 'start-menu-app-icon';
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '32');
            svg.setAttribute('height', '32');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('fill', 'none');
            svg.setAttribute('stroke', 'currentColor');
            svg.setAttribute('stroke-width', '2');
            svg.setAttribute('stroke-linecap', 'round');
            svg.setAttribute('stroke-linejoin', 'round');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', app.path);
            svg.appendChild(path);
            icon.appendChild(svg);
            
            const label = document.createElement('div');
            label.className = 'start-menu-app-label';
            label.textContent = app.name;
            
            appItem.appendChild(icon);
            appItem.appendChild(label);
            
            appItem.addEventListener('click', function() {
                openStartMenuApp(app);
            });
            
            startMenuApps.appendChild(appItem);
        });
    }

    function updateStartMenuEmptyState(appCount) {
        const query = startMenuSearch.value.trim();
        const fsCount = lastFsResults.folders.length + lastFsResults.files.length;
        const showEmpty = !!query && appCount === 0 && fsCount === 0 && !startMenuSearchPending;
        startMenuEmpty.style.display = showEmpty ? 'block' : 'none';
    }

    function getParentPath(path) {
        if (!path || typeof path !== 'string') return '/';
        const normalized = path.replace(/\\/g, '/');
        const parts = normalized.split('/').filter(Boolean);
        if (parts.length <= 1) return '/';
        return `/${parts.slice(0, -1).join('/')}`;
    }

    async function searchStartMenuFiles(query) {
        if (!query || !query.trim()) {
            startMenuSearchRequest += 1;
            lastFsResults = { folders: [], files: [] };
            startMenuSearchPending = false;
            startMenuSearchResults.classList.remove('show');
            startMenuSearchResults.innerHTML = '';
            updateStartMenuEmptyState(getVisibleApps(query).length);
            return;
        }

        const requestId = ++startMenuSearchRequest;
        startMenuSearchPending = true;
        updateStartMenuEmptyState(getVisibleApps(query).length);

        const results = { folders: [], files: [], total: 0 };
        try {
            const fs = await initFileSystem();
            await searchStartMenuRecursive(fs, '/', query.trim().toLowerCase(), results);
        } catch (error) {
            console.warn('Start menu search error:', error);
        }

        if (requestId !== startMenuSearchRequest) return;
        lastFsResults = { folders: results.folders, files: results.files };
        startMenuSearchPending = false;
        renderStartMenuSearchResults(query.trim(), lastFsResults);
        updateStartMenuEmptyState(getVisibleApps(query).length);
    }

    async function searchStartMenuRecursive(fs, searchPath, query, results) {
        if (results.total >= START_MENU_MAX_FS_RESULTS) return;
        try {
            const directory = await fs.listDirectory(searchPath);

            for (const folder of directory.folders) {
                if (results.total >= START_MENU_MAX_FS_RESULTS) return;
                if (folder.name.toLowerCase().includes(query)) {
                    results.folders.push(folder);
                    results.total += 1;
                }
                await searchStartMenuRecursive(fs, folder.path, query, results);
                if (results.total >= START_MENU_MAX_FS_RESULTS) return;
            }

            for (const file of directory.files) {
                if (results.total >= START_MENU_MAX_FS_RESULTS) return;
                if (file.name.toLowerCase().includes(query)) {
                    results.files.push(file);
                    results.total += 1;
                }
            }
        } catch (error) {
            console.warn('Start menu search directory error:', searchPath, error);
        }
    }

    function renderStartMenuSearchResults(query, results) {
        const total = results.folders.length + results.files.length;
        if (!query || total === 0) {
            startMenuSearchResults.classList.remove('show');
            startMenuSearchResults.innerHTML = '';
            return;
        }

        startMenuSearchResults.innerHTML = '';

        if (results.folders.length) {
            const heading = document.createElement('div');
            heading.className = 'start-menu-search-heading';
            heading.textContent = 'Folders';
            startMenuSearchResults.appendChild(heading);

            results.folders.forEach(folder => {
                startMenuSearchResults.appendChild(createStartMenuSearchItem({
                    type: 'folder',
                    name: folder.name,
                    path: folder.path
                }));
            });
        }

        if (results.files.length) {
            const heading = document.createElement('div');
            heading.className = 'start-menu-search-heading';
            heading.textContent = 'Files';
            startMenuSearchResults.appendChild(heading);

            results.files.forEach(file => {
                startMenuSearchResults.appendChild(createStartMenuSearchItem({
                    type: 'file',
                    name: file.name,
                    path: file.path
                }));
            });
        }

        startMenuSearchResults.classList.add('show');
    }

    function createStartMenuSearchItem({ type, name, path }) {
        const item = document.createElement('div');
        item.className = 'start-menu-search-item';
        const iconSvg = type === 'folder'
            ? '<svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>'
            : '<svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2v6h6"></path></svg>';
        item.innerHTML = `
            <div class="start-menu-search-icon">${iconSvg}</div>
            <div class="start-menu-search-meta">
                <div class="start-menu-search-name">${name}</div>
                <div class="start-menu-search-path">${path}</div>
            </div>
        `;
        item.addEventListener('click', () => {
            startMenu.classList.remove('show');
            const openFileExplorer = initFileExplorer();
            if (openFileExplorer) {
                const targetPath = type === 'folder' ? path : getParentPath(path);
                openFileExplorer(targetPath || '/');
            }
        });
        return item;
    }
    
    // Initialize apps
    renderApps();
    
    // App shortcuts are no longer created - Applications folder has been removed from root directory
    // This function is intentionally disabled to prevent creation of Applications folder and shortcuts
    async function createAppShortcuts() {
        // Function permanently disabled - Applications folder removed from root directory
        // No shortcuts will be created for apps
        return;
    }
    
    // Note: createAppShortcuts() calls are kept for backward compatibility but the function does nothing
    // This prevents errors if any code still tries to call it
    createAppShortcuts();
    
    // Export function globally (disabled) - prevents errors if external code tries to call it
    window.createAppShortcuts = createAppShortcuts;
    
    // These calls are kept but do nothing since the function is disabled
    setTimeout(() => {
        createAppShortcuts();
    }, 500);
    
    // Re-create shortcuts whenever renderApps is called (function is disabled, so nothing happens)
    const originalRenderApps = renderApps;
    renderApps = function(...args) {
        originalRenderApps(...args);
        // Function call kept for compatibility but createAppShortcuts() does nothing
        createAppShortcuts();
    };
    
    // Function to position start menu at top of search icon panel
    function positionStartMenu() {
        const dockSearch = document.querySelector('.dock-search');
        if (!dockSearch) {
            console.error('positionStartMenu: dock-search not found');
            return;
        }
        
        const dockSearchRect = dockSearch.getBoundingClientRect();
        const menuWidth = startMenu.offsetWidth || 520;
        const menuLeft = clampDockMenuLeft(
            dockSearchRect.left + (dockSearchRect.width / 2) - (menuWidth / 2),
            menuWidth
        );
        const dockRect = _getDockEl().getBoundingClientRect();
        const menuBottom = Math.max(0, window.innerHeight - dockRect.top + DOCK_MENU_GAP_PX);
        startMenu.style.left = menuLeft + 'px';
        startMenu.style.bottom = menuBottom + 'px';
        startMenu.style.top = 'auto';
        startMenu.style.right = 'auto';
    }
    
    // Toggle menu on search icon click
    // Check if listener already attached
    if (!searchIcon.hasAttribute('data-listener-attached')) {
        searchIcon.setAttribute('data-listener-attached', 'true');
        
        searchIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            e.preventDefault();
            const wasOpen = startMenu.classList.contains('show');
            closeAllMenus();
            if (!wasOpen) {
                startMenu.classList.add('show');
                startMenuSearch.value = '';
                startMenuSearchRequest += 1;
                startMenuSearchResults.classList.remove('show');
                startMenuSearchResults.innerHTML = '';
                lastFsResults = { folders: [], files: [] };
                startMenuSearchPending = false;
                renderApps();
                // Use setTimeout to ensure menu is rendered before positioning
                setTimeout(positionStartMenu, 0);
                setTimeout(() => startMenuSearch.focus(), 0);
            }
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', function(e) {
            if (startMenu.classList.contains('show')) {
                const clickedSearch = searchIcon.contains(e.target) || searchIcon === e.target;
                const clickedMenu = startMenu.contains(e.target);
                if (!clickedSearch && !clickedMenu) {
                    startMenu.classList.remove('show');
                }
            }
        });
        
        // Reposition menu on window resize if it's visible
        window.addEventListener('resize', function() {
            if (startMenu.classList.contains('show')) {
                positionStartMenu();
            }
        });
        
        // Toggle menu on Ctrl + Windows key press
        document.addEventListener('keydown', function(e) {
            // Check for Ctrl + Windows key (Meta key) combination
            // This prevents Windows 11 Start Menu from opening
            if ((e.key === 'Meta' || e.code === 'MetaLeft' || e.code === 'MetaRight') && e.ctrlKey) {
                e.preventDefault(); // Prevent default browser behavior
                e.stopPropagation(); // Stop event from bubbling
                const wasOpen = startMenu.classList.contains('show');
                closeAllMenus();
                if (!wasOpen) {
                    startMenu.classList.add('show');
                    startMenuSearch.value = '';
                    startMenuSearchRequest += 1;
                    startMenuSearchResults.classList.remove('show');
                    startMenuSearchResults.innerHTML = '';
                    lastFsResults = { folders: [], files: [] };
                    startMenuSearchPending = false;
                    renderApps();
                    // Use setTimeout to ensure menu is rendered before positioning
                    setTimeout(positionStartMenu, 0);
                    setTimeout(() => startMenuSearch.focus(), 0);
                }
            }
        });
    } else {
    }

    startMenuSearch.addEventListener('input', function() {
        const query = startMenuSearch.value;
        renderApps(query);
        clearTimeout(startMenuSearchTimeout);
        if (query.trim()) {
            startMenuSearchPending = true;
            startMenuSearchResults.classList.remove('show');
            startMenuSearchResults.innerHTML = '';
            updateStartMenuEmptyState(getVisibleApps(query).length);
        }
        startMenuSearchTimeout = setTimeout(() => {
            searchStartMenuFiles(query);
        }, START_MENU_SEARCH_DELAY_MS);
    });

    startMenuSearch.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            e.preventDefault();
            startMenuSearch.value = '';
            renderApps();
            clearTimeout(startMenuSearchTimeout);
            startMenuSearchRequest += 1;
            startMenuSearchResults.classList.remove('show');
            startMenuSearchResults.innerHTML = '';
            lastFsResults = { folders: [], files: [] };
            startMenuSearchPending = false;
            updateStartMenuEmptyState(getVisibleApps('').length);
            return;
        }
        if (e.key === 'Enter') {
            e.preventDefault();
            const visibleApps = getVisibleApps(startMenuSearch.value);
            openStartMenuApp(visibleApps[0]);
        }
    });
}

// Weather Functionality

function initWeather() {
    // Prevent multiple initializations
    if (window.weatherInitialized) {
        return;
    }
    window.weatherInitialized = true;
    
    const weatherIcon = document.getElementById('weather-icon');
    const weatherTemp = document.getElementById('weather-temp');
    const isElectron = navigator.userAgent.toLowerCase().includes('electron');
    
    if (!weatherIcon || !weatherTemp) return;
    
    // OpenWeatherMap API Key - Get a free API key from https://openweathermap.org/api
    // Leave as empty string to use free alternative (wttr.in)
    const API_KEY = ''; // Replace with your OpenWeatherMap API key for better reliability
    
    // Load cached weather data immediately on initialization
    function loadCachedWeather() {
        const cachedWeather = localStorage.getItem('weatherData');
        if (cachedWeather) {
            try {
                const weatherData = JSON.parse(cachedWeather);
                // Validate that temp exists and is a valid number
                if (weatherData && weatherData.temp !== undefined && weatherData.temp !== null && weatherData.temp !== '') {
                    const temp = Number(weatherData.temp);
                    if (!isNaN(temp)) {
                const unit = weatherData.unit || localStorage.getItem('weatherUnit') || 'F';
                        weatherTemp.textContent = `${temp} ${unit}`;
                        if (weatherData.conditionCode !== undefined) {
                weatherIcon.innerHTML = getWeatherIcon(weatherData.conditionCode);
                        }
                return true;
                    }
                }
            } catch (e) {
                console.error('Error loading cached weather:', e);
                // Clear invalid cached data
                localStorage.removeItem('weatherData');
            }
        }
        return false;
    }
    
    // Save weather data to cache
    function saveWeatherData(temp, conditionCode, unit = 'F') {
        const weatherData = {
            temp: temp,
            conditionCode: conditionCode,
            unit: unit,
            timestamp: Date.now()
        };
        localStorage.setItem('weatherData', JSON.stringify(weatherData));
    }
    
    // Debug: Check if elements are found
    if (!weatherIcon || !weatherTemp) {
        console.error('Weather elements not found:', { weatherIcon: !!weatherIcon, weatherTemp: !!weatherTemp });
        return;
    }
    
    // Load cached weather immediately - this ensures we never show empty weather
    const hasCachedWeather = loadCachedWeather();
    
    
    // Weather icon mapping based on OpenWeatherMap condition codes
    function getWeatherIcon(conditionCode) {
        // Clear sky
        if (conditionCode === 800) {
            return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="4"></circle>
                <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"></path>
            </svg>`;
        }
        // Clouds
        if (conditionCode >= 801 && conditionCode <= 804) {
            return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>
            </svg>`;
        }
        // Rain
        if (conditionCode >= 500 && conditionCode <= 531) {
            return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>
                <line x1="16" y1="13" x2="16" y2="21"></line>
                <line x1="8" y1="13" x2="8" y2="21"></line>
                <line x1="12" y1="15" x2="12" y2="23"></line>
            </svg>`;
        }
        // Thunderstorm
        if (conditionCode >= 200 && conditionCode <= 232) {
            return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
            </svg>`;
        }
        // Snow
        if (conditionCode >= 600 && conditionCode <= 622) {
            return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"></path>
                <circle cx="12" cy="12" r="2"></circle>
            </svg>`;
        }
        // Mist/Fog
        if (conditionCode >= 701 && conditionCode <= 781) {
            return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M5 12h14M12 5h7M12 19h7"></path>
            </svg>`;
        }
        // Default (sun)
        return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="4"></circle>
            <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"></path>
        </svg>`;
    }

    async function fetchJsonWithFallback(urls, options) {
        let lastError = null;
        for (const url of urls) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`Request failed (${response.status})`);
                }
                return await response.json();
            } catch (error) {
                lastError = error;
            }
        }
        throw lastError || new Error('All requests failed');
    }

    function setWeatherLocationName(city, region) {
        if (!city && !region) return;
        const trimmedCity = city ? String(city).trim() : '';
        const trimmedRegion = region ? String(region).trim() : '';
        const normalizeRegion = (value) => {
            if (!value) return '';
            const regionPart = String(value).split(',')[0].trim();
            if (!regionPart) return '';
            if (regionPart.length === 2) {
                return regionPart.toUpperCase();
            }
            const stateAbbreviations = {
                'alabama': 'AL',
                'alaska': 'AK',
                'arizona': 'AZ',
                'arkansas': 'AR',
                'california': 'CA',
                'colorado': 'CO',
                'connecticut': 'CT',
                'delaware': 'DE',
                'florida': 'FL',
                'georgia': 'GA',
                'hawaii': 'HI',
                'idaho': 'ID',
                'illinois': 'IL',
                'indiana': 'IN',
                'iowa': 'IA',
                'kansas': 'KS',
                'kentucky': 'KY',
                'louisiana': 'LA',
                'maine': 'ME',
                'maryland': 'MD',
                'massachusetts': 'MA',
                'michigan': 'MI',
                'minnesota': 'MN',
                'mississippi': 'MS',
                'missouri': 'MO',
                'montana': 'MT',
                'nebraska': 'NE',
                'nevada': 'NV',
                'new hampshire': 'NH',
                'new jersey': 'NJ',
                'new mexico': 'NM',
                'new york': 'NY',
                'north carolina': 'NC',
                'north dakota': 'ND',
                'ohio': 'OH',
                'oklahoma': 'OK',
                'oregon': 'OR',
                'pennsylvania': 'PA',
                'rhode island': 'RI',
                'south carolina': 'SC',
                'south dakota': 'SD',
                'tennessee': 'TN',
                'texas': 'TX',
                'utah': 'UT',
                'vermont': 'VT',
                'virginia': 'VA',
                'washington': 'WA',
                'west virginia': 'WV',
                'wisconsin': 'WI',
                'wyoming': 'WY',
                'district of columbia': 'DC'
            };
            const normalizedKey = regionPart.toLowerCase();
            return stateAbbreviations[normalizedKey] || regionPart;
        };
        const normalizedRegion = normalizeRegion(trimmedRegion);
        let locationName = '';
        if (trimmedCity && normalizedRegion) {
            locationName = `${trimmedCity}, ${normalizedRegion}`;
        } else {
            locationName = trimmedCity || normalizedRegion || '';
        }
        if (locationName) {
            localStorage.setItem('weatherLocationName', locationName);
        }
    }

    async function updateLocationNameFromCoords(lat, lon) {
        try {
            const data = await fetchJsonWithFallback([
                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`,
                `http://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`
            ]);
            const address = data.address || {};
            const city = address.city || address.town || address.village || address.hamlet || address.county || address.state_district;
            const region = address.state || address.region || address.county || address.state_district;
            setWeatherLocationName(city, region);
        } catch (error) {
            // Fall back to IP-based location if reverse geocoding fails.
            await getIPLocation();
        }
    }
    
    function updateWeather(lat, lon) {
        // Use OpenWeatherMap if API key is provided, otherwise use free alternative
        if (API_KEY && API_KEY !== '') {
            const urls = [
                `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=imperial`,
                `http://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=imperial`
            ];
            
            fetchJsonWithFallback(urls)
                .then(data => {
                    const temp = Math.round(data.main.temp);
                    const conditionCode = data.weather[0].id;
                    const region = data.sys?.state || data.sys?.region || data.sys?.country || '';
                    setWeatherLocationName(data.name, region);
                    
                    // Determine unit based on location
                    determineTemperatureUnit(lat, lon).then(unit => {
                        // Only update if we successfully got new data
                        weatherTemp.textContent = `${temp} ${unit}`;
                        weatherIcon.innerHTML = getWeatherIcon(conditionCode);
                        
                        // Save to cache for next load
                        saveWeatherData(temp, conditionCode, unit);
                    });
                })
                .catch(error => {
                    console.error('Error fetching weather:', error);
                    // Fallback to free API, but don't clear existing data
                    updateWeatherFree(lat, lon);
                });
        } else {
            // Use free weather API (wttr.in)
            updateWeatherFree(lat, lon);
        }
    }
    
    // Determine temperature unit based on country
    let useFahrenheit = true; // Default to Fahrenheit
    let temperatureUnit = 'F';
    
    async function determineTemperatureUnit(lat, lon) {
        const savedUnit = localStorage.getItem('weatherUnit');
        if (savedUnit) {
            temperatureUnit = savedUnit;
            useFahrenheit = savedUnit === 'F';
            return temperatureUnit;
        }

        const locale = (navigator.languages && navigator.languages[0]) || navigator.language || '';
        if (locale) {
            const normalizedLocale = locale.toUpperCase();
            const fahrenheitLocales = ['EN-US', 'EN-BS', 'EN-BZ', 'EN-KY', 'EN-PW'];
            if (fahrenheitLocales.includes(normalizedLocale)) {
                useFahrenheit = true;
                temperatureUnit = 'F';
                localStorage.setItem('weatherUnit', temperatureUnit);
                return temperatureUnit;
            }
        }

        try {
            const data = await fetchJsonWithFallback([
                'https://ipapi.co/json/',
                'http://ip-api.com/json/'
            ]);
            const country = (data.country_code || data.countryCode || '').toUpperCase();
            const fahrenheitCountries = ['US', 'BS', 'BZ', 'KY', 'PW'];
            useFahrenheit = fahrenheitCountries.includes(country);
            temperatureUnit = useFahrenheit ? 'F' : 'C';
            localStorage.setItem('weatherUnit', temperatureUnit);
            return temperatureUnit;
        } catch (e) {
            console.error('Error determining temperature unit:', e);
        }

        // Default to Fahrenheit if nothing else works
        useFahrenheit = true;
        temperatureUnit = 'F';
        return temperatureUnit;
    }

    async function getIPLocation() {
        try {
            const data = await fetchJsonWithFallback([
                'https://ipapi.co/json/',
                'http://ip-api.com/json/'
            ]);
            const lat = Number(data.latitude ?? data.lat);
            const lon = Number(data.longitude ?? data.lon);
            const city = data.city;
            const region = data.region || data.region_code || data.regionName;
            setWeatherLocationName(city, region);
            if (!Number.isNaN(lat) && !Number.isNaN(lon)) {
                return { lat, lon };
            }
        } catch (e) {
            console.warn('IP location fallback failed:', e);
        }
        return null;
    }
    
    function updateWeatherFree(lat, lon) {
        // Use wttr.in free weather API (no API key required)
        // Note: wttr.in may have rate limits, but works without API key
        // Include location coordinates in the API call
        // Try with coordinates first, fallback to IP-based if that fails
        const urls = [
            `https://wttr.in/${lat},${lon}?format=j1`,
            `http://wttr.in/${lat},${lon}?format=j1`
        ];
        
        
        // Determine temperature unit first, then fetch weather
        determineTemperatureUnit(lat, lon).then(unit => {
            const isFahrenheit = unit === 'F';
            
            fetchJsonWithFallback(urls)
                .then(data => {
                    
                    // Check if data is valid
                    if (!data || !data.current_condition || !data.current_condition[0]) {
                        throw new Error('Invalid weather data format');
                    }
                    const area = data.nearest_area?.[0];
                    if (area) {
                        const city = area.areaName?.[0]?.value;
                        const region = area.region?.[0]?.value || area.state?.[0]?.value;
                        setWeatherLocationName(city, region);
                    }
                    
                    // Get temperature in the appropriate unit
                    const temp = isFahrenheit 
                        ? Math.round(parseFloat(data.current_condition[0].temp_F))
                        : Math.round(parseFloat(data.current_condition[0].temp_C));
                    const conditionCode = parseInt(data.current_condition[0].weatherCode);
                    const desc = data.current_condition[0].weatherDesc[0].value.toLowerCase();
                    
                    
                    // Only update if we successfully got new data
                    if (weatherTemp) {
                        weatherTemp.textContent = `${temp} ${unit}`;
                    }
                    // Map wttr.in weather codes/descriptions to icons
                    if (weatherIcon) {
                        const iconHTML = getWeatherIconFromDescription(conditionCode, desc);
                        weatherIcon.innerHTML = iconHTML;
                    }
                    
                    // Convert wttr.in condition to standard code for caching
                    let standardConditionCode = 800; // Default to clear
                    if (desc.includes('sunny') || desc.includes('clear') || conditionCode === 113) {
                        standardConditionCode = 800;
                    } else if (desc.includes('cloud') || (conditionCode >= 116 && conditionCode <= 122)) {
                        standardConditionCode = 803;
                    } else if (desc.includes('rain') || desc.includes('drizzle') || (conditionCode >= 266 && conditionCode <= 321)) {
                        standardConditionCode = 500;
                    } else if (desc.includes('thunder') || desc.includes('storm') || (conditionCode >= 350 && conditionCode <= 395)) {
                        standardConditionCode = 200;
                    } else if (desc.includes('snow') || (conditionCode >= 335 && conditionCode <= 339) || conditionCode >= 399) {
                        standardConditionCode = 600;
                    } else if (desc.includes('fog') || desc.includes('mist') || (conditionCode >= 143 && conditionCode <= 263)) {
                        standardConditionCode = 701;
                    }
                    
                    // Save to cache for next load (include unit)
                    saveWeatherData(temp, standardConditionCode, unit);
                })
                .catch(error => {
                    console.error('Error fetching weather:', error);
                    // Don't clear existing data on error - keep cached data visible
                    // Only show placeholder if we have no cached data
                    if (!loadCachedWeather()) {
                        weatherTemp.textContent = `-10 ${unit}`;
                    }
                });
        }).catch(error => {
            console.error('Error determining temperature unit:', error);
            // Fallback: try to fetch weather anyway with default unit
            const defaultUnit = localStorage.getItem('weatherUnit') || 'F';
            const isFahrenheit = defaultUnit === 'F';
            const urls = [
                `https://wttr.in/${lat},${lon}?format=j1`,
                `http://wttr.in/${lat},${lon}?format=j1`
            ];
            
            fetchJsonWithFallback(urls)
                .then(data => {
                    const area = data.nearest_area?.[0];
                    if (area) {
                        const city = area.areaName?.[0]?.value;
                        const region = area.region?.[0]?.value || area.state?.[0]?.value;
                        setWeatherLocationName(city, region);
                    }
                    const temp = isFahrenheit 
                        ? Math.round(parseFloat(data.current_condition[0].temp_F))
                        : Math.round(parseFloat(data.current_condition[0].temp_C));
                    const conditionCode = parseInt(data.current_condition[0].weatherCode);
                    const desc = data.current_condition[0].weatherDesc[0].value.toLowerCase();
                    
                    weatherTemp.textContent = `${temp} ${defaultUnit}`;
                    const iconHTML = getWeatherIconFromDescription(conditionCode, desc);
                    weatherIcon.innerHTML = iconHTML;
                    
                    let standardConditionCode = 800;
                    if (desc.includes('sunny') || desc.includes('clear') || conditionCode === 113) {
                        standardConditionCode = 800;
                    } else if (desc.includes('cloud') || (conditionCode >= 116 && conditionCode <= 122)) {
                        standardConditionCode = 803;
                    } else if (desc.includes('rain') || desc.includes('drizzle') || (conditionCode >= 266 && conditionCode <= 321)) {
                        standardConditionCode = 500;
                    } else if (desc.includes('thunder') || desc.includes('storm') || (conditionCode >= 350 && conditionCode <= 395)) {
                        standardConditionCode = 200;
                    } else if (desc.includes('snow') || (conditionCode >= 335 && conditionCode <= 339) || conditionCode >= 399) {
                        standardConditionCode = 600;
                    } else if (desc.includes('fog') || desc.includes('mist') || (conditionCode >= 143 && conditionCode <= 263)) {
                        standardConditionCode = 701;
                    }
                    
                    saveWeatherData(temp, standardConditionCode, defaultUnit);
                })
                .catch(error => {
                    console.error('Error fetching weather (fallback):', error);
                    // Try to load cached weather, or show placeholder
                    if (!loadCachedWeather()) {
                        weatherTemp.textContent = `-10 ${defaultUnit}`;
                    }
                });
        });
    }
    
    // Ensure cached weather is loaded immediately
    if (!hasCachedWeather) {
        // If no cached weather, show placeholder with default unit
        const savedUnit = localStorage.getItem('weatherUnit') || 'F';
        weatherTemp.textContent = `-10 ${savedUnit}`;
    }
    
    function getWeatherIconFromDescription(code, description) {
        // Map based on description keywords and codes
        if (description.includes('sunny') || description.includes('clear')) {
            return getWeatherIcon(800); // Clear sky
        } else if (description.includes('cloud')) {
            return getWeatherIcon(803); // Clouds
        } else if (description.includes('rain') || description.includes('drizzle')) {
            return getWeatherIcon(500); // Rain
        } else if (description.includes('thunder') || description.includes('storm')) {
            return getWeatherIcon(200); // Thunderstorm
        } else if (description.includes('snow')) {
            return getWeatherIcon(600); // Snow
        } else if (description.includes('fog') || description.includes('mist')) {
            return getWeatherIcon(701); // Mist
        } else {
            // Use code-based mapping for wttr.in (WMO codes)
            if (code === 113) return getWeatherIcon(800); // Clear
            if (code >= 116 && code <= 119) return getWeatherIcon(801); // Partly cloudy
            if (code >= 120 && code <= 122) return getWeatherIcon(802); // Cloudy
            if (code >= 143 && code <= 248) return getWeatherIcon(701); // Fog/Mist
            if (code >= 260 && code <= 263) return getWeatherIcon(701); // Freezing fog
            if (code >= 266 && code <= 274) return getWeatherIcon(500); // Rain
            if (code >= 275 && code <= 281) return getWeatherIcon(500); // Freezing rain
            if (code >= 284 && code <= 290) return getWeatherIcon(500); // Rain
            if (code >= 293 && code <= 302) return getWeatherIcon(500); // Rain
            if (code >= 305 && code <= 321) return getWeatherIcon(500); // Rain
            if (code >= 335 && code <= 339) return getWeatherIcon(600); // Snow
            if (code >= 350 && code <= 377) return getWeatherIcon(200); // Thunderstorm
            if (code >= 386 && code <= 395) return getWeatherIcon(200); // Thunderstorm
            if (code >= 399) return getWeatherIcon(600); // Snow
            return getWeatherIcon(800); // Default to clear
        }
    }
    
    function getLocation() {
        if (!navigator.geolocation) {
            console.error('Geolocation is not supported');
            getIPLocation().then((fallback) => {
                if (fallback) {
                    const { lat, lon } = fallback;
                    localStorage.setItem('weatherLocation', JSON.stringify({ lat, lon }));
                    localStorage.setItem('weatherLocationTime', Date.now().toString());
                    updateWeather(lat, lon);
                } else {
                    const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                    weatherTemp.textContent = `-10 ${savedUnit}`;
                }
            });
            return;
        }
        
        // Check if we're on file:// protocol - browsers don't persist permissions for file://
        // but they will still work within the session
        const isFileProtocol = window.location.protocol === 'file:';
        if (isFileProtocol) {
        }
        
        // Prevent multiple simultaneous location requests
        if (window.locationRequestInProgress) {
            return;
        }
        
        // Check if we have a cached location (less than 1 hour old)
        const cachedLocation = localStorage.getItem('weatherLocation');
        const cachedTime = localStorage.getItem('weatherLocationTime');
        
        if (cachedLocation && cachedTime) {
            const age = Date.now() - parseInt(cachedTime);
            const oneHour = 60 * 60 * 1000;
            
            if (age < oneHour) {
                try {
                    const { lat, lon } = JSON.parse(cachedLocation);
                    updateWeather(lat, lon);
                    // Set up interval for updates
                    if (!window.weatherUpdateInterval) {
                        window.weatherUpdateInterval = setInterval(() => {
                            updateWeather(lat, lon);
                        }, 5 * 60 * 1000); // Update every 5 minutes
                    }
                    return;
                } catch (e) {
                    // Invalid cached data, continue to get fresh location
                }
            }
        }
        
        // Check saved permission state FIRST - trust localStorage if it says 'granted'
        let savedPermissionState = localStorage.getItem('locationPermissionState');
        if (isElectron && savedPermissionState === 'denied') {
            localStorage.removeItem('locationPermissionState');
            localStorage.removeItem('locationPermissionAsked');
            savedPermissionState = null;
        }
        
        if (savedPermissionState === 'granted') {
            // Permission was previously granted, proceed directly without checking API
            // This prevents repeated prompts when browser API returns 'prompt' after refresh
            requestLocation();
            return;
        }
        
        if (savedPermissionState === 'denied') {
            // Permission was previously denied, don't request again
            const savedUnit = localStorage.getItem('weatherUnit') || 'F';
            weatherTemp.textContent = `-10 ${savedUnit}`;
            return;
        }
        
        // Check permission state (if Permissions API is available)
        if (navigator.permissions && navigator.permissions.query) {
            navigator.permissions.query({ name: 'geolocation' }).then(result => {
                // Get current saved state BEFORE checking API result
                const currentSavedState = localStorage.getItem('locationPermissionState');
                const hasAskedBefore = localStorage.getItem('locationPermissionAsked');
                
                // Only update permission state if API returns a definitive state (granted/denied)
                // Don't overwrite saved 'granted' or 'denied' with 'prompt'
                if (result.state === 'denied') {
                    // Permission was denied - always save this
                    localStorage.setItem('locationPermissionState', 'denied');
                    localStorage.setItem('locationPermissionAsked', 'true');
                    const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                    weatherTemp.textContent = `-10 ${savedUnit}`;
                    return;
                }
                
                // Permission is granted, proceed directly with location request
                if (result.state === 'granted') {
                    // Save granted state to localStorage for future checks
                    localStorage.setItem('locationPermissionState', 'granted');
                    localStorage.setItem('locationPermissionAsked', 'true');
                    requestLocation();
                    return;
                }
                
                // Permission state is 'prompt', check if we've already asked
                if (result.state === 'prompt') {
                    // If we previously saved 'granted' or 'denied' but API now says 'prompt', 
                    // trust the saved state (this can happen after page refresh in some browsers)
                    if (currentSavedState === 'granted' && hasAskedBefore === 'true') {
                        // Don't overwrite saved 'granted' with 'prompt'
                        requestLocation();
                        return;
                    }
                    
                    if (currentSavedState === 'denied' && hasAskedBefore === 'true') {
                        // Don't overwrite saved 'denied' with 'prompt'
                        const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                        weatherTemp.textContent = `-10 ${savedUnit}`;
                        return;
                    }
                    
                    // First time seeing 'prompt', proceed with location request (browser will handle the prompt)
                    localStorage.setItem('locationPermissionAsked', 'true');
                    // Don't save 'prompt' state - wait for actual grant/deny response
                    requestLocation();
                    return;
                }
                
                // Fallback: proceed with location request
                requestLocation();
            }).then(result => {
                // Listen for permission changes (but don't overwrite saved state unnecessarily)
                if (result && result.addEventListener) {
                    result.addEventListener('change', () => {
                        const newState = result.state;
                        const currentSavedState = localStorage.getItem('locationPermissionState');
                        
                        // Only update if there's a definitive state change (granted/denied)
                        // Don't overwrite saved 'granted' or 'denied' with 'prompt'
                        if (newState === 'granted' || newState === 'denied') {
                            localStorage.setItem('locationPermissionState', newState);
                            localStorage.setItem('locationPermissionAsked', 'true');
                            
                            if (newState === 'denied') {
                                const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                                weatherTemp.textContent = `-10 ${savedUnit}`;
                            } else if (newState === 'granted') {
                                // If permission was just granted, get location
                                requestLocation();
                            }
                        }
                    });
                }
                return result;
            }).catch(() => {
                // Permissions API not supported, check saved state
                const savedState = localStorage.getItem('locationPermissionState');
                const hasAskedBefore = localStorage.getItem('locationPermissionAsked');
                
                if (savedState === 'granted') {
                    requestLocation();
                } else if (savedState === 'denied') {
                    // Permission was denied, don't request again
                    const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                    weatherTemp.textContent = `-10 ${savedUnit}`;
                } else if (hasAskedBefore !== 'true') {
                    // First time, proceed with location request (browser will handle the prompt)
                    localStorage.setItem('locationPermissionAsked', 'true');
                    requestLocation();
                } else {
                    // We've asked before but state is unclear, don't request again to avoid repeated prompts
                    const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                    weatherTemp.textContent = `-10 ${savedUnit}`;
                }
            });
        } else {
            // Permissions API not available, check if we've asked before
            const hasAskedBefore = localStorage.getItem('locationPermissionAsked');
            const savedState = localStorage.getItem('locationPermissionState');
            
            if (savedState === 'granted') {
                // Permission was granted before, proceed directly
                requestLocation();
            } else if (savedState === 'denied') {
                // Permission was denied, don't ask again
                const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                weatherTemp.textContent = `-10 ${savedUnit}`;
            } else if (hasAskedBefore === 'true') {
                // We've asked before, proceed (browser will handle the prompt)
                requestLocation();
            } else {
                // First time, proceed with location request (browser will handle the prompt)
                localStorage.setItem('locationPermissionAsked', 'true');
                requestLocation();
            }
        }
    }
    
    function requestLocation() {
        // Check saved permission state BEFORE making request
        const savedPermissionState = localStorage.getItem('locationPermissionState');
        const hasAskedBefore = localStorage.getItem('locationPermissionAsked');
        
        // If permission was previously denied, don't request again
        if (savedPermissionState === 'denied') {
            const savedUnit = localStorage.getItem('weatherUnit') || 'F';
            weatherTemp.textContent = `-10 ${savedUnit}`;
            return;
        }
        
        // If permission was granted before, check for cached location first
        if (savedPermissionState === 'granted' && hasAskedBefore === 'true') {
            const cachedLocation = localStorage.getItem('weatherLocation');
            const cachedTime = localStorage.getItem('weatherLocationTime');
            
            if (cachedLocation && cachedTime) {
                const age = Date.now() - parseInt(cachedTime);
                const oneHour = 60 * 60 * 1000;
                
                // Use cached location if it's less than 1 hour old
                if (age < oneHour) {
                    try {
                        const { lat, lon } = JSON.parse(cachedLocation);
                        updateWeather(lat, lon);
                        if (!localStorage.getItem('weatherLocationName')) {
                            updateLocationNameFromCoords(lat, lon).then(() => {
                                if (!localStorage.getItem('weatherLocationName')) {
                                    getIPLocation();
                                }
                            });
                        }
                        // Set up interval for updates
                        if (!window.weatherUpdateInterval) {
                            window.weatherUpdateInterval = setInterval(() => {
                                updateWeather(lat, lon);
                            }, 5 * 60 * 1000); // Update every 5 minutes
                        }
                        return;
                    } catch (e) {
                        // Invalid cached data, continue to request new location
                        console.warn('Invalid cached location data, requesting new location');
                    }
                }
            }
        }
        
        // Set flag to prevent multiple simultaneous requests
        window.locationRequestInProgress = true;
        
        navigator.geolocation.getCurrentPosition(
            position => {
                // Clear the flag on success
                window.locationRequestInProgress = false;
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                // Cache the location
                localStorage.setItem('weatherLocation', JSON.stringify({ lat, lon }));
                localStorage.setItem('weatherLocationTime', Date.now().toString());
                
                // Save granted permission state IMMEDIATELY - if we got location, permission was granted
                // This ensures it's saved even if user refreshes quickly
                localStorage.setItem('locationPermissionState', 'granted');
                localStorage.setItem('locationPermissionAsked', 'true');
                
                // Verify permission state with Permissions API after a short delay
                // This gives the browser time to update its internal permission state
                setTimeout(() => {
                    if (navigator.permissions && navigator.permissions.query) {
                        navigator.permissions.query({ name: 'geolocation' }).then(result => {
                            // Update with the actual permission state from the browser if different
                            if (result.state === 'granted' || result.state === 'denied') {
                                localStorage.setItem('locationPermissionState', result.state);
                                localStorage.setItem('locationPermissionAsked', 'true');
                            }
                            
                            // Listen for permission changes (e.g., if user manually revokes it)
                            if (result.addEventListener) {
                                result.addEventListener('change', () => {
                                    const newState = result.state;
                                    if (newState === 'granted' || newState === 'denied') {
                                        localStorage.setItem('locationPermissionState', newState);
                                        localStorage.setItem('locationPermissionAsked', 'true');
                                        
                                        if (newState === 'denied') {
                                            const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                                            weatherTemp.textContent = `-10 ${savedUnit}`;
                                        }
                                    }
                                });
                            }
                        }).catch(() => {
                            // Permissions API query failed, but we already saved 'granted' above
                        });
                    }
                }, 500); // 500ms delay to let browser update its permission state
                
                updateWeather(lat, lon);
                updateLocationNameFromCoords(lat, lon).then(() => {
                    if (!localStorage.getItem('weatherLocationName')) {
                        getIPLocation();
                    }
                });
                
                // Update weather every 5 minutes
                if (window.weatherUpdateInterval) {
                    clearInterval(window.weatherUpdateInterval);
                }
                window.weatherUpdateInterval = setInterval(() => {
                    updateWeather(lat, lon);
                }, 5 * 60 * 1000); // Update every 5 minutes
            },
            error => {
                // Clear the flag on error
                window.locationRequestInProgress = false;
                
                console.error('Error getting location:', error);
                
                // If permission was denied, save the state and don't request again
                const savedUnit = localStorage.getItem('weatherUnit') || 'F';
                if (error.code === error.PERMISSION_DENIED) {
                    localStorage.setItem('locationPermissionState', 'denied');
                    localStorage.setItem('locationPermissionAsked', 'true');
                    weatherTemp.textContent = `-10 ${savedUnit}`;
                } else {
                    getIPLocation().then((fallback) => {
                        if (fallback) {
                            const { lat, lon } = fallback;
                            localStorage.setItem('weatherLocation', JSON.stringify({ lat, lon }));
                            localStorage.setItem('weatherLocationTime', Date.now().toString());
                            updateWeather(lat, lon);
                        } else {
                            weatherTemp.textContent = `-10 ${savedUnit}`;
                        }
                    });
                }
            },
            {
                // Options to reduce prompts
                enableHighAccuracy: false,
                timeout: 10000,
                maximumAge: 3600000 // Accept cached location up to 1 hour old
            }
        );
    }
    
    // Initialize weather on load
    // Cached weather is already displayed above, now update in background
    // Only call getLocation if we don't have cached weather or if it's old
    const cachedLocation = localStorage.getItem('weatherLocation');
    const cachedTime = localStorage.getItem('weatherLocationTime');
    let savedPermissionState = localStorage.getItem('locationPermissionState');
    let hasAskedBefore = localStorage.getItem('locationPermissionAsked');
    if (isElectron && savedPermissionState === 'denied') {
        localStorage.removeItem('locationPermissionState');
        localStorage.removeItem('locationPermissionAsked');
        savedPermissionState = null;
        hasAskedBefore = null;
    }
    
    // If permission was denied, don't request location even if cache is old
    if (savedPermissionState === 'denied') {
        // Use whatever cached weather we have, or show default
        if (hasCachedWeather) {
            // Keep using cached weather even if location is old
            try {
                const { lat, lon } = JSON.parse(cachedLocation || '{}');
                if (lat && lon) {
                    updateWeather(lat, lon);
                }
            } catch (e) {
                // Ignore parsing errors
            }
        }
        return;
    }
    
    if (!hasCachedWeather || !cachedLocation || !cachedTime) {
        // No cached weather or location, get location to fetch weather
        // But only if permission wasn't denied
        if (savedPermissionState !== 'denied') {
            getLocation();
        }
    } else {
        // We have cached weather, but check if location is still valid
        const age = Date.now() - parseInt(cachedTime);
        const oneHour = 60 * 60 * 1000;
        
        if (age >= oneHour) {
            // Location is old, refresh it - but only if permission was granted
            if (savedPermissionState === 'granted' && hasAskedBefore === 'true') {
                // Permission was granted before, safe to refresh
                getLocation();
            } else if (savedPermissionState !== 'denied') {
                // Permission not denied yet, but also not explicitly granted
                // Only refresh if we haven't asked before, otherwise use cached location
                if (hasAskedBefore !== 'true') {
                    getLocation();
                } else {
                    // We've asked before but don't have explicit grant, use cached location
                    try {
                        const { lat, lon } = JSON.parse(cachedLocation);
                        updateWeather(lat, lon);
                    } catch (e) {
                        console.error('Error parsing cached location:', e);
                    }
                }
            } else {
                // Permission was denied or state is unclear, use cached location
                try {
                    const { lat, lon } = JSON.parse(cachedLocation);
                    updateWeather(lat, lon);
                } catch (e) {
                    console.error('Error parsing cached location:', e);
                }
            }
        } else {
            // Use cached location to refresh weather
            try {
                const { lat, lon } = JSON.parse(cachedLocation);
                updateWeather(lat, lon);
            } catch (e) {
                console.error('Error parsing cached location:', e);
                // Only try to get new location if permission wasn't denied
                if (savedPermissionState !== 'denied') {
                    getLocation();
                }
            }
        }
    }
}

// Initialize Weather Icon Visibility
function initWeatherIconVisibility() {
    const weatherControlItem = document.querySelector('#weather-icon')?.closest('.dock-control-item');
    if (weatherControlItem) {
        const weatherIconVisible = localStorage.getItem('weatherIconVisible');
        const shouldShowWeather = weatherIconVisible === null || weatherIconVisible === 'true'; // Default to visible
        weatherControlItem.style.display = shouldShowWeather ? 'flex' : 'none';
    }
}

function initDockControlsVisibility() {
    const dockVisibilityConfigs = [
        {
            storageKey: 'dockVolumeVisible',
            element: document.querySelector('#volume-icon')?.closest('.dock-control-item'),
            defaultVisible: true,
            display: 'flex'
        },
        {
            storageKey: 'dockWifiVisible',
            element: document.querySelector('#wifi-icon')?.closest('.dock-control-item'),
            defaultVisible: true,
            display: 'flex'
        },
        {
            storageKey: 'dockBluetoothVisible',
            element: document.querySelector('#bluetooth-icon')?.closest('.dock-control-item'),
            defaultVisible: true,
            display: 'flex'
        },
        {
            storageKey: 'dockBatteryVisible',
            element: document.querySelector('#battery-icon')?.closest('.dock-control-item'),
            defaultVisible: true,
            display: 'flex'
        }
    ];

    dockVisibilityConfigs.forEach(config => {
        if (!config.element) return;
        const savedState = localStorage.getItem(config.storageKey);
        const isVisible = savedState !== null ? savedState === 'true' : config.defaultVisible;
        config.element.style.display = isVisible ? config.display : 'none';
    });
}


// Login Screen Functionality
// User data - in a real system, this would be stored securely
// User management functions
function getUsers() {
    // Migrate from old localStorage key if it exists
    const oldStored = localStorage.getItem('daddyos_users');
    if (oldStored && !localStorage.getItem('pilkos_users')) {
        try {
            localStorage.setItem('pilkos_users', oldStored);
            localStorage.removeItem('daddyos_users');
        } catch (e) {
            console.error('Error migrating users from old localStorage key:', e);
        }
    }
    
    const stored = localStorage.getItem('pilkos_users');
    if (stored) {
        try {
            const users = JSON.parse(stored);
            // Ensure all users have a role (migrate existing users without roles)
            const migrated = users.map(user => {
                if (!user.role) {
                    // Default role based on name for existing users
                    if (user.name.toLowerCase() === 'admin') {
                        return { ...user, role: 'admin' };
                    }
                    return { ...user, role: 'user' };
                }
                return user;
            });
            // Save migrated users if any changes were made
            if (JSON.stringify(users) !== JSON.stringify(migrated)) {
                saveUsers(migrated);
            }
            return migrated;
        } catch (e) {
            console.error('Error parsing users from localStorage:', e);
        }
    }
    // Default user if none exist - only Admin account
    const defaultUsers = [
        { id: 1, name: 'Admin', password: 'admin123', role: 'admin' }
    ];
    saveUsers(defaultUsers);
    return defaultUsers;
}

function saveUsers(usersArray) {
    localStorage.setItem('pilkos_users', JSON.stringify(usersArray));
}

function addUser(user) {
    const users = getUsers();
    const newId = users.length > 0 ? Math.max(...users.map(u => u.id)) + 1 : 1;
    // Default to 'user' role if not specified
    const newUser = { ...user, id: newId, role: user.role || 'user' };
    users.push(newUser);
    saveUsers(users);
    
    // Create user-specific folders asynchronously
    (async () => {
        try {
            const fs = await initFileSystem();
            await createUserFolders(newUser.name, fs);
        } catch (e) {
            console.error('Error creating folders for new user:', e);
        }
    })();
    
    return newUser;
}

function removeUser(userId) {
    const users = getUsers();
    const filtered = users.filter(u => u.id !== userId);
    saveUsers(filtered);
    return filtered;
}

function updateUser(userId, updates) {
    const users = getUsers();
    const index = users.findIndex(u => u.id === userId);
    if (index !== -1) {
        users[index] = { ...users[index], ...updates };
        saveUsers(users);

        // Keep the currently logged-in user in sync if they edited their own profile.
        try {
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                const current = JSON.parse(loggedInUser);
                if (current && current.id === userId) {
                    localStorage.setItem('loggedInUser', JSON.stringify(users[index]));
                }
            }
        } catch (e) {
            // ignore storage errors
        }

        return users[index];
    }
    return null;
}

function getUserAvatarInnerHTML(user) {
    if (user && typeof user.avatarImage === 'string' && user.avatarImage.startsWith('data:image')) {
        return `<img src="${user.avatarImage}" alt="" draggable="false" />`;
    }
    // Default avatar icon: match the Files sidebar "User" icon (user-home sidebar item)
    return `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
        </svg>
    `.trim();
}

async function resizeImageFileToDataUrl(file, maxSizePx = 128, quality = 0.85) {
    if (!file) return null;

    // Basic validation
    if (!file.type || !file.type.startsWith('image/')) {
        throw new Error('Please select an image file.');
    }

    const blobUrl = URL.createObjectURL(file);
    try {
        const img = new Image();
        img.src = blobUrl;

        // Wait for image to decode
        if (img.decode) {
            await img.decode();
        } else {
            await new Promise((resolve, reject) => {
                img.onload = () => resolve();
                img.onerror = () => reject(new Error('Failed to load image.'));
            });
        }

        const w = img.naturalWidth || img.width || 1;
        const h = img.naturalHeight || img.height || 1;
        const scale = Math.min(1, maxSizePx / Math.max(w, h));
        const targetW = Math.max(1, Math.round(w * scale));
        const targetH = Math.max(1, Math.round(h * scale));

        const canvas = document.createElement('canvas');
        canvas.width = targetW;
        canvas.height = targetH;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            // Fallback: FileReader without resize
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(String(reader.result || ''));
                reader.onerror = () => reject(new Error('Failed to read image.'));
                reader.readAsDataURL(file);
            });
            return dataUrl;
        }

        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, targetW, targetH);

        // Prefer JPEG for size, but preserve PNGs with alpha if needed
        const usePng = file.type === 'image/png';
        const dataUrl = usePng ? canvas.toDataURL('image/png') : canvas.toDataURL('image/jpeg', quality);
        return dataUrl;
    } finally {
        URL.revokeObjectURL(blobUrl);
    }
}

let currentUser = null;

function initLoginScreen() {
    const loginScreen = document.getElementById('login-screen');
    const desktop = document.getElementById('desktop');
    const loginUsers = document.getElementById('login-users');
    const loginPasswordContainer = document.getElementById('login-password-container');
    const loginPassword = document.getElementById('login-password');
    const loginPasswordToggle = document.getElementById('login-password-toggle');
    const loginSubmitBtn = document.getElementById('login-submit-btn');
    const loginBackBtn = document.getElementById('login-back-btn');
    const loginError = document.getElementById('login-error');
    const loginSelectedUser = document.getElementById('login-selected-user');
    const loginRestartBtn = document.getElementById('login-restart-btn');
    const loginShutdownBtn = document.getElementById('login-shutdown-btn');

    if (!loginScreen || !desktop) {
        return;
    }

    // Idempotency: initLoginScreen() is called on boot and may be called again after sign-out/restart.
    // Avoid stacking duplicate event listeners by short-circuiting if we already bound them once.
    if (loginScreen.hasAttribute('data-login-initialized')) {
        // After boot/restart, always land on login screen (even if a previous session exists).
        loginScreen.classList.remove('hidden');
        loginScreen.style.display = 'flex';
        loginScreen.style.pointerEvents = 'auto';
        desktop.style.display = 'none';
        desktop.style.pointerEvents = 'none';

        // Re-render users list in case it changed.
        try { refreshLoginScreen(); } catch (e) {}
        return;
    }

    // Password visibility toggle (reuses the same eyeball icon style as Files app)
    const passwordToggleIcon = loginPasswordToggle ? loginPasswordToggle.querySelector('svg') : null;
    let isPasswordVisible = false;

    const setLoginBackVisible = (visible) => {
        if (!loginBackBtn) return;
        const show = !!visible;
        loginBackBtn.hidden = !show;
        loginBackBtn.style.display = show ? 'flex' : 'none';
        loginBackBtn.setAttribute('aria-hidden', show ? 'false' : 'true');
        // When hidden, prevent keyboard focus.
        loginBackBtn.tabIndex = show ? 0 : -1;
    };

    const setPasswordVisible = (visible) => {
        if (!loginPassword) return;
        isPasswordVisible = !!visible;
        loginPassword.type = isPasswordVisible ? 'text' : 'password';

        if (loginPasswordToggle) {
            loginPasswordToggle.setAttribute('aria-pressed', isPasswordVisible ? 'true' : 'false');
            loginPasswordToggle.setAttribute('aria-label', isPasswordVisible ? 'Hide password' : 'Show password');
            loginPasswordToggle.title = isPasswordVisible ? 'Hide password' : 'Show password';
        }

        if (passwordToggleIcon) {
            if (isPasswordVisible) {
                // Visible: show normal eyeball
                passwordToggleIcon.innerHTML = `
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                `;
            } else {
                // Hidden: show eyeball with diagonal line
                passwordToggleIcon.innerHTML = `
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                    <line x1="1" y1="1" x2="23" y2="23"></line>
                `;
            }
        }
    };

    if (loginPasswordToggle && loginPassword) {
        // Ensure default state
        setPasswordVisible(false);
        loginPasswordToggle.addEventListener('click', () => {
            setPasswordVisible(!isPasswordVisible);
            try { loginPassword.focus(); } catch (e) {}
        });
    }

    // Show login screen
    loginScreen.classList.remove('hidden');
    loginScreen.style.display = 'flex';
    loginScreen.style.pointerEvents = 'auto';
    desktop.style.display = 'none';
    desktop.style.pointerEvents = 'none';

    // Render user cards
    function renderUsers() {
        loginUsers.innerHTML = '';
        const users = getUsers();
        setLoginBackVisible(users.length > 1);
        users.forEach(user => {
            const userCard = document.createElement('div');
            userCard.className = 'login-user-card';
            userCard.innerHTML = `
                <div class="login-user-avatar">${getUserAvatarInnerHTML(user)}</div>
                <div class="login-user-name">${user.name}</div>
            `;
            userCard.addEventListener('click', () => selectUser(user));
            loginUsers.appendChild(userCard);
        });
        // If there's only one account, skip the user picker entirely.
        if (users.length === 1) {
            selectUser(users[0]);
        }
    }

    // Select user
    function selectUser(user) {
        // Hide back button when there is only a single account.
        try { setLoginBackVisible(getUsers().length > 1); } catch (e) {}
        loginUsers.style.display = 'none';
        loginPasswordContainer.style.display = 'flex';
        loginError.style.display = 'none';
        
        loginSelectedUser.innerHTML = `
            <div class="login-selected-user-avatar">${getUserAvatarInnerHTML(user)}</div>
            <div class="login-selected-user-name">${user.name}</div>
        `;
        
        loginPassword.value = '';
        setPasswordVisible(false);
        loginPassword.focus();
        currentUser = user;
    }

    // Go back to user selection
    function goBackToUsers() {
        // In single-user mode, there is no user picker to return to.
        try {
            const users = getUsers();
            if (users.length <= 1) {
                setLoginBackVisible(false);
                return;
            }
        } catch (e) {}
        loginPasswordContainer.style.display = 'none';
        loginUsers.style.display = 'grid';
        loginError.style.display = 'none';
        loginPassword.value = '';
        setPasswordVisible(false);
        currentUser = null;
    }

    // Authenticate user
    function authenticate() {
        if (!currentUser) return;

        const password = loginPassword.value.trim();
        
        if (password === currentUser.password) {
            // Successful login
            loginError.style.display = 'none';
            localStorage.setItem('loggedInUser', JSON.stringify(currentUser));
            showDesktop();
        } else {
            // Failed login
            loginError.style.display = 'flex';
            loginPassword.value = '';
            setPasswordVisible(false);
            loginPassword.focus();
            
            // Shake animation
            loginPasswordContainer.style.animation = 'none';
            setTimeout(() => {
                loginPasswordContainer.style.animation = 'shake 0.5s ease';
            }, 10);
        }
    }

    // Show desktop
    function showDesktop() {
        loginScreen.classList.add('hidden');
        loginScreen.style.display = 'none'; // Ensure it's completely hidden
        loginScreen.style.pointerEvents = 'none'; // Disable pointer events
        desktop.style.display = 'flex';
        desktop.style.pointerEvents = 'auto'; // Enable pointer events on desktop
        
        // Initialize desktop components if not already initialized
        const isInitialized = desktop.hasAttribute('data-initialized');
        const isInitializing = desktop.hasAttribute('data-initializing');
        if (!isInitialized && !isInitializing) {
            // Use setTimeout to ensure desktop is fully visible before initializing
            setTimeout(() => {
                initDesktop();
            }, 50);
        }
    }

    function restartFromLogin() {
        // Restart: go boot -> login again (requires re-auth).
        try { localStorage.removeItem('loggedInUser'); } catch (e) {}
        try { sessionStorage.clear(); } catch (e) {}
        // Force boot splash on next load (explicit restart).
        try { sessionStorage.setItem('forceBootOnce', '1'); } catch (e) {}
        const boot = document.getElementById('boot-screen');
        if (boot) {
            boot.style.display = 'flex';
            boot.classList.remove('boot-hide');
            boot.classList.add('boot-show');
        }
        setTimeout(() => window.location.reload(), 50);
    }

    function shutdownFromLogin() {
        // Shutdown: wipe browser data for this webpage and reload into a clean cold boot.
        const boot = document.getElementById('boot-screen');
        if (boot) {
            boot.style.display = 'flex';
            boot.classList.remove('boot-hide');
            boot.classList.add('boot-show');
        }
        (async () => {
            await wipeSiteData();
            setTimeout(() => window.location.reload(), 50);
        })();
    }

    // Event listeners
    loginSubmitBtn.addEventListener('click', authenticate);
    loginBackBtn.addEventListener('click', goBackToUsers);
    if (loginRestartBtn) loginRestartBtn.addEventListener('click', restartFromLogin);
    if (loginShutdownBtn) loginShutdownBtn.addEventListener('click', shutdownFromLogin);
    
    loginPassword.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            authenticate();
        }
    });

    // Initialize
    renderUsers();
    // Convenience: if there are multiple users and one was previously logged in, pre-select them so login is 1-step.
    try {
        const users = getUsers();
        if (users.length > 1) {
            const loggedInUser = localStorage.getItem('loggedInUser');
            if (loggedInUser) {
                const prev = JSON.parse(loggedInUser);
                const match = users.find(u => (prev && (u.id === prev.id || u.name === prev.name)));
                if (match) {
                    selectUser(match);
                }
            }
        }
    } catch (e) {
        // ignore
    }
    loginScreen.setAttribute('data-login-initialized', 'true');
}

// Function to refresh login screen when users change
function refreshLoginScreen() {
    const loginUsers = document.getElementById('login-users');
    if (!loginUsers) return;

    const loginBackBtn = document.getElementById('login-back-btn');
    const setLoginBackVisible = (visible) => {
        if (!loginBackBtn) return;
        const show = !!visible;
        loginBackBtn.hidden = !show;
        loginBackBtn.style.display = show ? 'flex' : 'none';
        loginBackBtn.setAttribute('aria-hidden', show ? 'false' : 'true');
        loginBackBtn.tabIndex = show ? 0 : -1;
    };

    const showPasswordPromptForUser = (user) => {
        const loginPasswordContainer = document.getElementById('login-password-container');
        const loginSelectedUser = document.getElementById('login-selected-user');
        const loginPassword = document.getElementById('login-password');
        const loginPasswordToggle = document.getElementById('login-password-toggle');
        const loginError = document.getElementById('login-error');

        if (!loginPasswordContainer || !loginSelectedUser || !loginPassword) return;

        // Hide back button when there is only a single account.
        try { setLoginBackVisible(getUsers().length > 1); } catch (e) {}

        loginUsers.style.display = 'none';
        loginPasswordContainer.style.display = 'flex';
        if (loginError) loginError.style.display = 'none';

        loginSelectedUser.innerHTML = `
            <div class="login-selected-user-avatar">${getUserAvatarInnerHTML(user)}</div>
            <div class="login-selected-user-name">${user.name}</div>
        `;

        loginPassword.value = '';
        // Reset password visibility to hidden
        try { loginPassword.type = 'password'; } catch (e) {}
        if (loginPasswordToggle) {
            loginPasswordToggle.setAttribute('aria-pressed', 'false');
            loginPasswordToggle.setAttribute('aria-label', 'Show password');
            loginPasswordToggle.title = 'Show password';
            const icon = loginPasswordToggle.querySelector('svg');
            if (icon) {
                icon.innerHTML = `
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                    <line x1="1" y1="1" x2="23" y2="23"></line>
                `;
            }
        }
        try { loginPassword.focus(); } catch (e) {}
        currentUser = user;
    };

    loginUsers.innerHTML = '';
    const users = getUsers();
    setLoginBackVisible(users.length > 1);

    users.forEach(user => {
        const userCard = document.createElement('div');
        userCard.className = 'login-user-card';
        userCard.innerHTML = `
            <div class="login-user-avatar">${getUserAvatarInnerHTML(user)}</div>
            <div class="login-user-name">${user.name}</div>
        `;
        userCard.addEventListener('click', () => showPasswordPromptForUser(user));
        loginUsers.appendChild(userCard);
    });

    // If there's only one account, skip the user picker entirely.
    if (users.length === 1) {
        showPasswordPromptForUser(users[0]);
    }
}

// Sign out function
function signOut() {
    localStorage.removeItem('loggedInUser');
    currentUser = null;
    
    const loginScreen = document.getElementById('login-screen');
    const desktop = document.getElementById('desktop');
    
    if (loginScreen && desktop) {
        desktop.style.display = 'none';
        desktop.style.pointerEvents = 'none';
        desktop.removeAttribute('data-initialized'); // Reset initialization flag
        desktop.removeAttribute('data-initializing');
        loginScreen.classList.remove('hidden');
        loginScreen.style.display = 'flex';
        loginScreen.style.pointerEvents = 'auto';
        
        // Reset login screen
        const loginUsers = document.getElementById('login-users');
        const loginPasswordContainer = document.getElementById('login-password-container');
        const loginPassword = document.getElementById('login-password');
        const loginPasswordToggle = document.getElementById('login-password-toggle');
        const loginError = document.getElementById('login-error');
        
        if (loginUsers) loginUsers.style.display = 'grid';
        if (loginPasswordContainer) loginPasswordContainer.style.display = 'none';
        if (loginPassword) loginPassword.value = '';
        // Reset password visibility to hidden
        if (loginPassword) {
            try { loginPassword.type = 'password'; } catch (e) {}
        }
        if (loginPasswordToggle) {
            loginPasswordToggle.setAttribute('aria-pressed', 'false');
            loginPasswordToggle.setAttribute('aria-label', 'Show password');
            loginPasswordToggle.title = 'Show password';
            const icon = loginPasswordToggle.querySelector('svg');
            if (icon) {
                icon.innerHTML = `
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                    <line x1="1" y1="1" x2="23" y2="23"></line>
                `;
            }
        }
        if (loginError) loginError.style.display = 'none';
    }

    // Ensure login reflects latest user list and applies single-user auto-select behavior.
    try { refreshLoginScreen(); } catch (e) {}
    
    // Close all DESKTOP windows (do not remove the login dialog, which is also a `.window`).
    const windows = document.querySelectorAll('.window');
    windows.forEach(winEl => {
        if (winEl.closest('#login-screen')) return;
        winEl.remove();
    });
}

// Screenshots (Ctrl + PrintScreen)
let screenshotInProgress = false;
const screenshotAssetCache = new Map();
let screenshotAssetCachePromise = null;

function getScreenshotFileName() {
    const now = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const yyyy = now.getFullYear();
    const mm = pad(now.getMonth() + 1);
    const dd = pad(now.getDate());
    const hh = pad(now.getHours());
    const min = pad(now.getMinutes());
    const ss = pad(now.getSeconds());
    return `screenshot-${yyyy}${mm}${dd}-${hh}${min}${ss}.png`;
}

function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function resolveScreenshotAssetUrl(url) {
    if (!url) return url;
    try {
        return new URL(url, window.location.href).href;
    } catch {
        return url;
    }
}

function isScreenshotSafeUrl(url) {
    if (!url) return true;
    const s = String(url).trim();
    return s.startsWith('data:') || s.startsWith('blob:');
}

function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

async function preloadScreenshotAssets() {
    if (screenshotAssetCachePromise) return screenshotAssetCachePromise;
    screenshotAssetCachePromise = (async () => {
        const urls = new Set();
        document.querySelectorAll('img').forEach(img => {
            const src = img.getAttribute('src');
            if (src && !isScreenshotSafeUrl(src)) urls.add(src);
        });

        const bgTargets = document.querySelectorAll('.desktop, .login-screen, .dock');
        bgTargets.forEach(el => {
            const bg = window.getComputedStyle(el).backgroundImage;
            if (!bg || !bg.includes('url(')) return;
            Array.from(bg.matchAll(/url\(([^)]+)\)/g)).forEach(match => {
                const raw = (match[1] || '').replace(/["']/g, '').trim();
                if (raw && !isScreenshotSafeUrl(raw)) urls.add(raw);
            });
        });

        for (const rawUrl of urls) {
            const resolved = resolveScreenshotAssetUrl(rawUrl);
            if (screenshotAssetCache.has(resolved) || screenshotAssetCache.has(rawUrl)) continue;
            try {
                const response = await fetch(resolved);
                if (!response.ok) continue;
                const blob = await response.blob();
                const dataUrl = await blobToDataUrl(blob);
                if (typeof dataUrl === 'string') {
                    screenshotAssetCache.set(resolved, dataUrl);
                    screenshotAssetCache.set(rawUrl, dataUrl);
                }
            } catch (e) {
                // Ignore asset preload failures; we'll fallback to safe placeholders.
            }
        }
    })();
    return screenshotAssetCachePromise;
}

async function captureViewportPngBlob({ sanitize = false } = {}) {
    if (typeof html2canvas !== 'function') {
        throw new Error('html2canvas is not available (screenshot capture library failed to load).');
    }

    const isFileProtocol = window.location && window.location.protocol === 'file:';
    const effectiveSanitize = sanitize || isFileProtocol;
    if (effectiveSanitize && isFileProtocol) {
        try {
            await preloadScreenshotAssets();
        } catch (e) {
            // Best effort only; screenshot will continue with current cache.
        }
    }

    // Capture only the currently visible viewport (not the whole page).
    const canvas = await html2canvas(document.body, {
        backgroundColor: null,
        logging: false,
        // CORS is unreliable/meaningless on file:// origins; prefer skipping unsafe images instead.
        useCORS: !isFileProtocol,
        allowTaint: false,
        scale: window.devicePixelRatio || 1,
        scrollX: -window.scrollX,
        scrollY: -window.scrollY,
        windowWidth: document.documentElement.clientWidth,
        windowHeight: document.documentElement.clientHeight,
        onclone: effectiveSanitize ? (clonedDoc) => {
            try {
                // Remove/neutralize the most common causes of canvas tainting.
                // 1) <img> elements
                const imgs = Array.from(clonedDoc.querySelectorAll('img'));
                for (const img of imgs) {
                    const src = img.getAttribute('src') || '';
                    if (!src) continue;
                    const resolvedSrc = resolveScreenshotAssetUrl(src);
                    const cached = screenshotAssetCache.get(resolvedSrc) || screenshotAssetCache.get(src);
                    if (cached) {
                        img.setAttribute('src', cached);
                        continue;
                    }
                    if (isFileProtocol && !isScreenshotSafeUrl(src)) {
                        // file:// mode: local files frequently taint canvas export; drop all non-data/blob images.
                        const ph = clonedDoc.createElement('div');
                        const w = img.width || img.clientWidth || 0;
                        const h = img.height || img.clientHeight || 0;
                        if (w) ph.style.width = `${w}px`;
                        if (h) ph.style.height = `${h}px`;
                        ph.style.display = 'inline-block';
                        ph.style.background = 'rgba(255,255,255,0.06)';
                        ph.style.border = '1px solid rgba(255,255,255,0.08)';
                        ph.style.borderRadius = '4px';
                        ph.style.boxSizing = 'border-box';
                        img.replaceWith(ph);
                        continue;
                    }

                    // http/https mode: replace only truly cross-origin images.
                    let url;
                    try {
                        url = new URL(src, window.location.href);
                    } catch {
                        continue;
                    }
                    const isHttp = url.protocol === 'http:' || url.protocol === 'https:';
                    const isCrossOrigin = isHttp && url.origin !== window.location.origin;
                    if (isCrossOrigin && !isScreenshotSafeUrl(src)) {
                        const ph = clonedDoc.createElement('div');
                        const w = img.width || img.clientWidth || 0;
                        const h = img.height || img.clientHeight || 0;
                        if (w) ph.style.width = `${w}px`;
                        if (h) ph.style.height = `${h}px`;
                        ph.style.display = 'inline-block';
                        ph.style.background = 'rgba(255,255,255,0.06)';
                        ph.style.border = '1px solid rgba(255,255,255,0.08)';
                        ph.style.borderRadius = '4px';
                        ph.style.boxSizing = 'border-box';
                        img.replaceWith(ph);
                    } else {
                        // Best-effort: help CORS-friendly images remain exportable.
                        img.setAttribute('crossorigin', 'anonymous');
                    }
                }

                // 2) Elements that frequently taint or break rendering
                clonedDoc.querySelectorAll('video, iframe').forEach(el => el.remove());

                // 3) Background images via CSS (common tainting source, especially on file://)
                const win = clonedDoc.defaultView;
                if (win && win.getComputedStyle) {
                    const all = Array.from(clonedDoc.querySelectorAll('*'));
                    for (const el of all) {
                        const bg = win.getComputedStyle(el).backgroundImage;
                        if (!bg || !bg.includes('url(')) continue;
                        let hasUnsafe = false;
                        const nextBg = bg.replace(/url\(([^)]+)\)/g, (full, raw) => {
                            const cleaned = (raw || '').replace(/["']/g, '').trim();
                            const resolved = resolveScreenshotAssetUrl(cleaned);
                            const cached = screenshotAssetCache.get(resolved) || screenshotAssetCache.get(cleaned);
                            if (cached) return `url("${cached}")`;
                            if (isScreenshotSafeUrl(cleaned)) return full;
                            hasUnsafe = true;
                            return 'none';
                        });
                        if (hasUnsafe) {
                            el.style.backgroundImage = 'none';
                        } else if (nextBg !== bg) {
                            el.style.backgroundImage = nextBg;
                        }
                    }
                } else {
                    // Fallback: at least remove the wallpaper containers
                    clonedDoc.querySelectorAll('.desktop, .login-screen').forEach(el => {
                        el.style.backgroundImage = 'none';
                    });
                }
            } catch (e) {
                // Never fail screenshot because of sanitize pass
                console.warn('Screenshot sanitize failed:', e);
            }
        } : undefined
    });

    const blob = await new Promise((resolve, reject) => {
        try {
            canvas.toBlob((b) => {
                if (!b) reject(new Error('Failed to encode screenshot image.'));
                else resolve(b);
            }, 'image/png');
        } catch (e) {
            reject(e);
        }
    });
    if (!blob) throw new Error('Failed to encode screenshot image.');
    return blob;
}

function getLoggedInUsername() {
    const loggedInUser = localStorage.getItem('loggedInUser');
    if (!loggedInUser) return null;
    try {
        const user = JSON.parse(loggedInUser);
        return user && user.name ? user.name : null;
    } catch {
        return null;
    }
}

async function ensurePilkOsScreenshotsFolder(fs) {
    const username = getLoggedInUsername();
    // If no user is logged in, don't create a root-level /Pictures folder.
    // Instead, store screenshots in a temp location until a user signs in.
    const picturesPath = username ? `/Users/${username}/Pictures` : '/Temp Files';

    // Ensure Screenshots folder exists inside Pictures.
    const screenshotsPath = `${picturesPath}/Screenshots`;
    const existingScreenshots = await fs.getFolder(screenshotsPath);
    if (!existingScreenshots) {
        // Pictures folder should exist for logged-in users; create if missing just in case.
        const picturesFolder = await fs.getFolder(picturesPath);
        if (!picturesFolder) {
            if (username) {
                const parent = `/Users/${username}`;
                await fs.createFolder(parent, 'Pictures');
            } else {
                // Ensure /Temp Files exists (normally created during fs init, but keep this defensive)
                const tmp = await fs.getFolder('/Temp Files');
                if (!tmp) {
                    await fs.createFolder('/', 'Temp Files');
                }
            }
        }
        await fs.createFolder(picturesPath, 'Screenshots');
    }

    return screenshotsPath;
}

async function takeViewportScreenshotToPictures() {
    if (screenshotInProgress) return;
    screenshotInProgress = true;

    try {
        const filename = getScreenshotFileName();
        let blob;
        try {
            // file:// origins are extremely prone to canvas tainting; start in sanitized mode there.
            const isFileProtocol = window.location && window.location.protocol === 'file:';
            blob = await captureViewportPngBlob({ sanitize: isFileProtocol ? true : false });
        } catch (e) {
            // If canvas is tainted, retry with a sanitized capture that strips cross-origin images/backgrounds.
            const msg = (e && e.message) ? String(e.message) : String(e);
            if (msg.includes('Tainted canvases may not be exported') || msg.includes('tainted')) {
                blob = await captureViewportPngBlob({ sanitize: true });
            } else {
                throw e;
            }
        }

        try {
            const fs = await initFileSystem();
            const screenshotsPath = await ensurePilkOsScreenshotsFolder(fs);
            await fs.createFile(screenshotsPath, filename, blob, 'image');
            await refreshFileSystemViews(screenshotsPath);
            showNotification(`Saved to ${screenshotsPath}/${filename}`, 'success', 3500);
        } catch (err) {
            // If PilkOS filesystem is full/unavailable, fall back to a normal download.
            downloadBlob(blob, filename);
            showNotification('Saved screenshot to your Downloads folder (PilkOS Pictures\\Screenshots was unavailable).', 'warning', 4500);
            console.warn('Screenshot save-to-PilkOS-Pictures failed; downloaded instead:', err);
        }
    } catch (err) {
        console.error('Screenshot failed:', err);
        showNotification(`Screenshot failed: ${err && err.message ? err.message : String(err)}`, 'error', 5000);
    } finally {
        screenshotInProgress = false;
    }
}

function initScreenshotHotkey() {
    if (window.__pilkosScreenshotHotkeyInitialized) return;
    window.__pilkosScreenshotHotkeyInitialized = true;

    const isPrintScreenEvent = (e) => {
        // PrintScreen support varies a lot across browsers/platforms.
        // Common signals:
        // - e.code === 'PrintScreen'
        // - e.key === 'PrintScreen'
        // - legacy keyCode/which === 44
        return (
            e.code === 'PrintScreen' ||
            e.key === 'PrintScreen' ||
            e.key === 'PrtScr' ||
            e.key === 'PrtSc' ||
            e.keyCode === 44 ||
            e.which === 44
        );
    };

    const maybeHandleScreenshotHotkey = (e) => {
        // Ctrl + PrintScreen
        if (e && e.ctrlKey && isPrintScreenEvent(e)) {
            e.preventDefault();
            e.stopPropagation();
            takeViewportScreenshotToPictures();
        }
    };

    // Some environments only emit PrintScreen on keyup, and some only expose legacy keyCode.
    document.addEventListener('keydown', maybeHandleScreenshotHotkey, true);
    document.addEventListener('keyup', maybeHandleScreenshotHotkey, true);

    // Clipboard fallback: if PrintScreen is intercepted by the OS, users can paste the screenshot image.
    // (Windows often puts PrintScreen captures into the clipboard.)
    document.addEventListener('paste', async (e) => {
        try {
            const items = e.clipboardData && e.clipboardData.items ? Array.from(e.clipboardData.items) : [];
            const imageItem = items.find(i => i && i.type && i.type.startsWith('image/'));
            if (!imageItem) return;

            const blob = imageItem.getAsFile();
            if (!blob) return;

            const filename = getScreenshotFileName();
            const fs = await initFileSystem();
            const screenshotsPath = await ensurePilkOsScreenshotsFolder(fs);
            await fs.createFile(screenshotsPath, filename, blob, 'image');
            await refreshFileSystemViews(screenshotsPath);
            showNotification(`Saved pasted screenshot to ${screenshotsPath}/${filename}`, 'success', 3500);
        } catch (err) {
            console.warn('Paste-to-screenshot failed:', err);
        }
    }, true);
}

// Initialize Everything
// Disable browser's default right-click context menu
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

// Enable mouse wheel adjustments for all sliders (input[type="range"]).
// Works for both static and dynamically-created sliders via event delegation.
// Scroll down decreases, scroll up increases (matches volume menu behavior).
if (!window.__pilkosRangeWheelSupportInstalled) {
    window.__pilkosRangeWheelSupportInstalled = true;

    const clampNumber = (n, min, max) => {
        const nn = Number(n);
        if (!Number.isFinite(nn)) return min;
        return Math.max(min, Math.min(max, nn));
    };

    const getStepForRange = (el) => {
        const stepAttr = (el.getAttribute('step') || '').trim();
        if (stepAttr && stepAttr !== 'any') {
            const s = Number(stepAttr);
            if (Number.isFinite(s) && s > 0) return s;
        }
        const min = Number(el.min);
        const max = Number(el.max);
        if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
            const derived = (max - min) / 100;
            if (Number.isFinite(derived) && derived > 0) return derived;
        }
        return 1;
    };

    const decimalsForStep = (step) => {
        const s = String(step);
        const idx = s.indexOf('.');
        return idx >= 0 ? (s.length - idx - 1) : 0;
    };

    document.addEventListener('wheel', (e) => {
        try {
            const t = e.target;
            if (!(t instanceof Element)) return;
            const range = t.closest('input[type="range"]');
            if (!range) return;
            if (range.disabled) return;

            // Only handle meaningful wheel deltas.
            const deltaY = typeof e.deltaY === 'number' ? e.deltaY : 0;
            if (!deltaY) return;

            e.preventDefault();
            e.stopPropagation();

            const min = range.min !== '' ? Number(range.min) : 0;
            const max = range.max !== '' ? Number(range.max) : 100;
            const step = getStepForRange(range);
            const current = range.value !== '' ? Number(range.value) : 0;
            const dir = deltaY > 0 ? -1 : 1;

            // Nudge value and clamp.
            let next = current + (dir * step);
            next = clampNumber(next, Number.isFinite(min) ? min : -Infinity, Number.isFinite(max) ? max : Infinity);

            // Avoid float drift for fractional steps.
            const decimals = decimalsForStep(step);
            if (decimals > 0 && Number.isFinite(next)) {
                next = Number(next.toFixed(decimals));
            } else if (Number.isFinite(next)) {
                next = Math.round(next);
            }

            if (!Number.isFinite(next) || String(next) === range.value) return;

            range.value = String(next);
            range.dispatchEvent(new Event('input', { bubbles: true }));
            range.dispatchEvent(new Event('change', { bubbles: true }));
        } catch (err) {
            // Never block scroll due to unexpected slider issues.
        }
    }, { passive: false, capture: true });
}

document.addEventListener('DOMContentLoaded', async function() {
    // Decide whether to show the boot screen:
    // - Show on cold start (no persistent state in localStorage + CacheStorage)
    // - Show when explicitly requested via Restart
    const shouldShowBoot = async () => {
        // Explicit restart requests boot exactly once.
        try {
            const forced = sessionStorage.getItem('forceBootOnce');
            if (forced === '1') {
                sessionStorage.removeItem('forceBootOnce');
                return true;
            }
        } catch (e) {}

        // Cold start: no non-trivial localStorage keys and no CacheStorage entries.
        let hasLocalStorageData = false;
        try {
            const ignoreKeys = new Set(['appVersion']);
            for (let i = 0; i < localStorage.length; i++) {
                const k = localStorage.key(i);
                if (k && !ignoreKeys.has(k)) {
                    hasLocalStorageData = true;
                    break;
                }
            }
        } catch (e) {
            // If storage is unavailable, avoid showing the boot splash loop.
            hasLocalStorageData = true;
        }

        let hasCacheStorageData = false;
        try {
            if (typeof caches !== 'undefined' && caches && typeof caches.keys === 'function') {
                const keys = await caches.keys();
                hasCacheStorageData = Array.isArray(keys) && keys.length > 0;
            }
        } catch (e) {}

        return !hasLocalStorageData && !hasCacheStorageData;
    };

    // Current PilkOS version (used by Settings > About footer).
    // Keep this in sync with any UI that displays the OS version.
    const appVersion = { major: 0, minor: 1, patch: 3 };
    
    // Browser tab title (always include lowercase v)
    document.title = `PilkOS v${appVersion.major}.${appVersion.minor}.${appVersion.patch}`;

    // Hotkey should work regardless of login state.
    initScreenshotHotkey();

    const boot = document.getElementById('boot-screen');
    const loginScreen = document.getElementById('login-screen');
    const desktop = document.getElementById('desktop');

    const showBoot = await shouldShowBoot();

    // Now that we've decided whether this is a cold boot, persist appVersion (so future loads skip boot).
    try {
        localStorage.setItem('appVersion', JSON.stringify(appVersion));
    } catch (e) {
        // ignore storage errors
    }

    if (showBoot) {
        // Boot splash (about 10s), then proceed to login.
        await runBootSequence({ durationMs: BOOT_DURATION_MS });
        initLoginScreen();
        return;
    }

    // Skip boot: hide the boot screen immediately (it may be visible by default in HTML).
    if (boot) {
        boot.classList.remove('boot-show');
        boot.classList.add('boot-hide');
        boot.style.display = 'none';
    }

    // If browser refresh occurs while previously logged in, resume directly to desktop.
    let persistedUser = null;
    try {
        const raw = localStorage.getItem('loggedInUser');
        persistedUser = raw ? JSON.parse(raw) : null;
    } catch (e) {
        persistedUser = null;
    }

    if (persistedUser && desktop) {
        currentUser = persistedUser;
        if (loginScreen) {
            loginScreen.classList.add('hidden');
            loginScreen.style.display = 'none';
            loginScreen.style.pointerEvents = 'none';
        }
        desktop.style.display = 'flex';
        desktop.style.pointerEvents = 'auto';

        // Initialize desktop components if not already initialized.
        const isInitialized = desktop.hasAttribute('data-initialized');
        const isInitializing = desktop.hasAttribute('data-initializing');
        if (!isInitialized && !isInitializing) {
            setTimeout(() => {
                try { initDesktop(); } catch (e) {}
            }, 50);
        }
        return;
    }

    // Not logged in: show login screen without boot.
    initLoginScreen();
});

// Initialize desktop components
// Auto Brightness Initialization (Global)
let globalBrightnessOverlay = null;
let globalAutoBrightnessInterval = null;

// Night Light Initialization (Global)
let globalNightLightOverlay = null;

function initAutoBrightness() {
    // Create brightness overlay if it doesn't exist
    globalBrightnessOverlay = document.getElementById('auto-brightness-overlay');
    if (!globalBrightnessOverlay) {
        globalBrightnessOverlay = document.createElement('div');
        globalBrightnessOverlay.id = 'auto-brightness-overlay';
        globalBrightnessOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; z-index: 999999; transition: opacity 0.5s ease; opacity: 0;';
        document.body.appendChild(globalBrightnessOverlay);
    }
    
    // Function to calculate brightness based on time of day
    function calculateTimeBasedBrightness() {
        const now = new Date();
        const hour = now.getHours();
        
        let brightness;
        if (hour >= 6 && hour < 8) {
            const progress = (hour - 6) / 2;
            brightness = 30 + (progress * 40);
        } else if (hour >= 8 && hour < 18) {
            if (hour < 12) {
                const progress = (hour - 8) / 4;
                brightness = 70 + (progress * 30);
            } else {
                const progress = (18 - hour) / 6;
                brightness = 70 + (progress * 30);
            }
        } else if (hour >= 18 && hour < 22) {
            const progress = (hour - 18) / 4;
            brightness = 70 - (progress * 20);
        } else {
            const progress = hour >= 22 
                ? (hour - 22) / 8
                : (hour + 2) / 8;
            brightness = 50 - (Math.min(progress, 1) * 20);
        }
        
        return Math.max(30, Math.min(100, Math.round(brightness)));
    }
    
    // Function to apply brightness to the page
    function applyBrightness(value) {
        // Ensure value is a number
        const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
        const opacity = ((100 - numValue) / 100) * 0.8;
        
        // Ensure overlay exists, create if it doesn't
        if (!globalBrightnessOverlay) {
            globalBrightnessOverlay = document.getElementById('auto-brightness-overlay');
            if (!globalBrightnessOverlay) {
                globalBrightnessOverlay = document.createElement('div');
                globalBrightnessOverlay.id = 'auto-brightness-overlay';
                globalBrightnessOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; z-index: 999999; transition: opacity 0.5s ease; opacity: 0;';
                document.body.appendChild(globalBrightnessOverlay);
            }
        }
        
        if (globalBrightnessOverlay) {
            globalBrightnessOverlay.style.opacity = opacity.toString();
        }
        
        // Update slider and display if they exist (when Settings window is open)
        const brightnessSlider = document.querySelector('#display-brightness');
        const brightnessValue = document.querySelector('#display-brightness-value');
        if (brightnessSlider && brightnessValue) {
            brightnessSlider.value = numValue;
            brightnessValue.textContent = numValue + '%';
            brightnessSlider.style.setProperty('--slider-percent', numValue + '%');
            localStorage.setItem('displayBrightness', numValue.toString());
        } else {
            // Still save to localStorage even if slider doesn't exist
            localStorage.setItem('displayBrightness', numValue.toString());
        }

        const quickBrightnessSlider = document.querySelector('#quick-brightness-slider');
        if (quickBrightnessSlider) {
            quickBrightnessSlider.value = numValue;
            quickBrightnessSlider.style.setProperty('--volume-percent', numValue + '%');
        }
    }
    
    // Function to update auto-brightness
    function updateAutoBrightness() {
        const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
        if (autoBrightnessEnabled) {
            const brightness = calculateTimeBasedBrightness();
            applyBrightness(brightness);
        }
    }
    
    // Clear existing interval if any
    if (globalAutoBrightnessInterval) {
        clearInterval(globalAutoBrightnessInterval);
    }
    
    // Set up interval to update auto-brightness every minute
    globalAutoBrightnessInterval = setInterval(updateAutoBrightness, 60000);
    
    // Initial update if auto is enabled
    const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
    if (autoBrightnessEnabled) {
        updateAutoBrightness();
    } else {
        // Apply saved manual brightness if auto is disabled
        const savedBrightness = localStorage.getItem('displayBrightness') || '80';
        applyBrightness(parseInt(savedBrightness));
    }
    
    // Make functions available globally for Settings window to use
    window.calculateTimeBasedBrightness = calculateTimeBasedBrightness;
    window.applyBrightness = applyBrightness;
    window.updateAutoBrightness = updateAutoBrightness;
}

function initNightLight() {
    // Create night light overlay if it doesn't exist
    globalNightLightOverlay = document.getElementById('night-light-overlay');
    if (!globalNightLightOverlay) {
        globalNightLightOverlay = document.createElement('div');
        globalNightLightOverlay.id = 'night-light-overlay';
        globalNightLightOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 165, 0, 0.15); pointer-events: none; z-index: 999998; transition: opacity 0.5s ease; opacity: 0; mix-blend-mode: multiply;';
        document.body.appendChild(globalNightLightOverlay);
    }
    
    // Function to apply/remove night light filter
    function applyNightLight(enabled) {
        // Ensure overlay exists, create if it doesn't
        if (!globalNightLightOverlay) {
            globalNightLightOverlay = document.getElementById('night-light-overlay');
            if (!globalNightLightOverlay) {
                globalNightLightOverlay = document.createElement('div');
                globalNightLightOverlay.id = 'night-light-overlay';
                globalNightLightOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 165, 0, 0.15); pointer-events: none; z-index: 999998; transition: opacity 0.5s ease; opacity: 0; mix-blend-mode: multiply;';
                document.body.appendChild(globalNightLightOverlay);
            }
        }
        
        if (globalNightLightOverlay) {
            globalNightLightOverlay.style.opacity = enabled ? '1' : '0';
        }
    }
    
    // Check saved preference and apply
    const nightLightEnabled = localStorage.getItem('nightLightEnabled') === 'true';
    applyNightLight(nightLightEnabled);
    
    // Make function available globally for Settings window to use
    window.applyNightLight = applyNightLight;
}

// Quick Settings Menu (Volume, Wi-Fi, Bluetooth, Battery)
function initQuickSettings() {
    const quickSettingsIcon = document.getElementById('quick-settings-icon');
    const quickSettingsMenu = document.getElementById('quick-settings-menu');
    if (!quickSettingsIcon || !quickSettingsMenu) return;

    const quickControlItem = quickSettingsIcon.closest('.dock-control-item');
    if (!quickControlItem) return;

    if (!quickControlItem.hasAttribute('data-quick-settings-listener')) {
        quickControlItem.setAttribute('data-quick-settings-listener', 'true');
    }

    const quickVolumeSlider = document.getElementById('quick-volume-slider');
    let quickVolumeTooltip = document.getElementById('quick-volume-tooltip');
    const quickVolumeSliderWrap = quickVolumeSlider ? quickVolumeSlider.closest('.quick-settings-slider') : null;
    const quickVolumeValue = document.getElementById('quick-volume-value');
    const quickVolumeMute = document.getElementById('quick-volume-mute');
    const quickVolumeMuteIcon = quickVolumeMute ? quickVolumeMute.querySelector('svg') : null;
    const quickBrightnessSlider = document.getElementById('quick-brightness-slider');
    const quickBrightnessTooltip = document.getElementById('quick-brightness-tooltip');
    const quickBrightnessSliderWrap = quickBrightnessSlider ? quickBrightnessSlider.closest('.quick-settings-slider') : null;
    const quickNightLightButton = document.getElementById('quick-night-light-button');
    const quickAutoBrightnessButton = document.getElementById('quick-auto-brightness-button');
    const mainVolumeSlider = document.getElementById('volume-slider');
    const quickAudioDevicesToggle = document.getElementById('quick-audio-devices-toggle');
    const quickAudioOutputDevice = document.getElementById('quick-audio-output-device');
    const quickAudioInputDevice = document.getElementById('quick-audio-input-device');
    const quickAudioBack = document.getElementById('quick-audio-back');
    const quickSettingsMainView = document.getElementById('quick-settings-main-view');
    const quickAudioView = document.getElementById('quick-audio-view');
    const quickWifiView = document.getElementById('quick-wifi-view');
    const quickBluetoothView = document.getElementById('quick-bluetooth-view');
    const quickSettingsOpenSettings = document.getElementById('quick-settings-open-settings');
    const quickSettingsEditToggle = document.getElementById('quick-settings-edit-toggle');
    const quickSettingsTilesWrap = quickSettingsMenu.querySelector('.quick-settings-tiles');
    const quickSettingsEditPanel = document.getElementById('quick-settings-edit-panel');
    const quickSettingsEditAvailable = document.getElementById('quick-settings-edit-available');
    const quickSettingsWifiView = document.getElementById('quick-settings-wifi-view');
    const quickSettingsBluetoothView = document.getElementById('quick-settings-bluetooth-view');
    const quickSettingsWifiBack = document.getElementById('quick-settings-wifi-back');
    const quickSettingsBluetoothBack = document.getElementById('quick-settings-bluetooth-back');

    const quickWifiToggle = document.getElementById('quick-wifi-toggle');
    const quickWifiStatus = document.getElementById('quick-wifi-status');
    const quickWifiList = document.getElementById('quick-wifi-list');
    const quickWifiRefresh = document.getElementById('quick-wifi-refresh');
    const wifiToggleBtn = document.getElementById('wifi-toggle-btn');
    const wifiRefreshBtn = document.getElementById('wifi-refresh-btn');
    const quickWifiDevicesToggle = document.getElementById('quick-wifi-devices-toggle');
    const quickWifiBack = document.getElementById('quick-wifi-back');

    const quickBluetoothToggle = document.getElementById('quick-bluetooth-toggle');
    const quickBluetoothStatus = document.getElementById('quick-bluetooth-status');
    const quickBluetoothList = document.getElementById('quick-bluetooth-list');
    const quickBluetoothRefresh = document.getElementById('quick-bluetooth-refresh');
    const bluetoothToggleBtn = document.getElementById('bluetooth-toggle-btn');
    const bluetoothRefreshBtn = document.getElementById('bluetooth-refresh-btn');
    const quickBluetoothDevicesToggle = document.getElementById('quick-bluetooth-devices-toggle');
    const quickBluetoothBack = document.getElementById('quick-bluetooth-back');

    const quickBatteryPercent = document.getElementById('quick-battery-percent');
    const quickBatteryTime = document.getElementById('quick-battery-time');
    const batteryMenuTime = document.getElementById('battery-menu-time');
    const quickAirplaneToggle = document.getElementById('quick-airplane-toggle');
    const quickAirplaneStatus = document.getElementById('quick-airplane-status');
    const quickBatteryPlansToggle = document.getElementById('quick-battery-plans-toggle');
    const quickBatteryView = document.getElementById('quick-battery-view');
    const quickBatteryBack = document.getElementById('quick-battery-back');
    const quickBatteryPlans = quickBatteryView ? quickBatteryView.querySelectorAll('.quick-settings-plan') : [];
    const quickResolutionToggle = document.getElementById('quick-resolution-toggle');
    const quickResolutionStatus = document.getElementById('quick-resolution-status');
    const quickResolutionOptionsToggle = document.getElementById('quick-resolution-options-toggle');
    const quickResolutionView = document.getElementById('quick-resolution-view');
    const quickResolutionBack = document.getElementById('quick-resolution-back');
    const quickResolutionList = document.getElementById('quick-resolution-list');
    const quickResolutionOptions = quickResolutionList
        ? Array.from(quickResolutionList.querySelectorAll('[data-resolution]'))
        : [];
    let quickSettingsLiveTimer = null;

    const QUICK_SETTINGS_TILE_ORDER_KEY = 'quickSettingsTileOrder';
    const QUICK_SETTINGS_TILE_HIDDEN_KEY = 'quickSettingsTileHidden';
    const QUICK_SETTINGS_TILE_DEFAULTS_KEY = 'quickSettingsTileDefaultsApplied';
    const QUICK_SETTINGS_RESOLUTION_KEY = 'pilkOsResolution';
    let quickSettingsEditMode = false;
    let quickSettingsDraggedTile = null;

    function getBooleanFromStorage(key, defaultValue) {
        let raw = null;
        try { raw = localStorage.getItem(key); } catch (e) {}
        if (raw === null || raw === undefined) return defaultValue;
        return raw === 'true';
    }

    function parseJsonArray(value) {
        if (!value) return [];
        try {
            const parsed = JSON.parse(value);
            return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
            return [];
        }
    }

    function parseResolutionOption(button) {
        if (!button) return null;
        const id = button.dataset.resolution || '';
        if (!id) return null;
        const width = parseInt(button.dataset.width, 10);
        const height = parseInt(button.dataset.height, 10);
        return {
            id,
            label: (button.textContent || '').trim() || id,
            width: Number.isFinite(width) ? width : null,
            height: Number.isFinite(height) ? height : null
        };
    }

    const resolutionOptions = quickResolutionOptions
        .map(parseResolutionOption)
        .filter(option => option && option.id);

    function getStoredResolutionId() {
        try {
            return localStorage.getItem(QUICK_SETTINGS_RESOLUTION_KEY) || 'auto';
        } catch (e) {
            return 'auto';
        }
    }

    function setStoredResolutionId(id) {
        try {
            localStorage.setItem(QUICK_SETTINGS_RESOLUTION_KEY, id);
        } catch (e) {}
    }

    function getResolutionOptionById(id) {
        if (!resolutionOptions.length) {
            return { id: 'auto', label: 'Auto', width: null, height: null };
        }
        const match = resolutionOptions.find(option => option.id === id);
        if (match) return match;
        return resolutionOptions.find(option => option.id === 'auto') || resolutionOptions[0];
    }

    function applyResolutionOption(option) {
        const target = option || getResolutionOptionById(getStoredResolutionId());
        if (!target || !target.width || !target.height) {
            return;
        }
        if (window.pilkOSWindow && typeof window.pilkOSWindow.setSize === 'function') {
            window.pilkOSWindow.setSize(target.width, target.height);
            return;
        }
        if (typeof window.resizeTo === 'function') {
            try {
                window.resizeTo(target.width, target.height);
            } catch (e) {}
        }
    }

    function updateQuickResolutionStatus(option) {
        if (!quickResolutionStatus) return;
        const target = option || getResolutionOptionById(getStoredResolutionId());
        if (!target || target.id === 'auto') {
            const width = Math.max(1, Math.round(window.innerWidth || 0));
            const height = Math.max(1, Math.round(window.innerHeight || 0));
            if (width > 1 && height > 1) {
                quickResolutionStatus.textContent = `Auto (${width} x ${height})`;
            } else {
                quickResolutionStatus.textContent = 'Auto';
            }
            return;
        }
        if (!target.width || !target.height) {
            quickResolutionStatus.textContent = 'Auto';
            return;
        }
        quickResolutionStatus.textContent = `${target.width} x ${target.height}`;
    }

    function updateQuickResolutionSelection(option) {
        const target = option || getResolutionOptionById(getStoredResolutionId());
        if (!target) return;
        quickResolutionOptions.forEach((button) => {
            button.classList.toggle('active', button.dataset.resolution === target.id);
        });
        updateQuickResolutionStatus(target);
    }

    function isQuickSettingsEditing() {
        return quickSettingsMenu.classList.contains('edit-mode');
    }

    function getQuickSettingsTiles() {
        if (!quickSettingsTilesWrap) return [];
        return Array.from(quickSettingsTilesWrap.querySelectorAll('.quick-settings-tile'));
    }

    function getTileId(tile) {
        return tile ? tile.dataset.quickTile || '' : '';
    }

    function isTileRemovable(tile) {
        if (!tile) return false;
        if (!tile.classList.contains('quick-settings-tile-static')) return true;
        return tile.dataset.quickTile === 'battery';
    }

    function ensureTileRemoveButton(tile) {
        if (!isTileRemovable(tile)) return;
        if (tile.querySelector('.quick-settings-tile-remove')) return;
        const label = tile.querySelector('.quick-settings-tile-label');
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'quick-settings-tile-remove';
        removeBtn.setAttribute('aria-label', `Remove ${label ? label.textContent : 'tile'}`);
        removeBtn.innerHTML = `
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        `;
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            hideQuickSettingsTile(tile);
        });
        tile.appendChild(removeBtn);
    }

    function saveQuickSettingsTileLayout() {
        if (!quickSettingsTilesWrap) return;
        const tiles = getQuickSettingsTiles();
        const order = tiles.map(tile => getTileId(tile)).filter(Boolean);
        const hidden = tiles
            .filter(tile => tile.classList.contains('quick-settings-tile-hidden'))
            .map(tile => getTileId(tile))
            .filter(Boolean);
        try {
            localStorage.setItem(QUICK_SETTINGS_TILE_ORDER_KEY, JSON.stringify(order));
            localStorage.setItem(QUICK_SETTINGS_TILE_HIDDEN_KEY, JSON.stringify(hidden));
        } catch (e) {}
    }

    function applyQuickSettingsTileLayout() {
        if (!quickSettingsTilesWrap) return;
        const tiles = getQuickSettingsTiles();
        const tileMap = new Map();
        tiles.forEach((tile) => {
            const id = getTileId(tile);
            if (id) tileMap.set(id, tile);
        });

        const savedOrder = parseJsonArray(localStorage.getItem(QUICK_SETTINGS_TILE_ORDER_KEY));
        savedOrder.forEach((id) => {
            const tile = tileMap.get(id);
            if (tile) quickSettingsTilesWrap.appendChild(tile);
        });
        tiles.forEach((tile) => {
            if (!savedOrder.includes(getTileId(tile))) {
                quickSettingsTilesWrap.appendChild(tile);
            }
        });

        let hiddenStorage = null;
        let defaultsStorage = null;
        try { hiddenStorage = localStorage.getItem(QUICK_SETTINGS_TILE_HIDDEN_KEY); } catch (e) {}
        try { defaultsStorage = localStorage.getItem(QUICK_SETTINGS_TILE_DEFAULTS_KEY); } catch (e) {}
        const hidden = new Set(parseJsonArray(hiddenStorage));
        const defaultsApplied = new Set(parseJsonArray(defaultsStorage));
        let defaultsChanged = false;

        tiles.forEach((tile) => {
            const id = getTileId(tile);
            if (!id || tile.dataset.quickDefaultHidden !== 'true') return;
            if (!defaultsApplied.has(id)) {
                hidden.add(id);
                defaultsApplied.add(id);
                defaultsChanged = true;
            }
        });

        if (defaultsChanged) {
            try {
                localStorage.setItem(QUICK_SETTINGS_TILE_HIDDEN_KEY, JSON.stringify(Array.from(hidden)));
                localStorage.setItem(QUICK_SETTINGS_TILE_DEFAULTS_KEY, JSON.stringify(Array.from(defaultsApplied)));
            } catch (e) {}
        }
        tiles.forEach((tile) => {
            const shouldHide = hidden.has(getTileId(tile));
            tile.classList.toggle('quick-settings-tile-hidden', shouldHide);
        });

        tiles.forEach((tile) => ensureTileRemoveButton(tile));
        refreshQuickSettingsAvailableTiles();
    }

    function refreshQuickSettingsAvailableTiles() {
        if (!quickSettingsEditAvailable) return;
        const tiles = getQuickSettingsTiles();
        const hiddenTiles = tiles.filter(tile => tile.classList.contains('quick-settings-tile-hidden'));
        quickSettingsEditAvailable.innerHTML = '';

        if (!hiddenTiles.length) {
            const empty = document.createElement('div');
            empty.className = 'quick-settings-add-tile is-disabled';
            empty.textContent = 'No Hidden Tiles';
            quickSettingsEditAvailable.appendChild(empty);
            return;
        }

        hiddenTiles.forEach((tile) => {
            const tileId = getTileId(tile);
            if (!tileId) return;
            const label = tile.querySelector('.quick-settings-tile-label');
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'quick-settings-add-tile';
            addBtn.textContent = `${label ? label.textContent : 'Tile'}`;
            addBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showQuickSettingsTile(tile);
            });
            quickSettingsEditAvailable.appendChild(addBtn);
        });
    }

    function showQuickSettingsTile(tile) {
        tile.classList.remove('quick-settings-tile-hidden');
        tile.setAttribute('draggable', quickSettingsEditMode ? 'true' : 'false');
        if (quickSettingsTilesWrap) {
            quickSettingsTilesWrap.appendChild(tile);
        }
        saveQuickSettingsTileLayout();
        refreshQuickSettingsAvailableTiles();
    }

    function hideQuickSettingsTile(tile) {
        if (!isTileRemovable(tile)) return;
        tile.classList.add('quick-settings-tile-hidden');
        tile.setAttribute('draggable', 'false');
        saveQuickSettingsTileLayout();
        refreshQuickSettingsAvailableTiles();
    }

    function setQuickSettingsEditMode(enabled) {
        quickSettingsEditMode = enabled;
        quickSettingsMenu.classList.toggle('edit-mode', enabled);
        if (quickSettingsEditToggle) {
            quickSettingsEditToggle.classList.toggle('active', enabled);
            quickSettingsEditToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        }
        if (quickSettingsEditPanel) {
            quickSettingsEditPanel.setAttribute('aria-hidden', enabled ? 'false' : 'true');
        }
        getQuickSettingsTiles().forEach((tile) => {
            const hidden = tile.classList.contains('quick-settings-tile-hidden');
            tile.setAttribute('draggable', enabled && !hidden ? 'true' : 'false');
        });
        refreshQuickSettingsAvailableTiles();
    }

    function setupQuickSettingsTileDragAndDrop() {
        if (!quickSettingsTilesWrap) return;
        const tiles = getQuickSettingsTiles();
        tiles.forEach((tile) => {
            tile.addEventListener('dragstart', (e) => {
                if (!quickSettingsEditMode || tile.classList.contains('quick-settings-tile-hidden')) {
                    e.preventDefault();
                    return;
                }
                quickSettingsDraggedTile = tile;
                tile.classList.add('dragging');
                if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', getTileId(tile));
                }
            });
            tile.addEventListener('dragend', () => {
                if (quickSettingsDraggedTile) {
                    quickSettingsDraggedTile.classList.remove('dragging');
                }
                quickSettingsDraggedTile = null;
                saveQuickSettingsTileLayout();
            });
        });

        quickSettingsTilesWrap.addEventListener('dragover', (e) => {
            if (!quickSettingsEditMode) return;
            e.preventDefault();
            if (!quickSettingsDraggedTile) return;
            const targetTile = e.target.closest('.quick-settings-tile');
            if (!targetTile || targetTile === quickSettingsDraggedTile) return;
            if (targetTile.classList.contains('quick-settings-tile-hidden')) return;
            const visibleTiles = getQuickSettingsTiles().filter(tile => !tile.classList.contains('quick-settings-tile-hidden'));
            const targetIndex = visibleTiles.indexOf(targetTile);
            const draggedIndex = visibleTiles.indexOf(quickSettingsDraggedTile);
            if (targetIndex === -1 || draggedIndex === -1) return;
            if (targetIndex > draggedIndex) {
                quickSettingsTilesWrap.insertBefore(quickSettingsDraggedTile, targetTile.nextSibling);
            } else {
                quickSettingsTilesWrap.insertBefore(quickSettingsDraggedTile, targetTile);
            }
        });

        quickSettingsTilesWrap.addEventListener('drop', (e) => {
            if (!quickSettingsEditMode) return;
            e.preventDefault();
            saveQuickSettingsTileLayout();
        });
    }

    applyQuickSettingsTileLayout();
    setupQuickSettingsTileDragAndDrop();
    applyResolutionOption(getResolutionOptionById(getStoredResolutionId()));
    updateQuickResolutionSelection();

    if (quickSettingsEditToggle) {
        quickSettingsEditToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            setQuickSettingsEditMode(!quickSettingsEditMode);
        });
    }

    let lastHostWiFiFetchAt = 0;
    let hostWiFiFetchInFlight = null;

    function getMockWiFiNetworks() {
        const baseNetworks = [
            { name: 'Andromeda-5G', secured: true, signal: 4 },
            { name: 'PilkOS Guest', secured: false, signal: 3 },
            { name: 'Office Mesh', secured: true, signal: 3 },
            { name: 'Cafe WiFi', secured: false, signal: 2 },
            { name: 'Horizon-24G', secured: true, signal: 2 },
            { name: 'Library Net', secured: false, signal: 2 },
            { name: 'Warehouse AP', secured: true, signal: 1 },
            { name: 'Neighbor WiFi', secured: true, signal: 1 },
            { name: 'Guest Network', secured: false, signal: 1 },
        ];

        // Simulate scanning by rotating and jittering signal levels.
        const now = Date.now();
        const sliceSize = 7;
        const offset = Math.floor((now / 4000) % baseNetworks.length);
        const rotated = baseNetworks.slice(offset).concat(baseNetworks.slice(0, offset));
        const visible = rotated.slice(0, sliceSize);

        return visible.map((network, index) => {
            const jitter = ((now / 1500 + index) % 3) - 1; // -1, 0, 1
            const nextSignal = Math.max(0, Math.min(4, (network.signal || 2) + jitter));
            return {
                ...network,
                signal: nextSignal,
                connected: false,
            };
        });
    }

    function getConnectedWifiSsid() {
        try {
            const raw = localStorage.getItem('connectedWifiSsid');
            return raw ? String(raw) : '';
        } catch (e) {
            return '';
        }
    }

    function setConnectedWifiSsid(ssid) {
        try {
            if (!ssid) {
                localStorage.removeItem('connectedWifiSsid');
            } else {
                localStorage.setItem('connectedWifiSsid', String(ssid));
            }
        } catch (e) {}
    }

    function normalizeWifiSignal(signalLevel) {
        if (typeof signalLevel !== 'number' || isNaN(signalLevel)) return null;
        if (signalLevel <= 0) {
            if (signalLevel >= -50) return 4;
            if (signalLevel >= -60) return 3;
            if (signalLevel >= -70) return 2;
            if (signalLevel >= -80) return 1;
            return 0;
        }
        if (signalLevel >= 80) return 4;
        if (signalLevel >= 60) return 3;
        if (signalLevel >= 40) return 2;
        if (signalLevel >= 20) return 1;
        return 0;
    }

    function mapHostNetwork(network) {
        const name = (network && (network.ssid || network.SSID || network.name)) || 'Unknown Network';
        const signalLevel = typeof network.signal_level === 'number'
            ? network.signal_level
            : (typeof network.quality === 'number' ? network.quality : null);
        const securityRaw = String(network.security || network.security_flags || network.encryption || '').toLowerCase();
        const secured = securityRaw !== '' && securityRaw !== 'none' && securityRaw !== 'open' && securityRaw !== 'nopass';
        return {
            name,
            secured,
            signal: normalizeWifiSignal(signalLevel),
            connected: false,
        };
    }

    function refreshHostWiFiNetworks() {
        // Always use mock data for now.
        const connectedSsid = getConnectedWifiSsid();
        const mock = getMockWiFiNetworks().map((network) => ({
            ...network,
            connected: connectedSsid && network.name === connectedSsid,
        }));
        window.currentWiFiNetworks = mock;
        return Promise.resolve(mock);
    }

    function ensureQuickVolumeTooltipFloating() {
        if (!quickVolumeTooltip) {
            quickVolumeTooltip = document.createElement('div');
            quickVolumeTooltip.id = 'quick-volume-tooltip';
            quickVolumeTooltip.className = 'tooltip quick-volume-tooltip';
            document.body.appendChild(quickVolumeTooltip);
        }
        if (quickVolumeTooltip.dataset.floating === 'true') return;
        document.body.appendChild(quickVolumeTooltip);
        quickVolumeTooltip.dataset.floating = 'true';
        quickVolumeTooltip.style.display = 'block';
    }

    function setQuickVolumeTooltip(value) {
        if (!quickVolumeTooltip) return;
        ensureQuickVolumeTooltipFloating();
        const rawValue = typeof value === 'number' ? value : parseInt(quickVolumeSlider ? quickVolumeSlider.value : '0');
        const clamped = isNaN(rawValue) ? 0 : Math.max(0, Math.min(100, rawValue));
        quickVolumeTooltip.textContent = `${clamped}`;
        if (quickVolumeSliderWrap) {
            quickVolumeSliderWrap.style.setProperty('--volume-percent', `${clamped}%`);
        }
        if (quickVolumeSlider) {
            quickVolumeSlider.removeAttribute('title');
            quickVolumeSlider.setAttribute('aria-valuetext', `${clamped}%`);
            const sliderRect = quickVolumeSlider.getBoundingClientRect();
            const left = sliderRect.left + (sliderRect.width / 2);
            const top = sliderRect.top - 10;
            quickVolumeTooltip.style.left = `${left}px`;
            quickVolumeTooltip.style.top = `${top}px`;
        }
    }

    function updateQuickVolume() {
        if (!quickVolumeSlider || !quickVolumeValue) return;
        let volume = NaN;
        let muted = false;
        try {
            const stored = parseInt(localStorage.getItem('volumeLevel'));
            if (!isNaN(stored)) volume = stored;
            muted = localStorage.getItem('volumeMuted') === 'true';
        } catch (e) {}

        if (isNaN(volume) && mainVolumeSlider) {
            volume = parseInt(mainVolumeSlider.value);
        }
        if (isNaN(volume)) {
            volume = 70;
        }
        if (muted) {
            volume = 0;
        }

        quickVolumeSlider.value = volume;
        quickVolumeSlider.style.setProperty('--volume-percent', `${volume}%`);
        if (quickVolumeSliderWrap) {
            quickVolumeSliderWrap.style.setProperty('--volume-percent', `${volume}%`);
        }
        quickVolumeValue.textContent = muted || volume === 0 ? 'Muted' : `${volume}%`;
        setQuickVolumeTooltip(volume);
        if (quickVolumeMute) {
            quickVolumeMute.setAttribute('aria-pressed', muted ? 'true' : 'false');
        }
        if (quickVolumeMuteIcon) {
            quickVolumeMuteIcon.innerHTML = '';
            const speaker = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            speaker.setAttribute('points', '11 5 6 9 2 9 2 15 6 15 11 19 11 5');
            speaker.setAttribute('fill', 'none');
            speaker.setAttribute('stroke', 'currentColor');
            speaker.setAttribute('stroke-width', '2');
            speaker.setAttribute('stroke-linecap', 'round');
            speaker.setAttribute('stroke-linejoin', 'round');
            quickVolumeMuteIcon.appendChild(speaker);

            if (muted || volume === 0) {
                const muteLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                muteLine.setAttribute('x1', '3');
                muteLine.setAttribute('y1', '6');
                muteLine.setAttribute('x2', '18');
                muteLine.setAttribute('y2', '18');
                muteLine.setAttribute('stroke', 'currentColor');
                muteLine.setAttribute('stroke-width', '2');
                muteLine.setAttribute('stroke-linecap', 'round');
                quickVolumeMuteIcon.appendChild(muteLine);
            } else {
                const wave1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                wave1.setAttribute('d', 'M15.54 8.46a5 5 0 0 1 0 7.07');
                wave1.setAttribute('fill', 'none');
                wave1.setAttribute('stroke', 'currentColor');
                wave1.setAttribute('stroke-width', '2');
                wave1.setAttribute('stroke-linecap', 'round');
                quickVolumeMuteIcon.appendChild(wave1);

                if (volume > 50) {
                    const wave2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    wave2.setAttribute('d', 'M19.07 4.93a10 10 0 0 1 0 14.14');
                    wave2.setAttribute('fill', 'none');
                    wave2.setAttribute('stroke', 'currentColor');
                    wave2.setAttribute('stroke-width', '2');
                    wave2.setAttribute('stroke-linecap', 'round');
                    quickVolumeMuteIcon.appendChild(wave2);
                }
            }
        }
    }

    function setQuickBrightnessValue(value) {
        if (!quickBrightnessSlider) return;
        const rawValue = typeof value === 'number' ? value : parseInt(value, 10);
        const clamped = isNaN(rawValue) ? 80 : Math.max(0, Math.min(100, rawValue));
        quickBrightnessSlider.value = clamped;
        quickBrightnessSlider.style.setProperty('--volume-percent', `${clamped}%`);
        if (quickBrightnessSliderWrap) {
            quickBrightnessSliderWrap.style.setProperty('--volume-percent', `${clamped}%`);
        }
        if (quickBrightnessTooltip && quickBrightnessTooltip.classList.contains('show')) {
            setQuickBrightnessTooltip(clamped);
        }
    }

    function ensureQuickBrightnessTooltipFloating() {
        if (!quickBrightnessTooltip) return;
        if (quickBrightnessTooltip.dataset.floating === 'true') return;
        document.body.appendChild(quickBrightnessTooltip);
        quickBrightnessTooltip.dataset.floating = 'true';
        quickBrightnessTooltip.style.display = 'block';
    }

    function setQuickBrightnessTooltip(value) {
        if (!quickBrightnessTooltip || !quickBrightnessSlider) return;
        ensureQuickBrightnessTooltipFloating();
        const rawValue = typeof value === 'number' ? value : parseInt(quickBrightnessSlider.value || '0', 10);
        const clamped = isNaN(rawValue) ? 0 : Math.max(0, Math.min(100, rawValue));
        quickBrightnessTooltip.textContent = `${clamped}`;
        quickBrightnessSlider.removeAttribute('title');
        quickBrightnessSlider.setAttribute('aria-valuetext', `${clamped}%`);
        const sliderRect = quickBrightnessSlider.getBoundingClientRect();
        const left = sliderRect.left + (sliderRect.width / 2);
        const top = sliderRect.top - 10;
        quickBrightnessTooltip.style.left = `${left}px`;
        quickBrightnessTooltip.style.top = `${top}px`;
    }

    function setQuickNightLightState(enabled) {
        if (quickNightLightButton) {
            quickNightLightButton.setAttribute('aria-pressed', enabled ? 'true' : 'false');
            const diagonal = quickNightLightButton.querySelector('.night-light-diagonal');
            if (diagonal) diagonal.style.display = enabled ? 'none' : 'block';
        }
    }

    function setQuickAutoBrightnessState(enabled) {
        if (quickAutoBrightnessButton) {
            quickAutoBrightnessButton.setAttribute('aria-pressed', enabled ? 'true' : 'false');
            const diagonal = quickAutoBrightnessButton.querySelector('.auto-brightness-diagonal');
            if (diagonal) diagonal.style.display = enabled ? 'none' : 'block';
        }
    }

    function syncQuickBrightnessControls() {
        if (!quickBrightnessSlider) return;
        const savedBrightness = localStorage.getItem('displayBrightness') || quickBrightnessSlider.value || '80';
        setQuickBrightnessValue(savedBrightness);
        const nightLightEnabled = localStorage.getItem('nightLightEnabled') === 'true';
        const autoBrightnessEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
        setQuickNightLightState(nightLightEnabled);
        setQuickAutoBrightnessState(autoBrightnessEnabled);
    }

    function applySystemVolumeToQuickSettings(volume, muted) {
        const clamped = Math.max(0, Math.min(100, Math.round(Number(volume))));
        const nextMuted = Boolean(muted) || clamped === 0;
        const storedVolume = parseInt(localStorage.getItem('volumeLevel'));
        const storedMuted = localStorage.getItem('volumeMuted') === 'true';
        const volumeChanged = isNaN(storedVolume) || storedVolume !== clamped;
        const mutedChanged = storedMuted !== nextMuted;
        if (!volumeChanged && !mutedChanged) return;
        try { localStorage.setItem('volumeLevel', String(clamped)); } catch (err) {}
        try { localStorage.setItem('volumeMuted', String(nextMuted)); } catch (err) {}
        if (clamped > 0) {
            try { localStorage.setItem('volumeLastNonZero', String(clamped)); } catch (err) {}
        }
        updateQuickVolume();
    }

    function renderQuickList(listEl, items, buildItem, emptyText) {
        if (!listEl) return;
        listEl.innerHTML = '';
        if (!items || items.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'quick-settings-empty';
            empty.textContent = emptyText;
            listEl.appendChild(empty);
            return;
        }
        items.forEach(item => listEl.appendChild(buildItem(item)));
    }

    function renderQuickWiFiTileIcon({ enabled, connected, signal }) {
        if (!quickWifiToggle) return;
        const iconSvg = quickWifiToggle.querySelector('.quick-settings-tile-icon svg');
        if (!iconSvg) return;
        const normalizedSignal = typeof signal === 'number'
            ? Math.max(0, Math.min(4, Math.round(signal)))
            : 0;
        const showSlash = !enabled;
        const inactiveOpacity = showSlash ? '1' : '0.25';
        const outerOpacity = showSlash || normalizedSignal >= 4 ? '1' : inactiveOpacity;
        const midOpacity = showSlash || normalizedSignal >= 3 ? '1' : inactiveOpacity;
        const innerOpacity = showSlash || normalizedSignal >= 2 ? '1' : inactiveOpacity;
        const dotOpacity = showSlash || normalizedSignal >= 1 ? '1' : inactiveOpacity;

        iconSvg.innerHTML = `
            <path d="M4 12a12 12 0 0 1 16 0" opacity="${outerOpacity}"></path>
            <path d="M6.5 14.5a9 9 0 0 1 11 0" opacity="${midOpacity}"></path>
            <path d="M9 17a6 6 0 0 1 6 0" opacity="${innerOpacity}"></path>
            <path d="M12 20h.01" opacity="${dotOpacity}"></path>
            ${showSlash ? '<line x1="1" y1="1" x2="23" y2="23" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>' : ''}
        `;
    }

    function renderQuickBluetoothTileIcon({ enabled }) {
        if (!quickBluetoothToggle) return;
        const iconSvg = quickBluetoothToggle.querySelector('.quick-settings-tile-icon svg');
        if (!iconSvg) return;
        const showSlash = !enabled;
        iconSvg.innerHTML = `
            <path d="M6.5 6.5L17.5 17.5L12 23V1L17.5 6.5L6.5 17.5"></path>
            ${showSlash ? '<line x1="1" y1="1" x2="23" y2="23" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line>' : ''}
        `;
    }

    function updateQuickWiFi() {
        const wifiEnabled = getBooleanFromStorage('wifiEnabled', true);
        if (quickWifiToggle) {
            if (wifiToggleBtn) {
                quickWifiToggle.setAttribute('aria-pressed', wifiToggleBtn.getAttribute('aria-pressed') || (wifiEnabled ? 'true' : 'false'));
            } else {
                quickWifiToggle.setAttribute('aria-pressed', wifiEnabled ? 'true' : 'false');
            }
        }

        const networks = Array.isArray(window.currentWiFiNetworks) ? window.currentWiFiNetworks : [];
        const connected = networks.find(network => network.connected);
        if (quickWifiStatus) {
            if (!wifiEnabled) {
                quickWifiStatus.textContent = 'Off';
            } else if (connected) {
                quickWifiStatus.textContent = connected.name || 'Connected';
            } else if (networks.length > 0) {
                quickWifiStatus.textContent = `${networks.length} Networks Available`;
            } else {
                quickWifiStatus.textContent = 'Not Connected';
            }
        }

        const connectedSignal = connected && typeof connected.signal === 'number' ? connected.signal : null;
        const bestSignal = networks.reduce((max, network) => {
            const value = typeof network.signal === 'number' ? network.signal : -1;
            return value > max ? value : max;
        }, -1);
        const displaySignal = connectedSignal !== null
            ? connectedSignal
            : (wifiEnabled ? 4 : Math.max(0, bestSignal));
        renderQuickWiFiTileIcon({
            enabled: wifiEnabled,
            connected: Boolean(connected),
            signal: displaySignal
        });

        if (!wifiEnabled) {
            renderQuickList(quickWifiList, [], () => null, 'Wi-Fi is off.');
            return;
        }

        const sortedNetworks = networks.slice().sort((a, b) => {
            const aSignal = typeof a.signal === 'number' ? a.signal : -1;
            const bSignal = typeof b.signal === 'number' ? b.signal : -1;
            return bSignal - aSignal;
        });
        renderQuickList(quickWifiList, sortedNetworks, (network) => {
            const item = document.createElement('div');
            item.className = 'quick-settings-list-item';

            const icon = document.createElement('div');
            icon.className = 'quick-settings-list-icon';
            icon.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M5 13a10 10 0 0 1 14 0"></path>
                    <path d="M8.5 16.5a6 6 0 0 1 7 0"></path>
                    <path d="M12 20h.01"></path>
                </svg>
            `;

            const name = document.createElement('div');
            name.className = 'quick-settings-list-name';
            name.textContent = network.name;

            const status = document.createElement('div');
            status.className = 'quick-settings-list-status';
            const statusText = network.connected ? 'Connected' : (network.secured ? 'Secured' : 'Open');
            status.textContent = statusText;

            const signal = document.createElement('div');
            signal.className = 'quick-settings-signal';
            const signalValue = typeof network.signal === 'number' ? network.signal : 0;
            for (let i = 1; i <= 4; i += 1) {
                const bar = document.createElement('span');
                bar.className = i <= signalValue ? 'active' : '';
                signal.appendChild(bar);
            }

            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const current = getConnectedWifiSsid();
                if (current && current === network.name) {
                    setConnectedWifiSsid('');
                } else {
                    setConnectedWifiSsid(network.name);
                }
                refreshHostWiFiNetworks().then(updateQuickWiFi);
                updateQuickSettingsPanel();
            });

            item.appendChild(icon);
            item.appendChild(name);
            item.appendChild(status);
            item.appendChild(signal);
            return item;
        }, 'No networks found.');
    }

    function updateQuickBluetooth() {
        const bluetoothEnabled = getBooleanFromStorage('bluetoothEnabled', true);
        if (quickBluetoothToggle) {
            if (bluetoothToggleBtn) {
                quickBluetoothToggle.setAttribute('aria-pressed', bluetoothToggleBtn.getAttribute('aria-pressed') || (bluetoothEnabled ? 'true' : 'false'));
            } else {
                quickBluetoothToggle.setAttribute('aria-pressed', bluetoothEnabled ? 'true' : 'false');
            }
        }
        renderQuickBluetoothTileIcon({ enabled: bluetoothEnabled });

        const devices = Array.isArray(window.currentBluetoothDevices) ? window.currentBluetoothDevices : [];
        const connectedDevices = devices.filter(device => device.connected);
        if (quickBluetoothStatus) {
            if (!bluetoothEnabled) {
                quickBluetoothStatus.textContent = 'Off';
            } else if (connectedDevices.length > 0) {
                quickBluetoothStatus.textContent = `${connectedDevices.length} Devices Connected`;
            } else if (devices.length) {
                quickBluetoothStatus.textContent = `${devices.length} devices detected`;
            } else {
                quickBluetoothStatus.textContent = 'No Devices Detected';
            }
        }

        if (!bluetoothEnabled) {
            renderQuickList(quickBluetoothList, [], () => null, 'Bluetooth is off.');
            return;
        }

        const topDevices = devices.slice(0, 3);
        renderQuickList(quickBluetoothList, topDevices, (device) => {
            const item = document.createElement('div');
            item.className = 'quick-settings-list-item';

            const name = document.createElement('div');
            name.className = 'quick-settings-list-name';
            name.textContent = device.name;

            const status = document.createElement('div');
            status.className = 'quick-settings-list-status';
            if (device.connected) {
                status.textContent = device.battery !== null && device.battery !== undefined ? `${device.battery}%` : 'Connected';
            } else {
                status.textContent = 'Available';
            }

            item.appendChild(name);
            item.appendChild(status);
            return item;
        }, 'No devices found.');
    }

    function renderQuickBatteryTileIcon({ level, charging }) {
        const tile = document.querySelector('.quick-settings-tile[data-quick-tile="battery"]');
        if (!tile) return;
        const iconSvg = tile.querySelector('.quick-settings-tile-icon svg');
        if (!iconSvg) return;
        const clamped = isNaN(level) ? 0 : Math.max(0, Math.min(100, level));

        iconSvg.innerHTML = '';

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', '1');
        rect.setAttribute('y', '6');
        rect.setAttribute('width', '18');
        rect.setAttribute('height', '10');
        rect.setAttribute('rx', '2');
        rect.setAttribute('ry', '2');
        rect.setAttribute('fill', 'none');
        rect.setAttribute('stroke', 'currentColor');
        rect.setAttribute('stroke-width', '2');
        iconSvg.appendChild(rect);

        const terminal = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        terminal.setAttribute('x1', '22');
        terminal.setAttribute('y1', '13');
        terminal.setAttribute('x2', '22');
        terminal.setAttribute('y2', '11');
        terminal.setAttribute('stroke', 'currentColor');
        terminal.setAttribute('stroke-width', '2');
        terminal.setAttribute('stroke-linecap', 'round');
        iconSvg.appendChild(terminal);

        if (clamped > 0) {
            const fillWidth = (clamped / 100) * 18;
            const fill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            fill.setAttribute('x', '2');
            fill.setAttribute('y', '7');
            fill.setAttribute('width', fillWidth.toString());
            fill.setAttribute('height', '8');
            fill.setAttribute('rx', '1');
            fill.setAttribute('ry', '1');
            fill.setAttribute('fill', '#5dade2');
            iconSvg.appendChild(fill);
        }

        if (charging && clamped < 100) {
            const bolt = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            bolt.setAttribute('d', 'M13 2L3 14h8l-2 8 10-12h-8l2-8z');
            bolt.setAttribute('fill', '#5dade2');
            bolt.setAttribute('opacity', '0.9');
            iconSvg.appendChild(bolt);
        }
    }

    function updateQuickBattery() {
        const level = typeof window.currentBatteryLevel === 'number'
            ? Math.round(window.currentBatteryLevel)
            : NaN;
        const charging = window.isCharging === true;
        const quickBatteryLabel = document.getElementById('quick-battery-percent-label');
        if (quickBatteryLabel) {
            quickBatteryLabel.textContent = isNaN(level) ? '--' : `${level}%`;
        }
        if (quickBatteryTime) {
            const text = window.currentBatteryTimeText || (batteryMenuTime ? batteryMenuTime.textContent : '');
            quickBatteryTime.textContent = text || '--';
        }
        renderQuickBatteryTileIcon({ level, charging });
    }

    function updateQuickAirplane() {
        if (!quickAirplaneToggle) return;
        const enabled = getBooleanFromStorage('airplaneModeEnabled', false);
        quickAirplaneToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        if (quickAirplaneStatus) {
            quickAirplaneStatus.textContent = enabled ? 'On' : 'Off';
        }
    }

    function setQuickSettingsMode(mode) {
        const isAudio = mode === 'audio';
        const isWifi = mode === 'wifi';
        const isBluetooth = mode === 'bluetooth';
        const isBattery = mode === 'battery';
        const isResolution = mode === 'resolution';
        const isMain = !isAudio && !isWifi && !isBluetooth && !isBattery && !isResolution;
        if (!quickSettingsMenu) return;
        quickSettingsMenu.classList.toggle('devices-mode', !isMain);
        if (quickAudioDevicesToggle) quickAudioDevicesToggle.setAttribute('aria-expanded', isAudio ? 'true' : 'false');
        if (quickWifiDevicesToggle) quickWifiDevicesToggle.setAttribute('aria-expanded', isWifi ? 'true' : 'false');
        if (quickBluetoothDevicesToggle) quickBluetoothDevicesToggle.setAttribute('aria-expanded', isBluetooth ? 'true' : 'false');
        if (quickBatteryPlansToggle) quickBatteryPlansToggle.setAttribute('aria-expanded', isBattery ? 'true' : 'false');
        if (quickResolutionOptionsToggle) quickResolutionOptionsToggle.setAttribute('aria-expanded', isResolution ? 'true' : 'false');
        if (quickAudioView) quickAudioView.setAttribute('aria-hidden', isAudio ? 'false' : 'true');
        if (quickWifiView) quickWifiView.setAttribute('aria-hidden', isWifi ? 'false' : 'true');
        if (quickBluetoothView) quickBluetoothView.setAttribute('aria-hidden', isBluetooth ? 'false' : 'true');
        if (quickBatteryView) quickBatteryView.setAttribute('aria-hidden', isBattery ? 'false' : 'true');
        if (quickResolutionView) quickResolutionView.setAttribute('aria-hidden', isResolution ? 'false' : 'true');
        if (quickSettingsMainView) quickSettingsMainView.setAttribute('aria-hidden', isMain ? 'false' : 'true');
    }

    function syncQuickAudioDevicesFromSettings() {
        if (!quickAudioOutputDevice || !quickAudioInputDevice) return;
        const settingsOutput = document.getElementById('sound-output-device');
        const settingsInput = document.getElementById('sound-input-device');
        if (settingsOutput) {
            quickAudioOutputDevice.innerHTML = settingsOutput.innerHTML;
            quickAudioOutputDevice.value = settingsOutput.value;
        }
        if (settingsInput) {
            quickAudioInputDevice.innerHTML = settingsInput.innerHTML;
            quickAudioInputDevice.value = settingsInput.value;
        }
    }

    function updateQuickSettingsPanel() {
        updateQuickVolume();
        updateQuickWiFi();
        updateQuickBluetooth();
        updateQuickBattery();
        updateQuickAirplane();
        updateQuickResolutionStatus();
    }

    function refreshQuickSettingsData() {
        const wifiEnabled = getBooleanFromStorage('wifiEnabled', true);
        const bluetoothEnabled = getBooleanFromStorage('bluetoothEnabled', true);
        const networks = Array.isArray(window.currentWiFiNetworks) ? window.currentWiFiNetworks : [];
        const devices = Array.isArray(window.currentBluetoothDevices) ? window.currentBluetoothDevices : [];

        if (wifiEnabled) {
            refreshHostWiFiNetworks();
        }
        if (wifiEnabled && wifiRefreshBtn && networks.length === 0) {
            wifiRefreshBtn.click();
        }
        if (bluetoothEnabled && bluetoothRefreshBtn && devices.length === 0) {
            bluetoothRefreshBtn.click();
        }
    }

    function startQuickSettingsLiveUpdates() {
        if (quickSettingsLiveTimer) return;
        quickSettingsLiveTimer = setInterval(updateQuickSettingsPanel, 2000);
    }

    function stopQuickSettingsLiveUpdates() {
        if (!quickSettingsLiveTimer) return;
        clearInterval(quickSettingsLiveTimer);
        quickSettingsLiveTimer = null;
    }

    window.updateQuickSettingsPanel = updateQuickSettingsPanel;

    if (quickVolumeSlider) {
        if (quickVolumeTooltip) {
            const hoverTarget = quickVolumeSliderWrap || quickVolumeSlider;
            hoverTarget.addEventListener('pointerenter', function() {
                setQuickVolumeTooltip(parseInt(quickVolumeSlider.value));
                quickVolumeTooltip.classList.add('show');
            });
            hoverTarget.addEventListener('pointerleave', function() {
                quickVolumeTooltip.classList.remove('show');
            });
            quickVolumeSlider.addEventListener('focus', function() {
                setQuickVolumeTooltip(parseInt(quickVolumeSlider.value));
                quickVolumeTooltip.classList.add('show');
            });
            quickVolumeSlider.addEventListener('blur', function() {
                quickVolumeTooltip.classList.remove('show');
            });
        }
        quickVolumeSlider.addEventListener('input', function(e) {
            const nextValue = parseInt(e.target.value);
            const clamped = isNaN(nextValue) ? 0 : Math.max(0, Math.min(100, nextValue));
            const muted = clamped === 0;
            if (clamped > 0) {
                try { localStorage.setItem('volumeLastNonZero', String(clamped)); } catch (err) {}
            }

            if (mainVolumeSlider) {
                mainVolumeSlider.value = clamped;
                mainVolumeSlider.dispatchEvent(new Event('input', { bubbles: true }));
            } else {
                try { localStorage.setItem('volumeLevel', String(clamped)); } catch (err) {}
                try { localStorage.setItem('volumeMuted', String(muted)); } catch (err) {}
                if (window.pilkOSSystemAudio && typeof window.pilkOSSystemAudio.setVolume === 'function') {
                    window.pilkOSSystemAudio.setVolume(clamped);
                }
                if (window.pilkOSSystemAudio && typeof window.pilkOSSystemAudio.setMuted === 'function') {
                    window.pilkOSSystemAudio.setMuted(muted);
                }
            }
            updateQuickVolume();
            if (quickVolumeTooltip && quickVolumeTooltip.classList.contains('show')) {
                setQuickVolumeTooltip(clamped);
            }
        });
    }

    if (quickBrightnessSlider) {
        if (quickBrightnessTooltip) {
            const hoverTarget = quickBrightnessSliderWrap || quickBrightnessSlider;
            hoverTarget.addEventListener('pointerenter', function() {
                setQuickBrightnessTooltip(parseInt(quickBrightnessSlider.value, 10));
                quickBrightnessTooltip.classList.add('show');
            });
            hoverTarget.addEventListener('pointerleave', function() {
                quickBrightnessTooltip.classList.remove('show');
            });
            quickBrightnessSlider.addEventListener('focus', function() {
                setQuickBrightnessTooltip(parseInt(quickBrightnessSlider.value, 10));
                quickBrightnessTooltip.classList.add('show');
            });
            quickBrightnessSlider.addEventListener('blur', function() {
                quickBrightnessTooltip.classList.remove('show');
            });
        }
        quickBrightnessSlider.addEventListener('input', function(e) {
            const nextValue = parseInt(e.target.value, 10);
            const clamped = isNaN(nextValue) ? 80 : Math.max(0, Math.min(100, nextValue));
            setQuickBrightnessValue(clamped);
            try { localStorage.setItem('displayBrightness', String(clamped)); } catch (err) {}
            const autoEnabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
            if (autoEnabled) {
                try { localStorage.setItem('autoBrightnessEnabled', 'false'); } catch (err) {}
                setQuickAutoBrightnessState(false);
            }
            if (window.applyBrightness) {
                window.applyBrightness(clamped);
            } else {
                let overlay = document.getElementById('auto-brightness-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'auto-brightness-overlay';
                    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; z-index: 999999; transition: opacity 0.5s ease; opacity: 0;';
                    document.body.appendChild(overlay);
                }
                const opacity = ((100 - clamped) / 100) * 0.8;
                overlay.style.opacity = opacity.toString();
            }
            if (quickBrightnessTooltip && quickBrightnessTooltip.classList.contains('show')) {
                setQuickBrightnessTooltip(clamped);
            }
        });
    }

    if (quickNightLightButton) {
        quickNightLightButton.addEventListener('click', function(e) {
            e.stopPropagation();
            const enabled = localStorage.getItem('nightLightEnabled') === 'true';
            const next = !enabled;
            try { localStorage.setItem('nightLightEnabled', String(next)); } catch (err) {}
            setQuickNightLightState(next);
            if (window.applyNightLight) {
                window.applyNightLight(next);
            } else {
                let overlay = document.getElementById('night-light-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'night-light-overlay';
                    overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 165, 0, 0.15); pointer-events: none; z-index: 999998; transition: opacity 0.5s ease; opacity: 0; mix-blend-mode: multiply;';
                    document.body.appendChild(overlay);
                }
                overlay.style.opacity = next ? '1' : '0';
            }
        });
    }

    if (quickAutoBrightnessButton) {
        quickAutoBrightnessButton.addEventListener('click', function(e) {
            e.stopPropagation();
            const enabled = localStorage.getItem('autoBrightnessEnabled') === 'true';
            const next = !enabled;
            try { localStorage.setItem('autoBrightnessEnabled', String(next)); } catch (err) {}
            setQuickAutoBrightnessState(next);
            if (next) {
                if (window.updateAutoBrightness) {
                    window.updateAutoBrightness();
                } else if (window.calculateTimeBasedBrightness && window.applyBrightness) {
                    window.applyBrightness(window.calculateTimeBasedBrightness());
                }
            } else {
                const savedBrightness = parseInt(localStorage.getItem('displayBrightness') || '80', 10);
                if (window.applyBrightness) {
                    window.applyBrightness(savedBrightness);
                }
            }
        });
    }

    syncQuickBrightnessControls();

    const systemAudio = window.pilkOSSystemAudio;
    async function syncQuickSystemVolume() {
        if (!systemAudio || typeof systemAudio.getStatus !== 'function') return;
        try {
            const status = await systemAudio.getStatus();
            if (status && typeof status.volume === 'number') {
                applySystemVolumeToQuickSettings(status.volume, status.muted);
            }
        } catch (err) {
            // Ignore polling failures; keep last known UI state.
        }
    }

    if (systemAudio && typeof systemAudio.getStatus === 'function') {
        syncQuickSystemVolume();
        if (window.quickSettingsSystemVolumeInterval) {
            clearInterval(window.quickSettingsSystemVolumeInterval);
        }
        window.quickSettingsSystemVolumeInterval = setInterval(syncQuickSystemVolume, 250);
    }

    if (quickVolumeMute) {
        quickVolumeMute.addEventListener('click', function(e) {
            e.stopPropagation();
            let currentVolume = parseInt(localStorage.getItem('volumeLevel'));
            if (isNaN(currentVolume)) currentVolume = 0;
            const isMuted = localStorage.getItem('volumeMuted') === 'true' || currentVolume === 0;

            let nextVolume = 0;
            let nextMuted = true;
            if (isMuted) {
                const lastNonZero = parseInt(localStorage.getItem('volumeLastNonZero'));
                nextVolume = !isNaN(lastNonZero) && lastNonZero > 0 ? lastNonZero : 50;
                nextMuted = false;
            } else {
                if (currentVolume > 0) {
                    try { localStorage.setItem('volumeLastNonZero', String(currentVolume)); } catch (err) {}
                }
                nextVolume = 0;
                nextMuted = true;
            }

            if (mainVolumeSlider) {
                mainVolumeSlider.value = nextVolume;
                mainVolumeSlider.dispatchEvent(new Event('input', { bubbles: true }));
            } else {
                try { localStorage.setItem('volumeLevel', String(nextVolume)); } catch (err) {}
                try { localStorage.setItem('volumeMuted', String(nextMuted)); } catch (err) {}
                if (window.pilkOSSystemAudio && typeof window.pilkOSSystemAudio.setVolume === 'function') {
                    window.pilkOSSystemAudio.setVolume(nextVolume);
                }
                if (window.pilkOSSystemAudio && typeof window.pilkOSSystemAudio.setMuted === 'function') {
                    window.pilkOSSystemAudio.setMuted(nextMuted);
                }
            }
            updateQuickVolume();
        });
    }

    if (quickAudioDevicesToggle) {
        quickAudioDevicesToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            syncQuickAudioDevicesFromSettings();
            setQuickSettingsMode('audio');
        });
    }

    if (quickSettingsOpenSettings) {
        quickSettingsOpenSettings.addEventListener('click', function(e) {
            e.stopPropagation();
            const openSettings = initSettingsWindow();
            if (openSettings) openSettings();
            if (quickSettingsMenu.classList.contains('show')) {
                quickSettingsMenu.classList.remove('show');
                quickSettingsMenu.style.display = 'none';
                stopQuickSettingsLiveUpdates();
                setQuickSettingsMode('main');
            }
        });
    }

    if (quickAudioBack) {
        quickAudioBack.addEventListener('click', function(e) {
            e.stopPropagation();
            setQuickSettingsMode('main');
        });
    }

    if (quickWifiDevicesToggle) {
        quickWifiDevicesToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            if (isQuickSettingsEditing()) return;
            setQuickSettingsMode('wifi');
            refreshHostWiFiNetworks({ force: true }).then(updateQuickWiFi);
        });
    }

    if (quickBluetoothDevicesToggle) {
        quickBluetoothDevicesToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            if (isQuickSettingsEditing()) return;
            updateQuickBluetooth();
            setQuickSettingsMode('bluetooth');
        });
    }

    if (quickWifiBack) {
        quickWifiBack.addEventListener('click', function(e) {
            e.stopPropagation();
            setQuickSettingsMode('main');
        });
    }

    if (quickBluetoothBack) {
        quickBluetoothBack.addEventListener('click', function(e) {
            e.stopPropagation();
            setQuickSettingsMode('main');
        });
    }

    if (quickBatteryPlansToggle) {
        quickBatteryPlansToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            if (isQuickSettingsEditing()) return;
            setQuickSettingsMode('battery');
            const currentPlan = localStorage.getItem('batteryPowerProfile') || 'balanced';
            quickBatteryPlans.forEach((btn) => {
                btn.classList.toggle('active', btn.dataset.plan === currentPlan);
            });
        });
    }

    if (quickBatteryBack) {
        quickBatteryBack.addEventListener('click', function(e) {
            e.stopPropagation();
            setQuickSettingsMode('main');
        });
    }

    function openQuickResolutionView(e) {
        if (e) e.stopPropagation();
        if (isQuickSettingsEditing()) return;
        updateQuickResolutionSelection();
        setQuickSettingsMode('resolution');
    }

    if (quickResolutionOptionsToggle) {
        quickResolutionOptionsToggle.addEventListener('click', openQuickResolutionView);
    }

    if (quickResolutionToggle) {
        quickResolutionToggle.addEventListener('click', openQuickResolutionView);
    }

    if (quickResolutionBack) {
        quickResolutionBack.addEventListener('click', function(e) {
            e.stopPropagation();
            setQuickSettingsMode('main');
        });
    }

    if (quickResolutionOptions.length) {
        quickResolutionOptions.forEach((button) => {
            button.addEventListener('click', function() {
                const id = button.dataset.resolution || 'auto';
                const option = getResolutionOptionById(id);
                setStoredResolutionId(option.id);
                applyResolutionOption(option);
                updateQuickResolutionSelection(option);
            });
        });
    }

    if (quickBatteryPlans.length) {
        quickBatteryPlans.forEach((btn) => {
            btn.addEventListener('click', () => {
                const plan = btn.dataset.plan;
                if (!plan) return;
                try { localStorage.setItem('batteryPowerProfile', plan); } catch (e) {}
                quickBatteryPlans.forEach((item) => item.classList.toggle('active', item === btn));
                if (window.updateBatteryMenuFromBattery) {
                    window.updateBatteryMenuFromBattery();
                }
            });
        });
    }

    if (quickAudioOutputDevice) {
        quickAudioOutputDevice.addEventListener('change', function(e) {
            const settingsOutput = document.getElementById('sound-output-device');
            if (settingsOutput) {
                settingsOutput.value = e.target.value;
                settingsOutput.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }

    if (quickAudioInputDevice) {
        quickAudioInputDevice.addEventListener('change', function(e) {
            const settingsInput = document.getElementById('sound-input-device');
            if (settingsInput) {
                settingsInput.value = e.target.value;
                settingsInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }

    if (mainVolumeSlider) {
        mainVolumeSlider.addEventListener('input', updateQuickVolume);
    }

    if (quickWifiToggle) {
        quickWifiToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            if (isQuickSettingsEditing()) return;
            if (wifiToggleBtn) {
                wifiToggleBtn.click();
            } else {
                const enabled = getBooleanFromStorage('wifiEnabled', true);
                try { localStorage.setItem('wifiEnabled', String(!enabled)); } catch (err) {}
            }
            setTimeout(updateQuickSettingsPanel, 0);
        });
    }

    if (quickWifiRefresh) {
        quickWifiRefresh.addEventListener('click', function(e) {
            e.stopPropagation();
            if (wifiRefreshBtn) wifiRefreshBtn.click();
            refreshHostWiFiNetworks({ force: true }).then(updateQuickWiFi);
            setTimeout(updateQuickSettingsPanel, 300);
        });
    }

    if (quickBluetoothToggle) {
        quickBluetoothToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            if (isQuickSettingsEditing()) return;
            if (bluetoothToggleBtn) {
                bluetoothToggleBtn.click();
            } else {
                const enabled = getBooleanFromStorage('bluetoothEnabled', true);
                try { localStorage.setItem('bluetoothEnabled', String(!enabled)); } catch (err) {}
            }
            setTimeout(updateQuickSettingsPanel, 0);
        });
    }

    if (quickBluetoothRefresh) {
        quickBluetoothRefresh.addEventListener('click', function(e) {
            e.stopPropagation();
            if (bluetoothRefreshBtn) bluetoothRefreshBtn.click();
            setTimeout(updateQuickSettingsPanel, 300);
        });
    }

    if (quickAirplaneToggle) {
        quickAirplaneToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            if (isQuickSettingsEditing()) return;
            const enabled = getBooleanFromStorage('airplaneModeEnabled', false);
            const next = !enabled;
            try { localStorage.setItem('airplaneModeEnabled', String(next)); } catch (err) {}
            if (next) {
                try {
                    localStorage.setItem('airplanePrevWifi', localStorage.getItem('wifiEnabled') || 'false');
                    localStorage.setItem('airplanePrevBluetooth', localStorage.getItem('bluetoothEnabled') || 'false');
                } catch (err) {}
                try { localStorage.setItem('wifiEnabled', 'false'); } catch (err) {}
                try { localStorage.setItem('bluetoothEnabled', 'false'); } catch (err) {}
            } else {
                try {
                    const prevWifi = localStorage.getItem('airplanePrevWifi');
                    const prevBluetooth = localStorage.getItem('airplanePrevBluetooth');
                    if (prevWifi === 'true') localStorage.setItem('wifiEnabled', 'true');
                    if (prevBluetooth === 'true') localStorage.setItem('bluetoothEnabled', 'true');
                    localStorage.removeItem('airplanePrevWifi');
                    localStorage.removeItem('airplanePrevBluetooth');
                } catch (err) {}
            }
            setTimeout(updateQuickSettingsPanel, 0);
        });
    }

    function positionQuickSettingsMenu() {
        const rect = quickControlItem.getBoundingClientRect();
        positionDockMenuForControl(quickSettingsMenu, rect, { menuWidth: 360, menuHeight: 560 });
    }

    let lastQuickSettingsToggleAt = 0;
    function handleQuickSettingsToggle(e) {
        if (e && e.__quickSettingsHandled) return;
        if (e) {
            e.__quickSettingsHandled = true;
            e.stopPropagation();
            e.preventDefault();
        }
        const now = Date.now();
        if (now - lastQuickSettingsToggleAt < 50) return;
        lastQuickSettingsToggleAt = now;
        const wasOpen = quickSettingsMenu.classList.contains('show');
        closeAllMenus();
        if (!wasOpen) {
            quickSettingsMenu.style.display = 'flex';
            quickSettingsMenu.classList.add('show');
            setQuickSettingsMode('main');
            setQuickSettingsEditMode(false);
            startQuickSettingsLiveUpdates();
            setTimeout(positionQuickSettingsMenu, 0);
            try {
                refreshQuickSettingsData();
                updateQuickSettingsPanel();
                syncQuickBrightnessControls();
            } catch (err) {
                console.error('Quick Settings update failed:', err);
            }
        } else {
            quickSettingsMenu.classList.remove('show');
            quickSettingsMenu.style.display = 'none';
            stopQuickSettingsLiveUpdates();
            setQuickSettingsMode('main');
        }
    }

    window.toggleQuickSettingsMenu = handleQuickSettingsToggle;

    quickControlItem.addEventListener('click', handleQuickSettingsToggle, { capture: true });
    quickSettingsIcon.addEventListener('click', handleQuickSettingsToggle, { capture: true });

    document.addEventListener('click', function(e) {
        if (quickSettingsMenu.classList.contains('show')) {
            const clickedControl = quickControlItem.contains(e.target);
            const clickedMenu = quickSettingsMenu.contains(e.target);
            if (!clickedControl && !clickedMenu) {
                quickSettingsMenu.classList.remove('show');
                quickSettingsMenu.style.display = 'none';
                stopQuickSettingsLiveUpdates();
                setQuickSettingsMode('main');
            }
        }
    });

    window.addEventListener('resize', function() {
        updateQuickResolutionStatus();
        if (quickSettingsMenu.classList.contains('show')) {
            positionQuickSettingsMenu();
        }
    });

    updateQuickSettingsPanel();
}

// Virtual Desktops (Task View)
const VIRTUAL_DESKTOP_STATE_STORAGE_KEY = 'virtualDesktopState';
const VIRTUAL_DESKTOP_WINDOW_MAP_STORAGE_KEY = 'virtualDesktopWindowMap';
let virtualDesktopState = null;
let virtualDesktopOverlay = null;
let virtualDesktopInitialized = false;
let virtualDesktopObserver = null;
let virtualDesktopPreviewTimer = null;
let virtualDesktopPreviewRequested = false;
const virtualDesktopPreviewInFlight = new Map();

function buildDefaultVirtualDesktops() {
    const now = Date.now();
    return [
        { id: `desktop-${now}-1`, name: 'Desktop 1' },
        { id: `desktop-${now}-2`, name: 'Desktop 2' }
    ];
}

function loadVirtualDesktopState() {
    let state = null;
    try {
        const raw = localStorage.getItem(VIRTUAL_DESKTOP_STATE_STORAGE_KEY);
        if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && Array.isArray(parsed.desktops) && parsed.desktops.length > 0) {
                state = parsed;
            }
        }
    } catch (e) {
        state = null;
    }

    if (!state) {
        state = {
            desktops: buildDefaultVirtualDesktops(),
            activeId: null
        };
    }

    const validIds = new Set(state.desktops.map(d => d.id));
    if (!state.activeId || !validIds.has(state.activeId)) {
        state.activeId = state.desktops[0].id;
    }

    return state;
}

function saveVirtualDesktopState() {
    if (!virtualDesktopState) return;
    try {
        localStorage.setItem(VIRTUAL_DESKTOP_STATE_STORAGE_KEY, JSON.stringify(virtualDesktopState));
    } catch (e) {
        // ignore storage errors
    }
}

function readWindowDesktopMap() {
    try {
        const raw = localStorage.getItem(VIRTUAL_DESKTOP_WINDOW_MAP_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') return parsed;
        return {};
    } catch (e) {
        return {};
    }
}

function writeWindowDesktopMap(map) {
    try {
        localStorage.setItem(VIRTUAL_DESKTOP_WINDOW_MAP_STORAGE_KEY, JSON.stringify(map));
    } catch (e) {
        // ignore storage errors
    }
}

function setWindowDesktopMapping(windowId, desktopId) {
    if (!windowId) return;
    const map = readWindowDesktopMap();
    map[windowId] = desktopId;
    writeWindowDesktopMap(map);
}

function removeWindowDesktopMapping(windowId) {
    if (!windowId) return;
    const map = readWindowDesktopMap();
    if (map[windowId]) {
        delete map[windowId];
        writeWindowDesktopMap(map);
    }
}

function ensureWindowDesktopId(win) {
    if (!win || !virtualDesktopState) return null;
    const existing = win.dataset ? win.dataset.desktopId : null;
    if (existing && virtualDesktopState.desktops.some(d => d.id === existing)) {
        return existing;
    }

    const windowId = win.id || (win.getAttribute ? win.getAttribute('id') : '');
    let desktopId = null;
    if (windowId) {
        const map = readWindowDesktopMap();
        desktopId = map[windowId] || null;
    }

    if (!desktopId || !virtualDesktopState.desktops.some(d => d.id === desktopId)) {
        desktopId = virtualDesktopState.activeId;
    }

    if (win.dataset) {
        win.dataset.desktopId = desktopId;
    }
    if (windowId) {
        setWindowDesktopMapping(windowId, desktopId);
    }

    return desktopId;
}

function updateAppBarVisibilityForDesktop(activeId) {
    if (!activeId) return;
    windowAppBarIcons.forEach((icon) => {
        const win = icon._window;
        if (!win) return;
        const desktopId = win.dataset ? win.dataset.desktopId : null;
        const resolvedId = desktopId || activeId;
        if (resolvedId !== activeId) {
            icon.classList.add('dock-item-desktop-hidden');
        } else {
            icon.classList.remove('dock-item-desktop-hidden');
        }
    });
}

function focusTopmostWindowForDesktop() {
    const visibleWindows = Array.from(document.querySelectorAll('.window')).filter(win => {
        if (win.classList.contains('window-desktop-hidden')) return false;
        return win.style.display !== 'none';
    });

    if (visibleWindows.length === 0) {
        document.querySelectorAll('.window.window-focused').forEach(win => {
            win.classList.remove('window-focused');
            updateWindowAppBarState(win, false, isWindowMinimized(win));
        });
        return;
    }

    const topmost = visibleWindows.reduce((best, win) => {
        const z = parseInt(win.style.zIndex) || 0;
        const bestZ = parseInt(best.style.zIndex) || 0;
        return z >= bestZ ? win : best;
    }, visibleWindows[0]);
    focusWindow(topmost);
    try { topmost.focus(); } catch (e) {}
}

function updateWindowVisibilityForDesktop() {
    if (!virtualDesktopState) return;
    const activeId = virtualDesktopState.activeId;
    const windows = document.querySelectorAll('.window');
    windows.forEach(win => {
        const desktopId = ensureWindowDesktopId(win);
        if (desktopId !== activeId) {
            win.classList.add('window-desktop-hidden');
        } else {
            win.classList.remove('window-desktop-hidden');
        }
    });
    updateAppBarVisibilityForDesktop(activeId);

    const focusedWindow = document.querySelector('.window.window-focused');
    if (!focusedWindow || focusedWindow.classList.contains('window-desktop-hidden') || focusedWindow.style.display === 'none') {
        focusTopmostWindowForDesktop();
    }
    if (virtualDesktopOverlay && virtualDesktopOverlay.classList.contains('show')) {
        scheduleVirtualDesktopPreviewRefresh();
    }
}

function canRenderDesktopPreviews() {
    return typeof window.html2canvas === 'function' && !!document.getElementById('desktop');
}

function renderDesktopPreviewForDesktop(desktopId, targetEl) {
    if (!desktopId || !targetEl || !canRenderDesktopPreviews()) return;
    if (!virtualDesktopOverlay || !virtualDesktopOverlay.classList.contains('show')) return;
    if (virtualDesktopPreviewInFlight.get(desktopId)) return;
    const desktopEl = document.getElementById('desktop');
    if (!desktopEl) return;

    virtualDesktopPreviewInFlight.set(desktopId, true);

    window.html2canvas(desktopEl, {
        backgroundColor: null,
        scale: 0.2,
        useCORS: true,
        onclone: (doc) => {
            const overlay = doc.getElementById('virtual-desktop-overlay');
            if (overlay) overlay.style.display = 'none';
            const startMenu = doc.getElementById('start-menu');
            if (startMenu) startMenu.classList.remove('show');
            const quickSettings = doc.getElementById('quick-settings-menu');
            if (quickSettings) quickSettings.style.display = 'none';
            const contextMenu = doc.getElementById('desktop-context-menu');
            if (contextMenu) contextMenu.style.display = 'none';

            const windows = doc.querySelectorAll('.window');
            windows.forEach(win => {
                const winDesktopId = win.dataset ? win.dataset.desktopId : null;
                const isMinimized = win.style.display === 'none' || win.classList.contains('window-desktop-hidden');
                if (winDesktopId !== desktopId || isMinimized) {
                    win.style.display = 'none';
                }
            });
        }
    }).then(canvas => {
        if (!virtualDesktopOverlay || !virtualDesktopOverlay.classList.contains('show')) return;
        const img = targetEl.querySelector('img') || document.createElement('img');
        img.alt = `Preview for ${desktopId}`;
        img.src = canvas.toDataURL('image/png');
        if (!img.parentElement) {
            targetEl.appendChild(img);
        }
    }).catch(() => {
        // ignore preview failures
    }).finally(() => {
        virtualDesktopPreviewInFlight.delete(desktopId);
    });
}

function refreshVirtualDesktopPreviews() {
    if (!virtualDesktopOverlay || !virtualDesktopOverlay.classList.contains('show')) return;
    if (!canRenderDesktopPreviews()) return;
    const previewEls = virtualDesktopOverlay.querySelectorAll('.virtual-desktop-preview');
    previewEls.forEach(el => {
        const desktopId = el.dataset.desktopId;
        renderDesktopPreviewForDesktop(desktopId, el);
    });
}

function scheduleVirtualDesktopPreviewRefresh() {
    if (virtualDesktopPreviewRequested) return;
    virtualDesktopPreviewRequested = true;
    requestAnimationFrame(() => {
        virtualDesktopPreviewRequested = false;
        refreshVirtualDesktopPreviews();
    });
}

function startVirtualDesktopPreviewUpdates() {
    if (virtualDesktopPreviewTimer) return;
    refreshVirtualDesktopPreviews();
    virtualDesktopPreviewTimer = setInterval(() => {
        if (!virtualDesktopOverlay || !virtualDesktopOverlay.classList.contains('show')) return;
        refreshVirtualDesktopPreviews();
    }, 2000);
}

function stopVirtualDesktopPreviewUpdates() {
    if (virtualDesktopPreviewTimer) {
        clearInterval(virtualDesktopPreviewTimer);
        virtualDesktopPreviewTimer = null;
    }
}

function getNextDesktopName() {
    const numbers = virtualDesktopState.desktops
        .map(d => {
            const match = String(d.name || '').match(/^Desktop\s+(\d+)$/i);
            return match ? parseInt(match[1], 10) : 0;
        })
        .filter(n => !isNaN(n));
    const maxNumber = numbers.length ? Math.max(...numbers) : virtualDesktopState.desktops.length;
    return `Desktop ${maxNumber + 1}`;
}

function moveWindowToDesktop(win, desktopId) {
    if (!win || !virtualDesktopState || !desktopId) return;
    const valid = virtualDesktopState.desktops.some(d => d.id === desktopId);
    if (!valid) return;
    if (win.dataset) {
        win.dataset.desktopId = desktopId;
    }
    const windowId = win.id || (win.getAttribute ? win.getAttribute('id') : '');
    if (windowId) {
        setWindowDesktopMapping(windowId, desktopId);
    }
    updateWindowVisibilityForDesktop();
}

function createDesktop(name) {
    if (!virtualDesktopState) return null;
    const desktop = {
        id: `desktop-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        name: name || getNextDesktopName()
    };
    virtualDesktopState.desktops.push(desktop);
    virtualDesktopState.activeId = desktop.id;
    saveVirtualDesktopState();
    updateWindowVisibilityForDesktop();
    renderVirtualDesktopList();
    return desktop;
}

function removeDesktop(desktopId) {
    if (!virtualDesktopState) return;
    if (virtualDesktopState.desktops.length <= 1) return;
    const index = virtualDesktopState.desktops.findIndex(d => d.id === desktopId);
    if (index === -1) return;

    const remaining = virtualDesktopState.desktops.filter(d => d.id !== desktopId);
    virtualDesktopState.desktops = remaining;
    if (virtualDesktopState.activeId === desktopId) {
        virtualDesktopState.activeId = remaining[Math.max(0, index - 1)].id;
    }

    const windows = document.querySelectorAll('.window');
    windows.forEach(win => {
        if (win.dataset && win.dataset.desktopId === desktopId) {
            moveWindowToDesktop(win, virtualDesktopState.activeId);
        }
    });

    saveVirtualDesktopState();
    updateWindowVisibilityForDesktop();
    renderVirtualDesktopList();
}

function renderVirtualDesktopList() {
    if (!virtualDesktopOverlay || !virtualDesktopState) return;
    const list = virtualDesktopOverlay.querySelector('.virtual-desktop-list');
    if (!list) return;
    list.innerHTML = '';

    const focusedWindow = document.querySelector('.window.window-focused');

    virtualDesktopState.desktops.forEach(desktop => {
        const isActive = desktop.id === virtualDesktopState.activeId;
        const windows = Array.from(document.querySelectorAll('.window')).filter(win => {
            return ensureWindowDesktopId(win) === desktop.id;
        });
        const minimizedCount = windows.filter(win => isWindowMinimized(win)).length;

        const card = document.createElement('div');
        card.className = `virtual-desktop-card${isActive ? ' active' : ''}`;
        card.setAttribute('role', 'button');
        card.setAttribute('tabindex', '0');
        card.addEventListener('click', () => {
            setActiveDesktop(desktop.id, { closeOverlay: true });
        });
        card.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                setActiveDesktop(desktop.id, { closeOverlay: true });
            }
        });

        const header = document.createElement('div');
        header.className = 'virtual-desktop-card-header';

        const name = document.createElement('div');
        name.className = 'virtual-desktop-card-name';
        name.textContent = desktop.name || 'Desktop';

        const badge = document.createElement('div');
        badge.className = 'virtual-desktop-card-badge';
        badge.textContent = isActive ? 'Active' : `${windows.length} windows`;

        header.appendChild(name);
        header.appendChild(badge);

        const preview = document.createElement('div');
        preview.className = 'virtual-desktop-preview';
        preview.dataset.desktopId = desktop.id;
        const previewImg = document.createElement('img');
        previewImg.alt = `${desktop.name || 'Desktop'} preview`;
        preview.appendChild(previewImg);

        const meta = document.createElement('div');
        meta.className = 'virtual-desktop-card-meta';
        if (windows.length === 0) {
            meta.textContent = 'No windows';
        } else if (minimizedCount > 0) {
            meta.textContent = `${windows.length} total, ${minimizedCount} minimized`;
        } else {
            meta.textContent = `${windows.length} total`;
        }

        const actions = document.createElement('div');
        actions.className = 'virtual-desktop-card-actions';

        const moveBtn = document.createElement('button');
        moveBtn.type = 'button';
        moveBtn.className = 'virtual-desktop-action-btn';
        moveBtn.textContent = 'Move focused window';
        const canMove = focusedWindow && ensureWindowDesktopId(focusedWindow) !== desktop.id;
        moveBtn.disabled = !canMove;
        moveBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!focusedWindow) return;
            moveWindowToDesktop(focusedWindow, desktop.id);
            renderVirtualDesktopList();
        });

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'virtual-desktop-action-btn danger';
        removeBtn.textContent = 'Remove';
        removeBtn.disabled = virtualDesktopState.desktops.length <= 1;
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeDesktop(desktop.id);
        });

        actions.appendChild(moveBtn);
        actions.appendChild(removeBtn);

        card.appendChild(header);
        card.appendChild(preview);
        card.appendChild(meta);
        card.appendChild(actions);
        list.appendChild(card);
    });
    if (virtualDesktopOverlay.classList.contains('show')) {
        scheduleVirtualDesktopPreviewRefresh();
    }
}

function showVirtualDesktopOverlay() {
    if (!virtualDesktopOverlay) return;
    renderVirtualDesktopList();
    virtualDesktopOverlay.classList.add('show');
    startVirtualDesktopPreviewUpdates();
}

function hideVirtualDesktopOverlay() {
    if (!virtualDesktopOverlay) return;
    virtualDesktopOverlay.classList.remove('show');
    stopVirtualDesktopPreviewUpdates();
}

function setActiveDesktop(desktopId, options = {}) {
    if (!virtualDesktopState || !desktopId) return;
    if (virtualDesktopState.activeId === desktopId) {
        if (options.closeOverlay) hideVirtualDesktopOverlay();
        return;
    }
    if (!virtualDesktopState.desktops.some(d => d.id === desktopId)) return;
    virtualDesktopState.activeId = desktopId;
    saveVirtualDesktopState();
    updateWindowVisibilityForDesktop();
    renderVirtualDesktopList();
    if (options.closeOverlay) hideVirtualDesktopOverlay();
}

function initVirtualDesktops() {
    if (virtualDesktopInitialized) return;
    virtualDesktopInitialized = true;

    virtualDesktopState = loadVirtualDesktopState();

    if (!virtualDesktopOverlay) {
        virtualDesktopOverlay = document.createElement('div');
        virtualDesktopOverlay.id = 'virtual-desktop-overlay';
        virtualDesktopOverlay.className = 'virtual-desktop-overlay';
        virtualDesktopOverlay.innerHTML = `
            <div class="virtual-desktop-panel" role="dialog" aria-label="Virtual Desktops">
                <div class="virtual-desktop-header">
                    <div class="virtual-desktop-title">Virtual Desktops</div>
                    <button class="virtual-desktop-add" type="button">New desktop</button>
                </div>
                <div class="virtual-desktop-list" role="list"></div>
            </div>
        `;
        document.body.appendChild(virtualDesktopOverlay);
    }

    const addBtn = virtualDesktopOverlay.querySelector('.virtual-desktop-add');
    if (addBtn) {
        addBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            createDesktop();
        });
    }

    const desktopIcon = document.getElementById('virtual-desktops-icon');
    const desktopControl = desktopIcon ? desktopIcon.closest('.dock-control-item') : null;

    const handleToggle = (e) => {
        if (e && e.__virtualDesktopHandled) return;
        if (e) {
            e.__virtualDesktopHandled = true;
            e.stopPropagation();
            e.preventDefault();
        }
        const isOpen = virtualDesktopOverlay.classList.contains('show');
        closeAllMenus();
        if (!isOpen) {
            showVirtualDesktopOverlay();
        } else {
            hideVirtualDesktopOverlay();
        }
    };

    if (desktopControl) {
        desktopControl.addEventListener('click', handleToggle, { capture: true });
    }
    if (desktopIcon) {
        desktopIcon.addEventListener('click', handleToggle, { capture: true });
    }

    document.addEventListener('click', (e) => {
        if (!virtualDesktopOverlay.classList.contains('show')) return;
        const panel = virtualDesktopOverlay.querySelector('.virtual-desktop-panel');
        const clickedPanel = panel && panel.contains(e.target);
        const clickedControl = desktopControl && desktopControl.contains(e.target);
        if (!clickedPanel && !clickedControl) {
            hideVirtualDesktopOverlay();
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && virtualDesktopOverlay.classList.contains('show')) {
            hideVirtualDesktopOverlay();
        }
    });

    const windowsContainer = document.getElementById('windows-container');
    if (windowsContainer && !virtualDesktopObserver) {
        virtualDesktopObserver = new MutationObserver((mutations) => {
            let shouldRender = false;
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType !== Node.ELEMENT_NODE) return;
                    if (node.classList && node.classList.contains('window')) {
                        ensureWindowDesktopId(node);
                        updateWindowVisibilityForDesktop();
                        shouldRender = true;
                    }
                });
                mutation.removedNodes.forEach(node => {
                    if (node.nodeType !== Node.ELEMENT_NODE) return;
                    if (node.classList && node.classList.contains('window')) {
                        const windowId = node.id || (node.getAttribute ? node.getAttribute('id') : '');
                        if (windowId) removeWindowDesktopMapping(windowId);
                        shouldRender = true;
                    }
                });
            });
            if (shouldRender && virtualDesktopOverlay.classList.contains('show')) {
                renderVirtualDesktopList();
            }
            if (shouldRender) {
                setTimeout(() => updateAppBarVisibilityForDesktop(virtualDesktopState.activeId), 0);
            }
        });
        virtualDesktopObserver.observe(windowsContainer, { childList: true });
    }

    updateWindowVisibilityForDesktop();
    renderVirtualDesktopList();
}

async function initDesktop() {
    // Check if already initialized to prevent duplicate initialization
    const desktop = document.getElementById('desktop');
    if (!desktop) {
        console.error('initDesktop: Desktop element not found');
        return;
    }

    // Hard guard: if we've already fully initialized once, don't re-run boot.
    // This prevents restored app windows from flashing due to double-restore on refresh.
    if (desktop.hasAttribute('data-initialized')) {
        return;
    }
    
    if (desktop.hasAttribute('data-initializing')) {
        return;
    }
    
    // Ensure desktop is visible
    if (desktop.style.display === 'none') {
        desktop.style.display = 'flex';
    }
    
    desktop.setAttribute('data-initializing', 'true');

    // Capture the pre-refresh focused window *before* any app/window restore runs.
    // Some initializers (e.g. Settings) may create/focus windows; if we capture after that,
    // we lose the true "last focused before refresh" window.
    let bootFocusedWindowId = null;
    try {
        bootFocusedWindowId = localStorage.getItem('focusedWindowId');
    } catch (e) {
        bootFocusedWindowId = null;
    }

    // During boot/restore, suppress persisting focusedWindowId so restore order doesn't overwrite it.
    suppressFocusPersistence = true;
    
    // Apply dock tooltips visibility setting on page load
    updateDockTooltipsVisibility();
    initDockAutoHide();
    updateDockAutoHideState();
    restoreDesktopBackground();
    initClock();
    initPowerActions();
    initBattery();
    initVolume();
    initVolumeMenu();
    initWiFi();
    initQuickSettings();
    initVirtualDesktops();
    initTooltips();
    initWeatherIconVisibility(); // Apply weather icon visibility setting
    initDockControlsVisibility(); // Apply dock controls visibility settings
    initWeather();
    initAutoBrightness(); // Initialize auto brightness globally
    initNightLight(); // Initialize night light globally
    initSettingsWindow();
    await initFileSystem(); // Initialize virtual file system first

    // Desktop icons are part of the "shell" UX  render them as soon as the FS exists.
    // Restoring app windows can be slower; do that in the background so refreshes feel snappy.
    initDesktopIcons();
    initDesktopContextMenu();
    initStartMenu();

    initFileExplorer(); // Initialize File Explorer (will restore if was open, and properties windows too)
    initViewer(); // Initialize Viewer (restores windows that were open before refresh)
    initPaint(); // Initialize Paint (restores windows that were open before refresh)
    initCalculate(); // Initialize Calculate (restores windows that were open before refresh)
    initPlayer(); // Initialize Player (restores windows that were open before refresh)
    const editorRestorePromise = restoreEditorWindows().catch(err => {
        console.warn('Error restoring Editor windows:', err);
    });
    
    // Restore Task Manager if it was open last session
    try {
        if (localStorage.getItem(TASK_MANAGER_OPEN_STORAGE_KEY) === 'true') {
            const openTaskManager = initTaskManager();
            if (openTaskManager) {
                // Restore on refresh: reuse last saved geometry/minimized state.
                openTaskManager({ restore: true });
            }
        }
    } catch (e) {
        // ignore storage errors
    }

    // Restore focus after app windows finish restoring.
    // Use a short retry loop because some apps restore asynchronously and/or use microtasks.
    function restoreBootFocus() {
        const startedAt = Date.now();
        const maxWaitMs = 3000;
        const tickMs = 80;

        const tick = () => {
            const id = bootFocusedWindowId;
            if (id) {
                const el = document.getElementById(id);
                if (el && el.classList.contains('window') && el.style.display !== 'none' && !el.classList.contains('window-desktop-hidden')) {
                    focusWindow(el);
                    try { el.focus(); } catch (e) {}
                    return true;
                }
            }

            // Fallback: focus the topmost visible window (if any)
            const wins = Array.from(document.querySelectorAll('.window')).filter(w => w.style.display !== 'none' && !w.classList.contains('window-desktop-hidden'));
            if (!id && wins.length === 1) {
                focusWindow(wins[0]);
                try { wins[0].focus(); } catch (e) {}
                return true;
            }

            if (Date.now() - startedAt >= maxWaitMs) {
                if (wins.length > 0) {
                    const topmost = wins.reduce((best, w) => {
                        const z = parseInt(w.style.zIndex) || 0;
                        const bestZ = parseInt(best.style.zIndex) || 0;
                        return z >= bestZ ? w : best;
                    }, wins[0]);
                    focusWindow(topmost);
                    try { topmost.focus(); } catch (e) {}
                }
                return true;
            }
            return false;
        };

        if (tick()) return;
        const interval = setInterval(() => {
            if (tick()) clearInterval(interval);
        }, tickMs);
    }

    Promise.resolve(editorRestorePromise).finally(() => {
        suppressFocusPersistence = false;
        restoreBootFocus();
    });
    
    desktop.setAttribute('data-initialized', 'true');
    desktop.removeAttribute('data-initializing');
    
    // Fix all windows to ensure they're fully visible (including controls)
    setTimeout(() => {
        const allWindows = document.querySelectorAll('.window');
        allWindows.forEach(win => {
            validateAndFixWindowPosition(win);
        });
    }, 300);
    
    // Run again after longer delay to ensure everything is rendered
    setTimeout(() => {
        const allWindows = document.querySelectorAll('.window');
        allWindows.forEach(win => {
            validateAndFixWindowPosition(win);
        });
    }, 1000);
    
    // (Focus restore now handled via restoreBootFocus() above)
    
    // Add window resize listener to fix windows when browser is resized
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const allWindows = document.querySelectorAll('.window');
            allWindows.forEach(win => {
                validateAndFixWindowPosition(win);
            });
        }, 100);
    });
}

// Save Editor and Files window state when page is about to unload
window.addEventListener('beforeunload', function() {
    // Save focused window ID
    const focusedWindow = document.querySelector('.window-focused');
    if (focusedWindow && focusedWindow.id) {
        localStorage.setItem('focusedWindowId', focusedWindow.id);
    }
    
    saveEditorWindowsState();
    if (typeof globalSaveSettingsWindowsState === 'function') {
        globalSaveSettingsWindowsState();
    }
    if (globalSaveFileExplorerWindowsState) {
        globalSaveFileExplorerWindowsState();
    }
    if (window.savePropertiesWindowsState) {
        window.savePropertiesWindowsState();
    }
    if (window.saveTaskManagerWindowState) {
        window.saveTaskManagerWindowState();
    }
    if (typeof globalSaveCalculateWindowsState === 'function') {
        globalSaveCalculateWindowsState();
    }
    if (typeof globalSavePlayerWindowsState === 'function') {
        globalSavePlayerWindowsState();
    }
});

// Also save on pagehide (more reliable for mobile browsers)
window.addEventListener('pagehide', function() {
    saveEditorWindowsState();
    if (typeof globalSaveSettingsWindowsState === 'function') {
        globalSaveSettingsWindowsState();
    }
    if (globalSaveFileExplorerWindowsState) {
        globalSaveFileExplorerWindowsState();
    }
    if (window.savePropertiesWindowsState) {
        window.savePropertiesWindowsState();
    }
    if (window.saveTaskManagerWindowState) {
        window.saveTaskManagerWindowState();
    }
    if (typeof globalSaveCalculateWindowsState === 'function') {
        globalSaveCalculateWindowsState();
    }
    if (typeof globalSavePlayerWindowsState === 'function') {
        globalSavePlayerWindowsState();
    }
});

// Also save on visibilitychange (when tab becomes hidden)
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'hidden') {
        saveEditorWindowsState();
        if (typeof globalSaveSettingsWindowsState === 'function') {
            globalSaveSettingsWindowsState();
        }
        if (globalSaveFileExplorerWindowsState) {
            globalSaveFileExplorerWindowsState();
        }
        if (window.savePropertiesWindowsState) {
            window.savePropertiesWindowsState();
        }
        if (window.saveTaskManagerWindowState) {
            window.saveTaskManagerWindowState();
        }
        if (typeof globalSaveCalculateWindowsState === 'function') {
            globalSaveCalculateWindowsState();
        }
        if (typeof globalSavePlayerWindowsState === 'function') {
            globalSavePlayerWindowsState();
        }
}
});


